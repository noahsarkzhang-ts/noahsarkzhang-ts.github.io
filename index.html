<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.5.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.5.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.5.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.5.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="不畏将来，不念过往">
<meta name="keywords" content="Java">
<meta property="og:type" content="website">
<meta property="og:title" content="以太格">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="以太格">
<meta property="og:description" content="不畏将来，不念过往">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="以太格">
<meta name="twitter:description" content="不畏将来，不念过往">






  <link rel="canonical" href="http://yoursite.com/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>以太格</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">以太格</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-commonweal">

    
    
    
      
    

    

    <a href="/404/" rel="section"><i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>公益 404</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于我</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/10/17/alligator-protocol-bufffer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2021/10/17/alligator-protocol-bufffer/" class="post-title-link" itemprop="http://yoursite.com/index.html">Alligator 系列：Protocol Buffer</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2021-10-17 15:11:22 / 修改时间：23:13:12" itemprop="dateCreated datePublished" datetime="2021-10-17T15:11:22+08:00">2021-10-17</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Alligator网关/" itemprop="url" rel="index"><span itemprop="name">Alligator网关</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">34k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">31 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>在系统中，Protocol Buffer 的使用有两种方式：1）定义 .proto 文件，生成相应的 Bean 对象及序列化的代码；2）根据现有的 Java Bean 对象，动态生成对应的 schema, 使用工具类完成对象的序列化。这两种方式的优缺点也比较明显，.proto 文件支持向前、向后兼容，后者使用简单，引用工具类，便可支持序列化操作，缺点是存在代码兼容性问题。</p>
<font color="red"><strong> 说明: </strong></font><br><font color="red">这篇文章只是简单讲述两种方式的使用，详细的内容请参考官方文档。</font>

<h2 id="2-定义-proto-文件"><a href="#2-定义-proto-文件" class="headerlink" title="2. 定义 proto 文件"></a>2. 定义 proto 文件</h2><h3 id="2-1-安装部署-Protocol-Buffer-编译器"><a href="#2-1-安装部署-Protocol-Buffer-编译器" class="headerlink" title="2.1 安装部署 Protocol Buffer 编译器"></a>2.1 安装部署 Protocol Buffer 编译器</h3><p>以 windows 环境为例，从官方下载 Protocol Buffer，如 protoc-3.18.1-win64.zip, 解压缩到指定目录，并将 bin 目录加到 Path 环境变量中即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SET PROTOC_HOME=D:\app\protoc-3.18.1-win64</span><br><span class="line">SET PATH=%PAHTH%;%PROTOC_HOME%\bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看版本</span></span><br><span class="line">C:\Users\Admin&gt;protoc --version</span><br><span class="line">libprotoc 3.18.1</span><br></pre></td></tr></table></figure>
<p><font color="red"><strong>下载地址:</strong></font><br><a href="ttps://github.com/protocolbuffers/protobuf/releases/tag/v3.18.1" target="_blank" rel="noopener">https://github.com/protocolbuffers/protobuf/releases/tag/v3.18.1</a></p>
<h3 id="2-2-定义-proto-文件"><a href="#2-2-定义-proto-文件" class="headerlink" title="2.2 定义 proto 文件"></a>2.2 定义 proto 文件</h3><p>在官方的 addressbook.proto 文件基础上，添加了 map 对象的变量 people_map，在真实场景中，该对象可以通过 peoples 列表遍历得到，不需要传递 map 对象，否则会传输两份数据，在这里仅仅是演示作用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [START declaration]</span></span><br><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"><span class="keyword">package</span> tutorial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"google/protobuf/timestamp.proto"</span>;</span><br><span class="line"><span class="comment">// [END declaration]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// [START java_declaration]</span></span><br><span class="line">option java_multiple_files = <span class="literal">true</span>;</span><br><span class="line">option java_package = <span class="string">"com.example.tutorial.protos"</span>;</span><br><span class="line">option java_outer_classname = <span class="string">"AddressBookProtos"</span>;</span><br><span class="line"><span class="comment">// [END java_declaration]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// [START messages]</span></span><br><span class="line">message Person &#123;</span><br><span class="line">  <span class="keyword">string</span> name = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int32</span> id = <span class="number">2</span>;  <span class="comment">// Unique ID number for this person.</span></span><br><span class="line">  <span class="keyword">string</span> email = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  enum PhoneType &#123;</span><br><span class="line">    MOBILE = <span class="number">0</span>;</span><br><span class="line">    HOME = <span class="number">1</span>;</span><br><span class="line">    WORK = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  message PhoneNumber &#123;</span><br><span class="line">    <span class="keyword">string</span> number = <span class="number">1</span>;</span><br><span class="line">    PhoneType <span class="keyword">type</span> = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  repeated PhoneNumber phones = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">  google.protobuf.Timestamp last_updated = <span class="number">5</span>;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Our address book file.</span></span><br><span class="line">message AddressBook &#123;</span><br><span class="line">  repeated Person peoples = <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">map</span>&lt;<span class="keyword">string</span>, Person&gt; people_map = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [END messages]</span></span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>syntax: PB 版本，有 v2 和 v3 两个版本，值分别为 proto2 和 proto3;</li>
<li>package: 包名，表示命名空间，用于解决名称冲突，在 Java 中转换为 package 包名；</li>
<li>java_multiple_files：Java 申明，若为 true, 表示为每一个 message 生成独立的文件（嵌套的 message 除外）；</li>
<li>java_package：Java 申明，指定 Java 的 package 名称，它为覆盖 package 属性指定的包名；</li>
<li>java_outer_classname：Java 申明，指定输出的 Java 类名；</li>
<li>import：引入外部的 proto 文件；</li>
<li>message：定义一个消息，对应 Java 中的对象，message 可以嵌套定义；</li>
<li>enum：枚举对象，下标从 0 开始；</li>
<li>repeated：表示 0 或 n 个对象，可以定义数组对象；</li>
<li>map：map 对象；</li>
<li>optional：描述符，表示该字段为可选字段，如果没有设置的话，使用默认值，在 proto3 中已经取消 required 字段；</li>
<li>tag：如同 =1,字段在 message 中的惟一标示，在二进制编码中使用 tag 代表该字段，1~15 使用一个字节表示，处于优化的目的，常用的字段应该放在这个区域。</li>
</ol>
<p>map 对象等同于如下的定义，它实际上就是一个包含 key 和 value 对象的数组。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">message MapFieldEntry &#123;</span><br><span class="line">  key_type key = <span class="number">1</span>;</span><br><span class="line">  value_type value = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">repeated MapFieldEntry map_field = N;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-3-编译-proto-文件"><a href="#2-3-编译-proto-文件" class="headerlink" title="2.3 编译 proto 文件"></a>2.3 编译 proto 文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc -I=. --java_out=. addressbookV2.proto</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>-I：指定 proto 文件所在的源目录；</li>
<li>–java_out：指定 Java 语言编译输出的目录；</li>
</ol>
<p>生成的代码如下所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">└─org</span><br><span class="line">    └─noahsark</span><br><span class="line">        └─tutorial</span><br><span class="line">            └─protos</span><br><span class="line">                    AddressBook.java</span><br><span class="line">                    AddressBookOrBuilder.java</span><br><span class="line">                    AddressBookProtos.java</span><br><span class="line">                    Person.java</span><br><span class="line">                    PersonOrBuilder.java</span><br></pre></td></tr></table></figure></p>
<h3 id="2-4-运行代码"><a href="#2-4-运行代码" class="headerlink" title="2.4 运行代码"></a>2.4 运行代码</h3><p>将生成的的代码导入工程，引入 Protocol Buffer jar 包。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.protobuf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>protobuf-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.18.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>构造 AddressBook 对象并序列化数据</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span> [] marshal() &#123;</span><br><span class="line">    <span class="comment">// 构造 Person 对象</span></span><br><span class="line">    Person john =</span><br><span class="line">            Person.newBuilder()</span><br><span class="line">                    .setId(<span class="number">1234</span>)</span><br><span class="line">                    .setName(<span class="string">"John Doe"</span>)</span><br><span class="line">                    .setEmail(<span class="string">"jdoe@example.com"</span>)</span><br><span class="line">                    .addPhones(</span><br><span class="line">                            Person.PhoneNumber.newBuilder()</span><br><span class="line">                                    .setNumber(<span class="string">"555-4321"</span>)</span><br><span class="line">                                    .setType(Person.PhoneType.HOME))</span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造 AddressBook 对象</span></span><br><span class="line">    AddressBook addressBook = AddressBook.newBuilder()</span><br><span class="line">            .addPeoples(john)</span><br><span class="line">            .putPeopleMap(john.getName(),john).build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化 AddressBook 对象</span></span><br><span class="line">    <span class="keyword">byte</span> [] message = addressBook.toByteArray();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>反序列化 AddressBook 对象</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> AddressBook <span class="title">unmarshal</span><span class="params">(<span class="keyword">byte</span> [] message)</span> <span class="keyword">throws</span> InvalidProtocolBufferException </span>&#123;</span><br><span class="line">    AddressBook addressBook = AddressBook.parseFrom(message);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> addressBook;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>输出 AddressBook 对象</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">listAddressBook</span><span class="params">(AddressBook addressBook)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Person person: addressBook.getPeoplesList()) &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Person ID: "</span> + person.getId());</span><br><span class="line">        System.out.println(<span class="string">"  Name: "</span> + person.getName());</span><br><span class="line">        System.out.println(<span class="string">"  E-mail address: "</span> + person.getEmail());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Person.PhoneNumber phoneNumber : person.getPhonesList()) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (phoneNumber.getType()) &#123;</span><br><span class="line">                <span class="keyword">case</span> MOBILE:</span><br><span class="line">                    System.out.print(<span class="string">"  Mobile phone #: "</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> HOME:</span><br><span class="line">                    System.out.print(<span class="string">"  Home phone #: "</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> WORK:</span><br><span class="line">                    System.out.print(<span class="string">"  Work phone #: "</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(phoneNumber.getNumber());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>使用 ProtocolBuffer 序列化及反序列化数据</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InvalidProtocolBufferException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造 AddressBook 对象并序列化数据</span></span><br><span class="line">    <span class="keyword">byte</span> [] message = marshal();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化 AddressBook 对象</span></span><br><span class="line">    AddressBook addressBook = unmarshal(message);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出 AddressBook 对象</span></span><br><span class="line">    listAddressBook(addressBook);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person ID: 1234</span><br><span class="line">  Name: John Doe</span><br><span class="line">  E-mail address: jdoe@example.com</span><br><span class="line">  Home phone <span class="comment">#: 555-4321</span></span><br></pre></td></tr></table></figure></p>
<h2 id="3-运行时模式"><a href="#3-运行时模式" class="headerlink" title="3. 运行时模式"></a>3. 运行时模式</h2><p>在该种方式下，不用定义 .proto 文件，引入 protostuff 工具包，然后使用其提供的 API 便可对 Java 对象进行 ProtocolBuffer 序列化/反序列化操作。</p>
<h3 id="3-1-引入-protostuff"><a href="#3-1-引入-protostuff" class="headerlink" title="3.1 引入 protostuff"></a>3.1 引入 protostuff</h3><p>在 maven pom 文件中加入如下依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- For the core formats (protostuff, protobuf, graph) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.protostuff<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>protostuff-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- For schemas generated at runtime --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.protostuff<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>protostuff-runtime<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-2-定义-Java-Bean-对象"><a href="#3-2-定义-Java-Bean-对象" class="headerlink" title="3.2 定义 Java Bean 对象"></a>3.2 定义 Java Bean 对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="keyword">private</span> String mobile;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-定义工具类"><a href="#3-3-定义工具类" class="headerlink" title="3.3 定义工具类"></a>3.3 定义工具类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtostuffUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 避免每次序列化都重新申请 Buffer 空间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LinkedBuffer buffer = LinkedBuffer.allocate(LinkedBuffer.DEFAULT_BUFFER_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存 Schema</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Class&lt;?&gt;, Schema&lt;?&gt;&gt; schemaCache = <span class="keyword">new</span> ConcurrentHashMap&lt;Class&lt;?&gt;, Schema&lt;?&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列化方法，把指定对象序列化成字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj 序列化的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; 对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 字节数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">byte</span>[] serialize(T obj) &#123;</span><br><span class="line">        Class&lt;T&gt; clazz = (Class&lt;T&gt;) obj.getClass();</span><br><span class="line">        Schema&lt;T&gt; schema = getSchema(clazz);</span><br><span class="line">        <span class="keyword">byte</span>[] data;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            data = ProtostuffIOUtil.toByteArray(obj, schema, buffer);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反序列化方法，将字节数组反序列化成指定 Class 类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data 字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz 序列化对象的类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; 对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 反序列化后的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] data, Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        Schema&lt;T&gt; schema = getSchema(clazz);</span><br><span class="line">        T obj = schema.newMessage();</span><br><span class="line">        ProtostuffIOUtil.mergeFrom(data, obj, schema);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Schema&lt;T&gt; <span class="title">getSchema</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        Schema&lt;T&gt; schema = (Schema&lt;T&gt;) schemaCache.get(clazz);</span><br><span class="line">        <span class="keyword">if</span> (schema == <span class="keyword">null</span>) &#123;</span><br><span class="line">            schema = RuntimeSchema.getSchema(clazz);</span><br><span class="line">            <span class="keyword">if</span> (schema == <span class="keyword">null</span>) &#123;</span><br><span class="line">                schemaCache.put(clazz, schema);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> schema;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-4-测试代码"><a href="#3-4-测试代码" class="headerlink" title="3.4 测试代码"></a>3.4 测试代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造 Person 对象</span></span><br><span class="line">    Person person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Person 对象赋值</span></span><br><span class="line">    person.setId(<span class="number">1</span>);</span><br><span class="line">    person.setName(<span class="string">"john"</span>);</span><br><span class="line">    person.setMobile(<span class="string">"13845678912"</span>);</span><br><span class="line">    person.setEmail(<span class="string">"john@gmail.com"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化数据</span></span><br><span class="line">    <span class="keyword">byte</span> [] message = ProtostuffUtils.serialize(person);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化数据</span></span><br><span class="line">    Person john = ProtostuffUtils.deserialize(message, Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出 Person 对象数据</span></span><br><span class="line">    System.out.println(<span class="string">"person:\n"</span> + john);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">person:</span><br><span class="line">Person&#123;id=1, name=<span class="string">'john'</span>, email=<span class="string">'john@gmail.com'</span>, mobile=<span class="string">'13845678912'</span>&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>这两种方式不同的使用场景，如果后期不考虑代码的兼容问题，可以使用 protostuff 工具包，简单方便，如果代码迭代更新比较多，需要考虑不同版本的兼容问题，那最好定义合适的 .proto 文件来保证代码的兼容性。</p>
<p><br></p>
<p><strong>参考：</strong></p>
<hr>
<p><a href="https://developers.google.com/protocol-buffers/docs/javatutorial?hl=zh-CN" target="_blank" rel="noopener">1. Protocol Buffer Basics: Java</a></p>
<p><a href="https://github.com/protocolbuffers/protobuf/releases/tag/v3.18.1" target="_blank" rel="noopener">2. Protocol Buffers v3.18.1</a></p>
<p><a href="https://github.com/protostuff/protostuff" target="_blank" rel="noopener">3. github:protostuff</a></p>
<p><a href="https://github.com/protocolbuffers/protobuf" target="_blank" rel="noopener">4. github:protobuf</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/78781763" target="_blank" rel="noopener">5. java序列化机制之protoStuff</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/10/16/alligator-mq-rpc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2021/10/16/alligator-mq-rpc/" class="post-title-link" itemprop="http://yoursite.com/index.html">Alligator 系列：MQ RPC</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2021-10-16 10:59:56" itemprop="dateCreated datePublished" datetime="2021-10-16T10:59:56+08:00">2021-10-16</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-10-17 12:06:04" itemprop="dateModified" datetime="2021-10-17T12:06:04+08:00">2021-10-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Alligator网关/" itemprop="url" rel="index"><span itemprop="name">Alligator网关</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">1.8k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">2 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-概览"><a href="#1-概览" class="headerlink" title="1. 概览"></a>1. 概览</h2><p>在 Alligator 系统中，网关与业务系统之间是通过 MQ 进行通信。为了简化开发成本，基于 MQ, 实现了一套 RPC 调用，其封装了超时、同步调用及异步调用等功能，调用模型如下图所示：<br><img src="/images/alligator/mq-rpc-model.jpg" alt="mq-rpc-model" title="mq-rpc-model"></p>
<ul>
<li>使用两个 MQ 队列来存储信息，分别是请求及响应信息；</li>
<li>在请求端维护一个 request id,在响应信息中带上 request id,从而将请求与响应对应起来；</li>
<li>在请求端为每一个请求设置一个超时任务，避免长时间未响应结果。</li>
</ul>
<h2 id="2-数据结构"><a href="#2-数据结构" class="headerlink" title="2. 数据结构"></a>2. 数据结构</h2><p>在 MQ RPC 中，有几个关键的接口：1) MqProxy; 2) Topic; 3) Message; 4) PromisHolder; 5) ChannelHolder; 6) Consumer; 7) Producer; 除此之外，还有一个 RpcPromise, 它继承了 Netty 中的 DefaultPromise 类，实现异步转同步的功能。其类图如下所示：</p>
<p><img src="/images/alligator/mq-rpc-class.jpg" alt="mq-rpc" title="mq-rpc"></p>
<ol>
<li>MqProxy: MQ RPC 中的核心类，封装了 MQ 调用的实现，不同类型的 MQ 实现该接口即可。外部模块通过该类进行 RPC 的调用及响应结果的处理；</li>
<li>Topic：MQ 队列的抽象，在不同 MQ 中含义可能不同，在 RoketMQ, Kafka 中，该 Topic 对应的就是 MQ 中的 Topic, 而在 RabbitMQ 中，Topic 对应的则是一个队列；</li>
<li>Message：MQ 中传输的数据；</li>
<li>RpcPromise：代表了一次 RPC 调用，RPC 的结果就是通过 RpcPromise 通知给上层使用，一般是通过定义回调方法实现，另外调用超时的处理也是在 RpcPromise 中实现；</li>
<li>PromisHolder：RpcPromise 容器类，负责管理维护所有的 RpcPromise，其中包括生成 request id，删除 RpcPromise等等。PromisHolder 主要由 RPC 的调用方（客户端）维护。在 MQ 的实现中，request id 是全局惟一的，而在 TCP/Websocket 中，request id 只需要保证在一个 Connnection(一个客户端连接一个服务器称为一个 Connection) 惟一即可。说明：RPC 在 Alligator 中有两类实现，一类是基于 TCP/Websocket的，后续文章再讲述，一类是基于 MQ 的，即本文讲述的内容； </li>
<li>ChannelHolder：一次 RPC 调用在服务器端的会话（Session）信息，它维护了一次 RPC 的相关状态数据，如客户端信息，以便写入响应数据； </li>
<li>Consumer：用于订阅 MQ 中请求队列及响应队列的中的数据；</li>
<li>Producer：用于向 MQ 中发送数据；</li>
<li>MqProxyFactory：MqProxy 工厂类，用于实例化 MqProxy 类。</li>
</ol>
<h2 id="3-结论"><a href="#3-结论" class="headerlink" title="3. 结论"></a>3. 结论</h2><p>目前为止，对相关的抽象还不够完善，Message 及 Topic 只定义了空接口，后续可以提取公共的方法丰富其接口定义。</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/10/02/alligator-rocketmq-deploy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2021/10/02/alligator-rocketmq-deploy/" class="post-title-link" itemprop="http://yoursite.com/index.html">Alligator 系列：RocketMQ 基础知识及部署</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2021-10-02 11:40:18 / 修改时间：21:10:32" itemprop="dateCreated datePublished" datetime="2021-10-02T11:40:18+08:00">2021-10-02</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Alligator网关/" itemprop="url" rel="index"><span itemprop="name">Alligator网关</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">13k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">12 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><h3 id="1-1-概念模型"><a href="#1-1-概念模型" class="headerlink" title="1.1 概念模型"></a>1.1 概念模型</h3><p>RocketMQ 是阿里推出的一款消息系统，用来取代 Kafka 及 RabbitMQ. 在 Alligator 中支持使用 RocketMQ, 其概念模型如下所示：</p>
<p><img src="/images/alligator/rocketmq-conceptual-model.jpg" alt="rocketmq-conceptual-model" title="rocketmq-conceptual-model"></p>
<p>在上图中有几个关键的概念，Producer 是消息的发布者，Consumer 是消息的接收者，负责消费消息，ConsumerGroup 是同一类 Consumer 的集合，Topic 是消息的集合体，而 messageQueue 则是对 Topic 进行分区，来提高消息处理的并行度，从而提高系统的吞吐量。topic 中的 MessageQueue 由 ConsumerGroup 下的 Consumer 负责消费，根据不同的消费模式，保证消息都能被 consumer 进行消费。</p>
<h3 id="1-2-实现架构"><a href="#1-2-实现架构" class="headerlink" title="1.2 实现架构"></a>1.2 实现架构</h3><p>RocketMQ 实现架构如下图所示：<br><img src="/images/alligator/rocketmq_architecture.png" alt="rocketmq_architecture" title="rocketmq_architecture"><br>RocketMQ架构上主要分为四部分：</p>
<ul>
<li>Producer：消息发布者；</li>
<li>Consumer：消息消费者，支持 push 和 pull 两种消费方式。；</li>
<li>NameServer：注册中心，主要包括两个功能：1)Broker管理，实现 Broker 的注册及动态发现；2）路由信息管理，保存集群的整个路由信息。</li>
<li>BrokerServer：负责消息的存储、投递和查询以及服务高可用保证。</li>
</ul>
<font color="red"><strong> 说明: </strong></font><br><font color="red">NameServer 是无状态的，彼此之间互不通信，BrokerServer 要向所有的 NameServer 上报状态，而不是其中一台（NameServer 之间没有数据同步）。</font>

<p>RocketMQ 相关概念，来自官方网站：</p>
<blockquote>
<ol>
<li><strong>消息模型（Message Model）</strong><br>RocketMQ主要由 Producer、Broker、Consumer 三部分组成，其中Producer 负责生产消息，Consumer 负责消费消息，Broker 负责存储消息。Broker 在实际部署过程中对应一台服务器，每个 Broker 可以存储多个Topic的消息，每个Topic的消息也可以分片存储于不同的 Broker。Message Queue 用于存储消息的物理地址，每个Topic中的消息地址存储于多个 Message Queue 中。ConsumerGroup 由多个Consumer 实例构成。</li>
<li><strong>消息生产者（Producer）</strong><br>负责生产消息，一般由业务系统负责生产消息。一个消息生产者会把业务应用系统里产生的消息发送到broker服务器。RocketMQ提供多种发送方式，同步发送、异步发送、顺序发送、单向发送。同步和异步方式均需要Broker返回确认信息，单向发送不需要。</li>
<li><strong>消息消费者（Consumer）</strong><br>负责消费消息，一般是后台系统负责异步消费。一个消息消费者会从Broker服务器拉取消息、并将其提供给应用程序。从用户应用的角度而言提供了两种消费形式：拉取式消费、推动式消费。</li>
<li><strong>主题（Topic）</strong><br>表示一类消息的集合，每个主题包含若干条消息，每条消息只能属于一个主题，是RocketMQ进行消息订阅的基本单位。</li>
<li><strong>代理服务器（Broker Server）</strong><br>消息中转角色，负责存储消息、转发消息。代理服务器在RocketMQ系统中负责接收从生产者发送来的消息并存储、同时为消费者的拉取请求作准备。代理服务器也存储消息相关的元数据，包括消费者组、消费进度偏移和主题和队列消息等。</li>
<li><strong>名字服务（Name Server）</strong><br>名称服务充当路由消息的提供者。生产者或消费者能够通过名字服务查找各主题相应的Broker IP列表。多个Namesrv实例组成集群，但相互独立，没有信息交换。</li>
<li><strong>拉取式消费（Pull Consumer）</strong><br>Consumer消费的一种类型，应用通常主动调用Consumer的拉消息方法从Broker服务器拉消息、主动权由应用控制。一旦获取了批量消息，应用就会启动消费过程。</li>
<li><strong>推动式消费（Push Consumer）</strong><br>Consumer消费的一种类型，该模式下Broker收到数据后会主动推送给消费端，该消费模式一般实时性较高。</li>
<li><strong>生产者组（Producer Group）</strong><br>同一类Producer的集合，这类Producer发送同一类消息且发送逻辑一致。如果发送的是事务消息且原始生产者在发送之后崩溃，则Broker服务器会联系同一生产者组的其他生产者实例以提交或回溯消费。</li>
<li><strong>消费者组（Consumer Group）</strong><br>同一类Consumer的集合，这类Consumer通常消费同一类消息且消费逻辑一致。消费者组使得在消息消费方面，实现负载均衡和容错的目标变得非常容易。要注意的是，消费者组的消费者实例必须订阅完全相同的Topic。RocketMQ 支持两种消息模式：集群消费（Clustering）和广播消费（Broadcasting）。</li>
<li><strong>集群消费（Clustering）</strong><br>集群消费模式下,相同Consumer Group的每个Consumer实例平均分摊消息。</li>
<li><strong>广播消费（Broadcasting）</strong><br>广播消费模式下，相同Consumer Group的每个Consumer实例都接收全量的消息。</li>
<li><strong>普通顺序消息（Normal Ordered Message）</strong><br>普通顺序消费模式下，消费者通过同一个消息队列（ Topic 分区，称作 Message Queue） 收到的消息是有顺序的，不同消息队列收到的消息则可能是无顺序的。</li>
<li><strong>严格顺序消息（Strictly Ordered Message）</strong><br>严格顺序消息模式下，消费者收到的所有消息均是有顺序的。</li>
<li><strong>消息（Message）</strong><br>消息系统所传输信息的物理载体，生产和消费数据的最小单位，每条消息必须属于一个主题。RocketMQ中每个消息拥有唯一的Message ID，且可以携带具有业务标识的Key。系统提供了通过Message ID和Key查询消息的功能。</li>
<li><strong>标签（Tag）</strong><br>为消息设置的标志，用于同一主题下区分不同类型的消息。来自同一业务单元的消息，可以根据不同业务目的在同一主题下设置不同标签。标签能够有效地保持代码的清晰度和连贯性，并优化RocketMQ提供的查询系统。消费者可以根据Tag实现对不同子主题的不同消费逻辑，实现更好的扩展性。</li>
</ol>
</blockquote>
<h2 id="2-基础"><a href="#2-基础" class="headerlink" title="2. 基础"></a>2. 基础</h2><h3 id="2-1-消息存储"><a href="#2-1-消息存储" class="headerlink" title="2.1 消息存储"></a>2.1 消息存储</h3><p>消息存储是 RocketMQ 中最为复杂和最为重要的一部分，我们主要是从概念上对其理解，其实现不作过多分析，其存储整体结构如下所示：<br><img src="/images/alligator/rocketmq_message_storage.png" alt="rocketmq_message_storage" title="rocketmq_message_storage"></p>
<p>消息存储架构图中主要有下面三个跟消息存储相关的文件构成。</p>
<ol>
<li><p>CommitLog：存储消息及元数据信息，由 Producer 写入, 消息内容不是定长的。单个文件大小默认 1G, 文件名长度为 20 位，左边补零，剩余为起始偏移量，比如 00000000000000000000 代表了第一个文件，起始偏移量为 0，文件大小为 1G=1073741824；当第一个文件写满了，第二个文件为 00000000001073741824 ，起始偏移量为 1073741824 ，以此类推。消息主要是顺序写入日志文件，当文件满了，写入下一个文件；</p>
</li>
<li><p>ConsumeQueue：消息消费队列，等同于概念模型中的 MessageQueue，Consumer 根据 ConsumeQueue 来查找待消费的消息。其中，ConsumeQueue（逻辑消费队列）作为消费消息的索引，保存了指定 Topic 下的队列消息在 CommitLog 中的起始物理偏移量 offset，消息大小 size 和消息Tag 的 HashCode 值。consumequeue 文件可以看成是基于 topic 的 commitlog 索引文件，故 consumequeue 文件夹的组织方式如下：topic/queue/file 三层组织结构，具体存储路径为：$HOME/store/consumequeue/{topic}/{queueId}/{fileName}。同样 consumequeue 文件采取定长设计，每一个条目共 20 个字节，分别为 8 字节的 commitlog 物理偏移量、4 字节的消息长度、8 字节 tag hashcode，单个文件由 30W 个条目组成，可以像数组一样随机访问每一个条目，每个 ConsumeQueue 文件大小约 5.72M；</p>
</li>
<li><p>IndexFile：IndexFile（索引文件）提供了一种可以通过 key 或时间区间来查询消息的方法。Index 文件的存储位置是：$HOME \store\index${fileName}，文件名 fileName 是以创建时的时间戳命名的，固定的单个IndexFile 文件大小约为 400M，一个 IndexFile 可以保存 2000W 个索引，IndexFile 的底层存储设计为在文件系统中实现 HashMap 结构，故 RocketMQ 的索引文件其底层实现为 hash 索引。</p>
</li>
</ol>
<p>从 RocketMQ 的消息存储整体架构图中可以看出，RocketMQ 采用的是混合型的存储结构，即为 Broker 单个实例下所有的队列共用一个日志数据文件（即为CommitLog）来存储。多个Topic的消息实体内容都存储于一个CommitLog中，Producer 发送消息到 Broker 端，然后 Broker 端使用同步或者异步的方式对消息刷盘持久化，保存至 CommitLog 中。只要消息被刷盘持久化至磁盘文件 CommitLog 中，那 么Producer 发送的消息就不会丢失。</p>
<h3 id="2-2-消息过滤"><a href="#2-2-消息过滤" class="headerlink" title="2.2 消息过滤"></a>2.2 消息过滤</h3><p>消息过滤是订阅/消费消息的时候处理的，Consumer 先从 ConsumeQueue 中拿到消息的索引，再去 CommitLog 中取到数据，过滤的操作就是根据索引来进行的，我们先看下 ConsumeQueue 中消息索引的格式：</p>
<p><img src="/images/alligator/rocketmq_message_index.png" alt="rocketmq_message_index" title="rocketmq_message_index"></p>
<p>可以看到其中有 8 个字节存储的 Message Tag 的哈希值，基于 Tag 的消息过滤正是基于这个字段值的。RocketMQ 支持两种过滤方式，1）Tag 过滤，Consumer 在订阅消息时除了指定 Topic 还可以指定 Tag，如果一个消息有多个 Tage ，可以用||分隔。从 ConsumeQueue 读取到记录后，会根据 tag hash 值去做过滤，由于使用 hashcode 进行判断，只能进行整体过滤，无法精确对 tag 原始字符串进行过滤，所以 Cousumer 接收到消息之后，还需要对消息的原始 tag 字符串进行比对，如果不同，则丢弃该消息，不进行消息消费。2） SQL92 过滤，使用 SQL 表达式进行过滤。</p>
<h3 id="2-3-消息负载均衡"><a href="#2-3-消息负载均衡" class="headerlink" title="2.3 消息负载均衡"></a>2.3 消息负载均衡</h3><p>RocketMQ 中的负载均衡都在 Client 端完成，具体来说的话，主要可以分为 Producer 端发送消息时候的负载均衡和 Consumer 端订阅消息的负载均衡。</p>
<p><strong>Producer 端负载均衡</strong><br>Producer 端在发送消息的时候，会找到 Topic 相关的所有 MessageQueue 信息，根据一定的负载策略选择一个 MessageQueue 进行发送。</p>
<p><strong>Consumer 端负载均衡</strong><br>Consumer 端负载均衡的主要目的是将 Topic 下的 MessageQueue 分配给 CousumerGroup 中的 Consumer，并保证一个 MessageQueue 只能被一个 Consumer 消费（集群模式下）。</p>
<p><img src="/images/alligator/rocketmq_message_allocate.png" alt="rocketmq_message_allocate" title="rocketmq_message_allocate"></p>
<h2 id="3-部署"><a href="#3-部署" class="headerlink" title="3. 部署"></a>3. 部署</h2><h3 id="3-1-单机部署"><a href="#3-1-单机部署" class="headerlink" title="3.1 单机部署"></a>3.1 单机部署</h3><p>由于只是用于实验目的，只需要部署单 Master 模式。</p>
<p><strong>官方推荐配置</strong></p>
<ol>
<li>64bit OS, Linux/Unix/Mac is recommended;(Windows user see guide below)</li>
<li>64bit JDK 1.8+;</li>
<li>Maven 3.2.x;</li>
<li>Git;</li>
<li>4g+ free disk for Broker server</li>
</ol>
<p>下载 RocketMQ V4.8.0，并解压到安装目录<br><a href="https://www.apache.org/dyn/closer.cgi?path=rocketmq/4.8.0/rocketmq-all-4.8.0-source-release.zip" target="_blank" rel="noopener">https://www.apache.org/dyn/closer.cgi?path=rocketmq/4.8.0/rocketmq-all-4.8.0-source-release.zip</a></p>
<p><strong>修改配置</strong><br><strong>1. 修改 rocketmq-4.8.0/conf/broker.conf</strong><br>如果部署在公有云上，需要将 brokerIP 和 namesrvAddr 设置为公网 ip 地址和端口<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">brokerClusterName = DefaultCluster</span><br><span class="line">brokerName = broker<span class="_">-a</span></span><br><span class="line">brokerId = 0</span><br><span class="line">deleteWhen = 04</span><br><span class="line">fileReservedTime = 48</span><br><span class="line">brokerRole = ASYNC_MASTER</span><br><span class="line">flushDiskType = ASYNC_FLUSH</span><br><span class="line"><span class="comment">## broker ip</span></span><br><span class="line">brokerIP1=公网ip </span><br><span class="line"></span><br><span class="line"><span class="comment">## na</span></span><br><span class="line">namesrvAddr=公网ip:9876</span><br></pre></td></tr></table></figure></p>
<p><strong>2. 修改内存大小</strong><br>RocketMQ 默认内存配置是 4G, 单机版本配置启动 1台 nameServer 及 1台 broker, 如果配置不够的话，需要修改 runbroker.sh 和 runserver.sh 脚本。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVA_OPT=<span class="string">"<span class="variable">$&#123;JAVA_OPT&#125;</span> -server -Xms2g -Xmx2g -Xmn1g"</span></span><br></pre></td></tr></table></figure></p>
<p>根据情况修改，这里修改为 2G.</p>
<h3 id="3-2-命令"><a href="#3-2-命令" class="headerlink" title="3.2 命令"></a>3.2 命令</h3><p><strong>1. 启动 nameServer</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> rocketmq-4.8.0/bin</span><br><span class="line"></span><br><span class="line">nohup sh mqnamesrv -n 外网ip:9876 &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment"># -n: 指定nameserv ip 地址</span></span><br></pre></td></tr></table></figure></p>
<p><strong>2. 启动 broker</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> rocketmq-4.8.0</span><br><span class="line"></span><br><span class="line">nohup sh bin/mqbroker -n 外网ip:9876 -c conf/broker.conf &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment"># -n: 指定nameserv ip 地址</span></span><br><span class="line"><span class="comment"># -c: 指定配置文件</span></span><br></pre></td></tr></table></figure></p>
<p><strong>3. 关闭服务器</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭 broker</span></span><br><span class="line">./mqshutdown broker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭 namesrv</span></span><br><span class="line">./mqshutdown namesrv</span><br></pre></td></tr></table></figure></p>
<p><strong>4. Topic 命令</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 topic</span></span><br><span class="line">sh mqadmin updateTopic -n 外网ip:9876 -c DefaultCluster -t &lt;topic name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询 topic</span></span><br><span class="line">sh mqadmin topicList –n 外网ip:9876</span><br></pre></td></tr></table></figure></p>
<font color="red"><strong> 说明: </strong></font><br><font color="red">在 RocketMQ 中，Topic 须提前创建。</font>

<p><br></p>
<p><strong>参考：</strong></p>
<hr>
<p><a href="https://github.com/apache/rocketmq/blob/master/docs/cn/concept.md" target="_blank" rel="noopener">1. RocketMQ 基本概念</a></p>
<p><a href="https://github.com/apache/rocketmq/blob/master/docs/cn/architecture.md" target="_blank" rel="noopener">2. RocketMQ 架构设计</a></p>
<p><a href="https://github.com/apache/rocketmq/blob/master/docs/cn/design.md" target="_blank" rel="noopener">3. RocketMQ 设计(design)</a></p>
<p><a href="https://mp.weixin.qq.com/s/Efw5pXrptWPfCDQI8rc_xg" target="_blank" rel="noopener">4. 一文讲透Apache RocketMQ技术精华</a></p>
<p><a href="http://rocketmq.apache.org/docs/quick-start/" target="_blank" rel="noopener">5. RocketMQ Quick Start</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/09/30/alligator-rabbitmq-deploy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2021/09/30/alligator-rabbitmq-deploy/" class="post-title-link" itemprop="http://yoursite.com/index.html">Alligator 系列：RabbitMQ 基础知识及部署</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2021-09-30 09:12:20" itemprop="dateCreated datePublished" datetime="2021-09-30T09:12:20+08:00">2021-09-30</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-10-16 10:49:31" itemprop="dateModified" datetime="2021-10-16T10:49:31+08:00">2021-10-16</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Alligator网关/" itemprop="url" rel="index"><span itemprop="name">Alligator网关</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">25k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">22 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-概览"><a href="#1-概览" class="headerlink" title="1. 概览"></a>1. 概览</h2><p>RabbitMQ 是一种消息系统，相比较其它消息系统，除了 queue，它多了一个 exchange 交换器的概念，在 Alligator 中支持使用 RabbitMQ, 其整体结构如下图所示：<br><img src="/images/alligator/rabbitmq-overview.png" alt="rabbitmq-overview" title="rabbitmq-overview"></p>
<p>现在假设有这样一个业务场景，一个 web app 具备生成 PDF 文档的能力，而生成 PDF 文档是一个耗时的操作，需要交给后台的 PDF 任务去执行。为了提高系统的吞吐量，引入 RabbitMQ 缓存请求，其流程为：</p>
<ol>
<li>用户发送一个生成 PDF 的请求给 web app;</li>
<li>Web app (Producer) 发送一个消息给 RabbitMQ;</li>
<li>Exchange 收到消息并路由消息到合适的 Queue; </li>
<li>PDF 任务(Consumer) 接收来自 Queue 的消息，生成 PDF.</li>
</ol>
<p>消息不是直接发送到 Queue 中，而是发送到 Exchange 中，最后通过 routing Key 在 Exchange 和 Queue 中建立一个 binding 关系，从而将消息路由到不同的 Queue 中。</p>
<p><img src="/images/alligator/exchanges-bidings-routing-keys.png" alt="exchanges-bidings-routing-keys" title="exchanges-bidings-routing-keys"></p>
<p>RabbitMQ 中消息处理流程：</p>
<ol>
<li>Producer 发布一个消息到 Exchange 中，在创建 Exchange 时必须指定其类型；</li>
<li>Exchange 收到消息并负责消息的路由，Exchange 会根据消息的属性进行路由，其中，routing key 是一个关键的属性，根据 Exchange 类型，可以有不同的路由策略；</li>
<li>Bindings(绑定关系) 必须创建，它决定了消息从 Exchange 路由到哪个 Queue，在这个 case 中，有两个绑定关系，路由到那个 Queue，取决于消息的属性；</li>
<li>消息路由到 Queue 中，并等待 Consumer 处理；</li>
<li>Consumer 接收消息并处理。</li>
</ol>
<p>Exchange 有四种类型：direct, topic, headers 和 fanout.<br><img src="/images/alligator/exchanges-topic-fanout-direct.png" alt="exchanges-topic-fanout-direct" title="exchanges-topic-fanout-direct"></p>
<ol>
<li>Direct: Binding Key 与 Routing Key 精确匹配。binding key 是 exchange 与 queue 建立绑定关系指定的属性，而 routing key 则是由 Producer 发送消息是指定的属性，如果两个 key 相同，消息则路由到与 binding key 相关联的 queue 中；</li>
<li>Fanout: 广播所有的消息；</li>
<li>Topic: 是比较灵活的类型，可以在 binding key 中指定通配符(*,#)，如 eu.fe.*, us.#, 其中，* 表示匹配一个单词，# 表示匹配多个单词。通过通配符，可以实现层次结构的匹配；</li>
<li>Headers: Headers exchanges 使用消息的属性进行路由。</li>
</ol>
<p><strong>Binding Key 与 Routing Key：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// exchange 申明, 可以指定 type</span></span><br><span class="line">AMQP.Exchange.DeclareOk exchangeDeclare​(String exchange, String type, <span class="keyword">boolean</span> durable) <span class="keyword">throws</span> IOException</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立绑定关系，指定 bindingKey</span></span><br><span class="line">AMQP.Queue.BindOk queueBind​(String queue, String exchange, String bindingKey, Map&lt;String,​Object&gt; arguments) <span class="keyword">throws</span> IOException</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布消息，指定 routingKey</span></span><br><span class="line"><span class="keyword">void</span> basicPublish​(String exchange, String routingKey, <span class="keyword">boolean</span> mandatory, AMQP.BasicProperties props, <span class="keyword">byte</span>[] body) <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure></p>
<p>通过 routingKey 与 bindingKey 进行匹配，从而实现消息的路由。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@my-rabbit:/<span class="comment"># rabbitmqctl list_exchanges</span></span><br><span class="line">Listing exchanges <span class="keyword">for</span> vhost / ...</span><br><span class="line">name    <span class="built_in">type</span></span><br><span class="line">amq.topic       topic</span><br><span class="line">amq.fanout      fanout</span><br><span class="line">amq.direct      direct</span><br><span class="line">amq.headers     headers</span><br><span class="line">amq.match       headers</span><br><span class="line">                direct(default)</span><br><span class="line">amq.rabbitmq.trace      topic</span><br></pre></td></tr></table></figure>
<p>通过 rabbitmqctl 命令可以查看 exchange 信息，在这个列表中，一些是 amq.* 打头的 exchange, 还一个没有命名，空名字的 exchange, 这个空的 exchange 是默认的 exchange. 它们都是默认创建好的。</p>
<p>在发布消息的时候，可以不指定 exchange 的名称, 如下代码所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">channel.basic_publish(exchange=<span class="string">''</span>,</span><br><span class="line">                      routing_key=<span class="string">'task_queue'</span>,</span><br><span class="line">                      body=message)</span><br></pre></td></tr></table></figure></p>
<p>空的 exchange 代表了默认或无名的 exchange: 消息会路由到与 routing_key 同名的 queue 中，在这个 case 中，消息最终路由到 task_queue queue 中。</p>
<h2 id="2-基础知识"><a href="#2-基础知识" class="headerlink" title="2. 基础知识"></a>2. 基础知识</h2><h3 id="2-1-Consumer-ACK-机制"><a href="#2-1-Consumer-ACK-机制" class="headerlink" title="2.1 Consumer ACK 机制"></a>2.1 Consumer ACK 机制</h3><p>Consumer ACK 有两种模式：1）自动；2）手动。在自动模式下，Broker 分发消息之后即认为分发成功，便可删除消息，该模式被认为是不安全的。而自动模式需要程序手动发送 Ack 确认信息，这样可以保证消息被处理。</p>
<p>官方文档对自动模式描述如下：</p>
<blockquote>
<p>In automatic acknowledgement mode, a message is considered to be successfully delivered immediately after it is sent. This mode trades off higher throughput (as long as the consumers can keep up) for reduced safety of delivery and consumer processing. This mode is often referred to as “fire-and-forget”. Unlike with manual acknowledgement model, if consumers’s TCP connection or channel is closed before successful delivery, the message sent by the server will be lost. Therefore, automatic message acknowledgement should be considered unsafe and not suitable for all workloads.</p>
</blockquote>
<p>通过下面方法来设置自动或手动：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> autoAck = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">channel.basicConsume(queueName, autoAck, <span class="string">"a-consumer-tag"</span>,</span><br><span class="line">     <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Envelope envelope,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    AMQP.BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">byte</span>[] body)</span></span></span><br><span class="line"><span class="function">             <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">         </span>&#123;</span><br><span class="line">             <span class="keyword">long</span> deliveryTag = envelope.getDeliveryTag();</span><br><span class="line">             <span class="comment">// negatively acknowledge, the message will</span></span><br><span class="line">             <span class="comment">// be discarded</span></span><br><span class="line">             channel.basicReject(deliveryTag, <span class="keyword">false</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br></pre></td></tr></table></figure></p>
<p>默认是自动模式，可以在 channel.basicConsume 方法中设置为 false。</p>
<p><strong>手动 Ack 有三个方法：</strong></p>
<ul>
<li>basic.ack : 用于肯定应答；</li>
<li>basic.nack ：用于否定应答，可以重新 requeue 排队发送；</li>
<li>basic.reject ：用于否定应答，与 nack 的区别在于是否支持批量确认。</li>
</ul>
<p><strong>basic.ack 方法定义：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> deliveryTag = envelope.getDeliveryTag();</span><br><span class="line"></span><br><span class="line">channel.basicAck(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> multiple);</span><br></pre></td></tr></table></figure></p>
<p>其中，</p>
<ul>
<li>deliveryTag : 消息的唯一标示，在一个channel 中一个消息具有唯一的 deliveryTag；</li>
<li>multiple ：是否批量确认，true 表示 deliveryTag 之前的消息都被确认，false 只确认当前消息。</li>
</ul>
<p><strong>basic.nack 方法定义：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> deliveryTag = envelope.getDeliveryTag();</span><br><span class="line"></span><br><span class="line">channel.basicNack(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> requeue, <span class="keyword">boolean</span> multiple);</span><br></pre></td></tr></table></figure></p>
<p>其中，</p>
<ul>
<li>deliveryTag : 消息的唯一标示，在一个channel 中一个消息具有唯一的 deliveryTag；</li>
<li>requeue : 是否重新排队发送，true 表示重新排队，false 表示删除该消息；</li>
<li>multiple ：是否批量确认，true 表示 deliveryTag 之前的消息都被确认，false 只确认当前消息。</li>
</ul>
<p><strong>basic.reject方法定义：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> deliveryTag = envelope.getDeliveryTag();</span><br><span class="line"></span><br><span class="line">basic.reject(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> requeue);</span><br></pre></td></tr></table></figure></p>
<p>其中，</p>
<ul>
<li>deliveryTag : 消息的唯一标示，在一个channel 中一个消息具有唯一的 deliveryTag；</li>
<li>requeue : 是否重新排队发送，true 表示重新排队，false 表示删除该消息；</li>
</ul>
<h3 id="2-2-QoS"><a href="#2-2-QoS" class="headerlink" title="2.2 QoS"></a>2.2 QoS</h3><p>QoS 主要是为了控制向 Consumer 发送消息的频率，通过配置当前未确认的消息数量来控制是否发送，如 Qos = 5，则表示如果有 5 条消息未被确认，则不向 Consumer 发送消息。通过配置 QoS，可以避免消息在 Consumer 中堆积。正常情况下，QoS 是配合手动 Ack 一起使用的。<br>在生产环境中，需要根据压测结果选择合适的值进行配置，QoS = 0 表示不限制，QoS = 1 是保守的配置，为了提高系统的吞吐量，一般可以设置较大的值。QoS 可以配置在 Channel 或 Consumer 上，Channel 的配置如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicQos(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="2-3-Producer-Comfirm"><a href="#2-3-Producer-Comfirm" class="headerlink" title="2.3 Producer Comfirm"></a>2.3 Producer Comfirm</h3><p>Consumer 通过 Ack 机制保证消息被消费，同样，Producer 通过 Confirm 机制保证投递到 broker 中，可以通过下面的代码开启 Comfirm。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启 confirm</span></span><br><span class="line">ch.confirmSelect();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步等待</span></span><br><span class="line">ch.waitForConfirmsOrDie(<span class="number">5_000</span>);</span><br></pre></td></tr></table></figure></p>
<p>可以结合业务，实现单个消息、批量消息的确认及消息的异步确认。</p>
<h3 id="2-4-持久化"><a href="#2-4-持久化" class="headerlink" title="2.4 持久化"></a>2.4 持久化</h3><p>消息的持久化，包括 exchange 及 queue 的持久化，其参数配置如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// exchange 申明</span></span><br><span class="line">channel.exchangeDeclare​(String exchange, String type, <span class="keyword">boolean</span> durable);</span><br><span class="line"></span><br><span class="line"><span class="comment">// queue 申明</span></span><br><span class="line">channel.queueDeclare​(String queue, <span class="keyword">boolean</span> durable, <span class="keyword">boolean</span> exclusive, <span class="keyword">boolean</span> autoDelete, Map&lt;String,​Object&gt; arguments);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 queue 绑定到 exchange 上</span></span><br><span class="line">channel.queueBind​(String queue, String exchange, String routingKey);</span><br></pre></td></tr></table></figure></p>
<p><strong>Exchange 申明：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AMQP.Exchange.DeclareOk exchangeDeclare​(String exchange, String type, <span class="keyword">boolean</span> durable) <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure></p>
<p>参数说明：</p>
<ul>
<li>exchange: exchange 名称</li>
<li>type: exchange type</li>
<li>durable: 是否持久化，若为 true，服务器重启之后，exchange 还会存在。</li>
</ul>
<p><strong>Queue​ 申明：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AMQP.Queue.DeclareOk queueDeclare​(String queue, <span class="keyword">boolean</span> durable, <span class="keyword">boolean</span> exclusive, <span class="keyword">boolean</span> autoDelete, Map&lt;String,​Object&gt; arguments) <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure></p>
<p>参数说明：</p>
<ul>
<li>queue: queue 名称</li>
<li>durable: 是否持久化，若为 true，服务器重启后，queue 仍然存在</li>
<li>exclusive: 是否具有排他性，若为 true, 不允许其它客户端连接</li>
<li>autoDelete: 是否自动删除，若为 true, 队列没有使用时，则为自动删除</li>
<li>arguments: 其它参数</li>
</ul>
<p><strong>QueueBind​ 申明：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AMQP.Queue.BindOk queueBind​(String queue, String exchange, String routingKey, Map&lt;String,​Object&gt; arguments) <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure></p>
<p>参数说明：</p>
<ul>
<li>queue: queue 名称</li>
<li>exchange: exchange 名称</li>
<li>routingKey: 路由 key</li>
<li>arguments: 其它参数</li>
</ul>
<p><strong>basicPublish 申明：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> basicPublish​(String exchange, String routingKey, <span class="keyword">boolean</span> mandatory, AMQP.BasicProperties props, <span class="keyword">byte</span>[] body) <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure></p>
<p>参数说明：</p>
<ul>
<li>exchange: exchange 名称</li>
<li>routingKey: 路由 key</li>
<li>mandatory: 若为 tue,表示消息若不能路由，则将消息 return 给发送者，发送者可以定义重发逻辑，若为 false, 则将消息丢弃或发送给另外的 exchange</li>
<li>props: 参数，可以指定消息的类型或是否持久化</li>
<li>body: 消息内容</li>
</ul>
<p>示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.basicPublish(exchangeName, routingKey, <span class="keyword">true</span>, MessageProperties.PERSISTENT_TEXT_PLAIN,</span><br><span class="line">                        body.getBytes(<span class="string">"UTF-8"</span>));</span><br></pre></td></tr></table></figure></p>
<font color="red"><strong> 说明: </strong></font><br><font color="red">在 RabbitMQ 中，exchange 及 queue 不用提前创建，调用上面的申明方法时，如果没有不存在，则会自动创建。</font>

<h3 id="2-5-Virtual-Hosts"><a href="#2-5-Virtual-Hosts" class="headerlink" title="2.5 Virtual Hosts"></a>2.5 Virtual Hosts</h3><blockquote>
<p>RabbitMQ is multi-tenant system: connections, exchanges, queues, bindings, user permissions, policies and some other things belong to virtual hosts, logical groups of entities</p>
</blockquote>
<p>RabbitMQ 是一个多租户系统，connections, exchanges, queues, bindings, user 权限, 策略及其它东西都属于一个 virtual host。使用 virtual host，需要用户提前创建，系统默认的 vhost 是 ‘/‘。</p>
<h2 id="3-部署"><a href="#3-部署" class="headerlink" title="3. 部署"></a>3. 部署</h2><font color="red"><strong> 说明: </strong></font><br><font color="red">只是用于实验目的，安装单机版本。</font>

<h3 id="3-1-安装-Rabbitmq"><a href="#3-1-安装-Rabbitmq" class="headerlink" title="3.1 安装 Rabbitmq"></a>3.1 安装 Rabbitmq</h3><p>使用 docker 部署单机版本，版本使用的是 3.9。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 安装 rabbitmq</span><br><span class="line">docker run -d --hostname my-rabbit --name rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:3.9-management</span><br><span class="line"></span><br><span class="line">// 进入容器</span><br><span class="line">docker <span class="built_in">exec</span> -it 容器id bash</span><br></pre></td></tr></table></figure></p>
<h3 id="3-2-创建-virtual-host"><a href="#3-2-创建-virtual-host" class="headerlink" title="3.2 创建 virtual host"></a>3.2 创建 virtual host</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 创建 alligator vhost</span><br><span class="line">rabbitmqctl add_vhost &lt;vhost_name&gt;</span><br><span class="line"></span><br><span class="line">rabbitmqctl add_vhost alligator</span><br><span class="line"></span><br><span class="line">// 查看 vhost</span><br><span class="line">rabbitmqctl list_vhosts</span><br></pre></td></tr></table></figure>
<h3 id="3-3-创建用户"><a href="#3-3-创建用户" class="headerlink" title="3.3 创建用户"></a>3.3 创建用户</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 创建 user</span><br><span class="line">rabbitmqctl add_user test_user 123456</span><br><span class="line"></span><br><span class="line">// 查看 user</span><br><span class="line">rabbitmqctl list_users</span><br><span class="line"></span><br><span class="line">// rabbitmqctl 用户相关的命令</span><br><span class="line">add_user &lt;username&gt; &lt;password&gt;</span><br><span class="line">delete_user &lt;username&gt;</span><br><span class="line">change_password &lt;username&gt; &lt;newpassword&gt;</span><br><span class="line">clear_password &lt;username&gt;</span><br><span class="line">authenticate_user &lt;username&gt; &lt;password&gt;</span><br><span class="line">set_user_tags &lt;username&gt; &lt;tag&gt; ...</span><br><span class="line">list_users</span><br></pre></td></tr></table></figure>
<p>rabbitmq 角色有：none,management,policymaker,monitoring 及 administrator，可以通过下面的命令设置角色。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 设置角色</span><br><span class="line">rabbitmqctl set_user_tags &lt;user&gt; &lt;role&gt;</span><br><span class="line"></span><br><span class="line">// 设置为超级管理员</span><br><span class="line">rabbitmqctl set_user_tags test_user administrator</span><br></pre></td></tr></table></figure>
<h3 id="3-4-授权用户"><a href="#3-4-授权用户" class="headerlink" title="3.4 授权用户"></a>3.4 授权用户</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 授权用户</span><br><span class="line">rabbitmqctl set_permissions [-p &lt;vhost&gt;] &lt;user&gt; &lt;conf&gt; &lt;write&gt; &lt;<span class="built_in">read</span>&gt;</span><br><span class="line"></span><br><span class="line">// 授权 test_user 具备 alligator vhost 下所有资源的读写权限</span><br><span class="line">rabbitmqctl set_permissions -p alligator  allen <span class="string">'.*'</span> <span class="string">'.*'</span> <span class="string">'.*'</span></span><br></pre></td></tr></table></figure>
<h3 id="3-5-管理后台"><a href="#3-5-管理后台" class="headerlink" title="3.5 管理后台"></a>3.5 管理后台</h3><p>RabbitMQ 默认创建了 guest(密码为 guest)，处于安全考虑，建议删除该用户，新建一个自定义用户，用于后台的管理。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 删除 guest 用户</span><br><span class="line">rabbitmqctl delete_user guest</span><br><span class="line"></span><br><span class="line">// 新建 admin 用户</span><br><span class="line">rabbitmqctl add_user admin ********</span><br><span class="line"></span><br><span class="line">// 设置 admin 为 administrator 角色</span><br><span class="line">rabbitmqctl set_user_tags admin administrator</span><br><span class="line"></span><br><span class="line">// 将 / (vhost) 所有权限授权给 admin</span><br><span class="line">rabbitmqctl set_permissions -p / admin <span class="string">'.*'</span> <span class="string">'.*'</span> <span class="string">'.*'</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p><strong>参考：</strong></p>
<hr>
<p><a href="https://www.cloudamqp.com/blog/part1-rabbitmq-for-beginners-what-is-rabbitmq.html" target="_blank" rel="noopener">1. part 1: RabbitMQ for beginners - What is RabbitMQ?</a></p>
<p><a href="https://rabbitmq.github.io/rabbitmq-java-client/api/4.x.x/com/rabbitmq/client/Channel.html" target="_blank" rel="noopener">2. rabbitmq api doc</a></p>
<p><a href="https://www.rabbitmq.com/confirms.html" target="_blank" rel="noopener">3. Consumer Acknowledgements and Publisher Confirms</a></p>
<p><a href="https://www.rabbitmq.com/vhosts.html" target="_blank" rel="noopener">4. Virtual Hosts</a></p>
<p><a href="https://www.rabbitmq.com/queues.html" target="_blank" rel="noopener">5. queues</a></p>
<p><a href="https://www.rabbitmq.com/getstarted.html" target="_blank" rel="noopener">6. RabbitMQ Tutorials</a></p>
<p><a href="https://www.rabbitmq.com/access-control.html" target="_blank" rel="noopener">7. Authentication, Authorisation, Access Control</a></p>
<p><a href="https://www.rabbitmq.com/rabbitmqctl.8.html" target="_blank" rel="noopener">8. rabbitmqctl(8)</a></p>
<p><a href="https://www.rabbitmq.com/production-checklist.html" target="_blank" rel="noopener">9. Production Checklist</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/09/19/netty-memory-management/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2021/09/19/netty-memory-management/" class="post-title-link" itemprop="http://yoursite.com/index.html">Netty 系列：内存管理（摘录）</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2021-09-19 11:26:47" itemprop="dateCreated datePublished" datetime="2021-09-19T11:26:47+08:00">2021-09-19</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-09-25 16:33:46" itemprop="dateModified" datetime="2021-09-25T16:33:46+08:00">2021-09-25</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Netty/" itemprop="url" rel="index"><span itemprop="name">Netty</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">17k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">16 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>在操作系统中内存管理的基本单位是 page, page 大小一般是 4k。为了满足不同场景，分配不同大小的内存，操作系统提供了丰富的内存管理方法。从分层的角度来说，可以用下面的层次图来表示。</p>
<p><img src="/images/netty/netty-memory-management-level.jpg" alt="netty-memory-management-level" title="renetty-memory-management-levelactor"></p>
<ol>
<li>在内核空间，Buddy 系统提供了 page 级的内存分配，可以实现较大连续内存的分配，最小的分配单位是 page；</li>
<li>在内核空间，Buddy 最小分配单位是 4k ,即一个 page。为了避免内存空间的浪费（小于 4K 的空间也会分配一个 page），slab 提供了小内存空间的分配机制；</li>
<li>在用户空间，一般是通过 Buddy 分配一个大内存，在这个大内存里面，使用特定的数据来管理内存的分配，满足不同场景下内存的使用，典型的分配算法有：ptmalloc,tcmalloc 及 jemalloc。</li>
</ol>
<blockquote>
<p>ptmalloc 是基于 glibc 实现的内存分配器，它是一个标准实现，所以兼容性较好。pt 表示 per thread 的意思。 ptmalloc 在多线程的性能优化上下了很多功夫。不过由于过于考虑性能问题，多线程之间内存无法实现共享，每个线程都独立使用各自的内存，所以在内存开销上是有很大浪费的。</p>
</blockquote>
<blockquote>
<p>tcmalloc 出身于 Google，全称是 thread-caching malloc，所以 tcmalloc 最大的特点是带有线程缓存，tcmalloc 非常出名，目前在 Chrome、Safari 等知名产品中都有所应有。tcmalloc 为每个线程分配了一个局部缓存，对于小对象的分配，可以直接由线程局部缓存来完成，对于大对象的分配场景，tcmalloc 尝试采用自旋锁来减少多线程的锁竞争问题。</p>
</blockquote>
<blockquote>
<p>jemalloc 是由 Jason Evans 在 FreeBSD 项目中引入的新一代内存分配器。它是一个通用的 malloc 实现，侧重于减少内存碎片和提升高并发场景下内存的分配效率，其目标是能够替代 malloc。jemalloc 应用十分广泛，在 Firefox、Redis、Rust、Netty 等出名的产品或者编程语言中都有大量使用。<br>jemalloc 借鉴了 tcmalloc 优秀的设计思路，所以在架构设计方面两者有很多相似之处，同样都包含 thread cache 的特性。但是 jemalloc 在设计上比 ptmalloc 和 tcmalloc 都要复杂，jemalloc 将内存分配粒度划分为 Small、Large、Huge 三个分类，并记录了很多 meta 数据，所以在空间占用上要略多于 tcmalloc，不过在大内存分配的场景，jemalloc 的内存碎片要少于 tcmalloc。</p>
</blockquote>
<p>在 Netty 中使用 jemalloc 分配器来实现对内存的管理，借助学习 Netty 的机会，顺便学习下内存管理的基本知识。这篇文章主要是对关键的分配算法做一个概述，希望能够说清楚该分配算法的整体结构，并不会对实现细节进行分析，这也超出了我的能力范围。</p>
<h2 id="2-Buddy-系统"><a href="#2-Buddy-系统" class="headerlink" title="2. Buddy 系统"></a>2. Buddy 系统</h2><blockquote>
<p>page：虚拟地址空间按照固定大小划分成被称为页（page）的若干单元，物理内存中对应的则是页框（page frame）。这两者一般来说是一样的大小，如 4KB，在本文中，我们统一用 page 表示分页。</p>
</blockquote>
<p>在内存管理中，存在两种碎片，一种是内部碎片，另外一种是外部碎片。page 是操作系统中内存分配的基本单元，如果分配的对象小于 page 的大小，就会造成 page 尾部空间的浪费，形成内部碎片。而外部碎片主要是指空闲的 page 不连续，造成可用的空间不能满足大内存的分配，形成外部碎片。</p>
<p>Buddy 系统主要解决了外部碎片的问题，它把所有的空闲 page 分组为 11 个块链表，每个块链表由不同大小的内存块组成，大小分别为1，2，4，8，16，32，64，128，256，512 和 1024个 连续 page 的 page 块。最大可以申请 1024 个连续 page，对应 4MB 大小的连续内存。如下图所示：</p>
<p><img src="/images/netty/buddy-system.jpg" alt="buddy-system" title="buddy-system"></p>
<p>假设要申请一个256个 page 的块，先从 256 个 page 的链表中查找空闲块，如果没有，就去 512 个 page 的链表中找，找到了则将页框块分为 2 个 256 个 page 的块，一个分配给应用，另外一个移到 256个 page 的链表中。如果 512 个 page 的链表中仍没有空闲块，继续向 1024 个 page 的链表查找，如果仍然没有，则返回错误。page 块在释放时，会主动将两个连续的 page 块合并为一个较大的 page 块。</p>
<p>buddy（伙伴）系统的含义就是不断合并相邻的 page，通过这种办法来减少外部碎片的存在，这也是 Buddy 系统的本质所在。</p>
<h2 id="3-slab"><a href="#3-slab" class="headerlink" title="3. slab"></a>3. slab</h2><p>在Linux中，buddy system（伙伴系统）是以 page 为单位管理和分配内存。page 默认大小为 4K，如果要分配 20 Bytes 大小的内存，就会造成很大的浪费，怎么解决这个问题呢？ slab 分配器就应运而生了，专为小内存分配而生。slab分配器分配内存以 Byte 为单位。但是 slab 分配器并没有脱离伙伴系统，而是基于伙伴系统分配的大内存进一步细分成小内存分配。先看下图：</p>
<p><img src="/images/netty/slab.jpg" alt="slab" title="slab"></p>
<p>kmem_cache 是一个 cache_chain 的链表，描述了一个高速缓存，每个高速缓存包含了一个 slabs 的列表，这通常是一段连续的内存块。存在 3 种 slab：</p>
<ol>
<li>slabs_full(完全分配的slab)</li>
<li>slabs_partial(部分分配的slab)</li>
<li>slabs_empty(空slab,或者没有对象被分配)。</li>
</ol>
<p>slab 是 slab 分配器的最小单位，在实现上一个 slab 有一个或多个连续的 page 组成（通常只有一个 page ）。单个 slab 可以在 slab 链表之间移动，如果一个半满 slab 被分配了对象后变满了，就要从slabs_partial 中被删除，同时插入到 slabs_full 中去。</p>
<p>可以通过下面的命令查看 slab 信息。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">root@noahsark ~]<span class="comment"># cat /proc/slabinfo</span></span><br><span class="line">slabinfo - version: 2.1</span><br><span class="line"><span class="comment"># name            &lt;active_objs&gt; &lt;num_objs&gt; &lt;objsize&gt; &lt;objperslab&gt; &lt;pagesperslab&gt; : tunables &lt;limit&gt; &lt;batchcount&gt; &lt;sharedfactor&gt; : slabdata &lt;active_slabs&gt; &lt;num_slabs&gt; &lt;sharedavail&gt;</span></span><br><span class="line">...</span><br><span class="line">UDP                  150    150   1088   15    4 : tunables    0    0    0 : slabdata     10     10      0</span><br><span class="line">tw_sock_TCP          208    208    256   16    1 : tunables    0    0    0 : slabdata     13     13      0</span><br><span class="line">TCP                  224    224   1984   16    8 : tunables    0    0    0 : slabdata     14     14      0</span><br><span class="line">net_namespace         12     12   5248    6    8 : tunables    0    0    0 : slabdata      2      2      0</span><br><span class="line">mm_struct            260    260   1600   20    8 : tunables    0    0    0 : slabdata     13     13      0</span><br><span class="line">fs_cache            1856   1856     64   64    1 : tunables    0    0    0 : slabdata     29     29      0</span><br><span class="line">files_cache          122    180    640   12    2 : tunables    0    0    0 : slabdata     15     15      0</span><br><span class="line">task_struct          317    385   4208    7    8 : tunables    0    0    0 : slabdata     55     55      0</span><br><span class="line">cred_jar             299    525    192   21    1 : tunables    0    0    0 : slabdata     25     25      0</span><br><span class="line">anon_vma            2221   2448     80   51    1 : tunables    0    0    0 : slabdata     48     48      0</span><br><span class="line">pid                  704    704    128   32    1 : tunables    0    0    0 : slabdata     22     22      0</span><br><span class="line">shared_policy_node   6840   7480     48   85    1 : tunables    0    0    0 : slabdata     88     88      0</span><br><span class="line">numa_policy           15     15    264   15    1 : tunables    0    0    0 : slabdata      1      1      0</span><br><span class="line">radix_tree_node    29849  30926    584   14    2 : tunables    0    0    0 : slabdata   2209   2209      0</span><br><span class="line">idr_layer_cache      285    285   2112   15    8 : tunables    0    0    0 : slabdata     19     19      0</span><br><span class="line">dma-kmalloc-8192       0      0   8192    4    8 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">dma-kmalloc-4096       0      0   4096    8    8 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">dma-kmalloc-2048       0      0   2048   16    8 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">dma-kmalloc-1024       0      0   1024   16    4 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">dma-kmalloc-512        0      0    512   16    2 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">dma-kmalloc-256        0      0    256   16    1 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">dma-kmalloc-128        0      0    128   32    1 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">dma-kmalloc-64         0      0     64   64    1 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">dma-kmalloc-32         0      0     32  128    1 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">dma-kmalloc-16         0      0     16  256    1 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">dma-kmalloc-8          0      0      8  512    1 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">dma-kmalloc-192        0      0    192   21    1 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">dma-kmalloc-96         0      0     96   42    1 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">kmalloc-8192          48     48   8192    4    8 : tunables    0    0    0 : slabdata     12     12      0</span><br><span class="line">kmalloc-4096         413    432   4096    8    8 : tunables    0    0    0 : slabdata     54     54      0</span><br><span class="line">kmalloc-2048         511    656   2048   16    8 : tunables    0    0    0 : slabdata     41     41      0</span><br><span class="line">kmalloc-1024        1541   1744   1024   16    4 : tunables    0    0    0 : slabdata    109    109      0</span><br><span class="line">kmalloc-512         1147   1232    512   16    2 : tunables    0    0    0 : slabdata     77     77      0</span><br><span class="line">kmalloc-256         1837   2192    256   16    1 : tunables    0    0    0 : slabdata    137    137      0</span><br><span class="line">kmalloc-192        11543  11550    192   21    1 : tunables    0    0    0 : slabdata    550    550      0</span><br><span class="line">kmalloc-128         1792   2080    128   32    1 : tunables    0    0    0 : slabdata     65     65      0</span><br><span class="line">kmalloc-96          2491   2604     96   42    1 : tunables    0    0    0 : slabdata     62     62      0</span><br><span class="line">kmalloc-64         23476  24256     64   64    1 : tunables    0    0    0 : slabdata    379    379      0</span><br><span class="line">kmalloc-32          1920   1920     32  128    1 : tunables    0    0    0 : slabdata     15     15      0</span><br><span class="line">kmalloc-16          4864   4864     16  256    1 : tunables    0    0    0 : slabdata     19     19      0</span><br><span class="line">kmalloc-8           4608   4608      8  512    1 : tunables    0    0    0 : slabdata      9      9      0</span><br><span class="line">kmem_cache_node      192    192     64   64    1 : tunables    0    0    0 : slabdata      3      3      0</span><br><span class="line">kmem_cache           112    112    256   16    1 : tunables    0    0    0 : slabdata      7      7      0</span><br></pre></td></tr></table></figure></p>
<p>可以看到，系统中存在的 slab 有些形如 kmalloc-xxx 的 slab，我们称其为通用型 slab，用来满足分配通用内存。其它含有具体名字的 slab 我们称其为 专用 slab，用来为特定结构体分配内存，如 task_struct 等。</p>
<p>为什么要分专用和通用 slab ？ 最直观的一个原因就是通用 slab 会造成内存浪费：出于 slab 管理的方便，每个 slab 管理的对象大小都是一致的，当我们需要分配一个处于 64-96 字节中间大小的对象时，就必须从保存 96 字节的 slab 中分配。而对于专用的 slab，其管理的都是同一个结构体实例，申请一个就给一个恰好内存大小的对象，这就可以充分利用空间。</p>
<h2 id="4-jemalloc"><a href="#4-jemalloc" class="headerlink" title="4. jemalloc"></a>4. jemalloc</h2><h3 id="4-1-整体架构"><a href="#4-1-整体架构" class="headerlink" title="4.1 整体架构"></a>4.1 整体架构</h3><p>jemalloc 是一种通用的内存管理方法， 着重于减少内存碎片和支持可伸缩的并发性。jemalloc 首次在 FreeBSD 中引入，后续增加了 heap profiling, Valgrind integration, and extensive monitoring/tuning hooks 等功能，目前在多个大型项目中都有应用。其整体结构如下图所示：<br><img src="/images/netty/jemalloc.jpg" alt="jemalloc" title="jemalloc"></p>
<p>jemalloc 将申请的内存分为三个等级：small, large, huge.</p>
<ol>
<li>Small objects 的 size 以 8, 16, 32, 64, 128, 256, 512 Bytes 分隔开，小于 page 大小；</li>
<li>Large objects的 size 以 page 为单位，等差间隔排列，小于 chunk 的大小； </li>
<li>Huge objects的大小是 chunk 大小的整数倍。</li>
</ol>
<p>small objects 和 large objects 由 arena 来管理， huge objects 由线程间公用的红黑树管理。对于64位操作系统，假设 chunk 大小为 4M，page 大小为 4K，内存等级分配如下：</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>间隔</th>
<th>大小</th>
</tr>
</thead>
<tbody>
<tr>
<td>Small</td>
<td>8</td>
<td>[8]</td>
</tr>
<tr>
<td></td>
<td>16</td>
<td>[16, 32, 48, …, 128]</td>
</tr>
<tr>
<td></td>
<td>32</td>
<td>[160, 192, 224, 256]</td>
</tr>
<tr>
<td></td>
<td>64</td>
<td>[320, 384, 448, 512]</td>
</tr>
<tr>
<td></td>
<td>128</td>
<td>[640, 768, 896, 1024]</td>
</tr>
<tr>
<td></td>
<td>256</td>
<td>[1280, 1536, 1792, 2048]</td>
</tr>
<tr>
<td></td>
<td>512</td>
<td>[2560, 3072, 3584]</td>
</tr>
<tr>
<td>Large</td>
<td>4 KiB</td>
<td>[4 KiB, 8 KiB, 12 KiB, …, 4072 KiB]</td>
</tr>
<tr>
<td>Huge</td>
<td>4 MiB</td>
<td>[4 MiB, 8 MiB, 12 MiB, …]</td>
</tr>
</tbody>
</table>
<p>jemalloc 中有几个比较重要的对象，分别是：arena, chunk, bin, run 及 tcache.</p>
<ol>
<li>arena: 为了减少线程间的竞争，jemalloc 将虚拟内存内存分为一定数量的 arenas。每个用户线程都会被绑定到一个 arena 上，线程采用 round-robin 轮询的方式选择可用的 arena 进行内存分配，默认每个 CPU 会分配 4 个 arena;</li>
<li>chunk: arena 由多个 chunk 组成，chunk 的大小为 2 的 k 次方，大于 page 大小。 chunk 的地址与 chunk 大小的整数倍对齐，这样可以通过指针操作在常量时间内找到分配 small/large objects 的元数据, 在对数时间内定位到分配 huge objects的元数据;</li>
<li>bin: bin 代表了相同大小对象的集合，在其大小范围内的对象就由它分配，Small objects 的分配就是通过 bin 分配的;</li>
<li>run: 每一个 bin 都维护一个红黑树，树结点便是 run 对象，用户分配的内存最终就是在 run 中分配。run 实际上就是 chunk 里的一块区域，大小是 page 的整数倍，在 run 的最开头会存储 run header 信息，存有 run 的元数据信息。run 中采用 bitmap 记录分配区域的状态， 相比采用空闲列表的方式， 采用 bitmap 具有以下优点：bitmap 能够快速计算出第一块空闲区域，且能很好的保证已分配区域的紧凑型。分配数据与应用数据是隔离的， 能够减少应用数据对分配数据的干扰，对很小的分配区域的支持更好。</li>
<li>tcache: tcache为线程对应的私有缓存空间， 用于减少线程分配内存时锁的争用， 提高内存分配的效率。如果使用 tcache 时, jemalloc 分配内存时将优先从 tcache 中分配， 只有在 tcache 中找不到才从 arena 中分配，每个 tcache 也会有一个对应的 arena, 在 tcache 内部包含一个 tbin 数组来缓存不同大小的内存块，与 arena 中的 bin 对应，用于存储用户对象。</li>
</ol>
<p>用户内存的分配本质是对 chunk 的分配，用户对象存储在 chunk 中，chunk 目前的默认大小是 4M。chunk 以 page （默认为4K) 为单位进行管理，每个 chunk 的前几个page（默认是6个）用于存储 chunk 的元数据，后面跟着一个或多个 page 的 runs。后面的 runs 可以是未分配区域， 多个小对象组合在一起组成 run, 其元数据放在 run 的头部。 大对象构成的 run, 其元数据放在 chunk 的头部。最后，run 对象挂载到 bin 对象的红黑树上，通过 bin–&gt;run–&gt;chunk 的链路，实现对内存区域 chunk 的管理， 它们之间的关系如图所示：<br><img src="/images/netty/jemalloc_bin_chunk_run.png" alt="jemalloc_bin_chunk_run" title="jemalloc_bin_chunk_run"></p>
<h3 id="4-2-内存管理"><a href="#4-2-内存管理" class="headerlink" title="4.2 内存管理"></a>4.2 内存管理</h3><p>jemalloc 采用多级内存分配，引入线程缓存 tcache, arena 来减少线程间锁的争用， 提高申请释放的效率和线程并发扩展性。我们先看下其分级结构：<br><img src="/images/netty/jemalloc_alloc_mem.png" alt="jemalloc_alloc_mem" title="jemalloc_alloc_mem"></p>
<p>如图所示， jemalloc 的内存管理采用层级架构，分别是线程缓存 tcache, arena 和系统内存，不同大小的内存块对应不同的分配区。每个线程对应一tcache, 负责当前线程使用内存块的快速申请和释放， 避免线程间锁的竞争和同步。arena 的具体结构在前文已经提到，采用内存池的思想对内存区域进行合理的划分和管理，在有效保证低内存碎片的情况下实现不同大小内存块的高效管理。 system memory 是系统的内存区域。</p>
<ol>
<li>small object: 当 jemalloc 支持 tcache 时， small object 的分配从 tcache 开始， tcache 不中则从 arena 申请 run 并将剩余区域缓存到 tcache， 若从 aren a中不能分配再从 system memory 中申请chunk 加入 arena 进行管理, 不支持 tcache 时， 则直接从 arena 中申请。</li>
<li>large object: 当 jemalloc 支持 tcache 时， 如果 large object 的 size 小于 tcache_maxclass，则从 tcache 开始分配， tcache 不中则从 arena 申请, 只申请需要的内存块， 不做多余 cache, 若从arena 中不能分配则从 system memory 中申请。当 large object 的 size 大于 tcache_maxclas s或者 jemmalloc 不支持 tcache 时， 直接从 arena 中申请。</li>
<li>huge object: huge object 的内存不归 arena 管理， 直接采用 mmap 从 system memory 中申请并由一棵与 arena 独立的红黑树进行管理。</li>
</ol>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>这篇文章主要是对内存管理知识的一个整理，感谢参考文献中给出的文章，通过对这些文章的阅读，极大加深了操作系统内存管理相关的知识。</p>
<p><br></p>
<p><strong>参考：</strong></p>
<hr>
<p><a href="https://zhuanlan.zhihu.com/p/36140017" target="_blank" rel="noopener">1. Linux内核内存管理算法Buddy和Slab</a></p>
<p><a href="https://www.dingmos.com/2021/03/22/54.html" target="_blank" rel="noopener">2. Linux 内核 | 内存管理——slab 分配器</a></p>
<p><a href="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Netty%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8E%20RPC%20%E5%AE%9E%E8%B7%B5-%E5%AE%8C/12%20%20%E4%BB%96%E5%B1%B1%E4%B9%8B%E7%9F%B3%EF%BC%9A%E9%AB%98%E6%80%A7%E8%83%BD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8%20jemalloc%20%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.md" target="_blank" rel="noopener">3. 他山之石：高性能内存分配器 jemalloc 基本原理</a></p>
<p><a href="https://engineering.fb.com/2011/01/03/core-data/scalable-memory-allocation-using-jemalloc/" target="_blank" rel="noopener">4. Scalable memory allocation using jemalloc</a></p>
<p><a href="https://brionas.github.io/2015/01/31/jemalloc%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84/" target="_blank" rel="noopener">5. jemalloc源码解析-核心架构</a></p>
<p><a href="https://brionas.github.io/2015/01/31/jemalloc%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" target="_blank" rel="noopener">6. jemalloc源码解析-内存管理</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/29/netty-eventloop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2021/08/29/netty-eventloop/" class="post-title-link" itemprop="http://yoursite.com/index.html">Netty 系列：EventLoop</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2021-08-29 21:17:38" itemprop="dateCreated datePublished" datetime="2021-08-29T21:17:38+08:00">2021-08-29</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-09-19 11:15:49" itemprop="dateModified" datetime="2021-09-19T11:15:49+08:00">2021-09-19</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Netty/" itemprop="url" rel="index"><span itemprop="name">Netty</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">107k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">1:37</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>EventLoop 是 Reactor 模式中的执行者，首先它持有 Selector 对象，监听多路 SocketChannel 的网络 I/O 事件，并对 I/O 事件分发处理。同时，它持有一个 Thread 对象，除了监听网络 I/O 事件， EventLoop 也可以执行提交的任务，包括定时任务，总结来说，EventLoop 具有如下三大功能：</p>
<ol>
<li>负责监听 SocketChannel 对象的 I/O 事件；</li>
<li>处理分发 I/O 事件；</li>
<li>执行任务，包括定时任务。</li>
</ol>
<p>整体的处理流程如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> selectCnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1、监听 Channel 网络事件</span></span><br><span class="line">            <span class="keyword">if</span> (!hasTasks()) &#123;</span><br><span class="line">                strategy = select(curDeadlineNanos);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> ioRatio = <span class="keyword">this</span>.ioRatio;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> ioStartTime = System.nanoTime();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 2、处理网络事件 </span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                processSelectedKeys();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> ioTime = System.nanoTime() - ioStartTime;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 3、执行任务</span></span><br><span class="line">                ranTasks = runAllTasks(ioTime * (<span class="number">100</span> - ioRatio) / ioRatio);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            handleLoopException(t);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// ... </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>说明：</strong> 代码以 NioEventLoop 为例。</p>
<h2 id="2-流程"><a href="#2-流程" class="headerlink" title="2. 流程"></a>2. 流程</h2><p>上文分析了 EventLoop 的主要功能，在这部分内容中主要讲述这三大功能及线程的创建，我们先从线程的创建开始。</p>
<h3 id="2-1-线程创建"><a href="#2-1-线程创建" class="headerlink" title="2.1 线程创建"></a>2.1 线程创建</h3><p>线程相关的变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EventLoop 线程对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state = ST_NOT_STARTED;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ST_NOT_STARTED = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ST_STARTED = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ST_SHUTTING_DOWN = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ST_SHUTDOWN = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ST_TERMINATED = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件执行器，线程池</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Executor executor;</span><br></pre></td></tr></table></figure>
<p>EventLoop 中持有一个线程的引用，在第一次执行任务的时候启动，提供任务的线程如果已经是 EventLoop 线程，将任务提交给任务即可，如果是非 EventLoop 线程，则需要启动 EventLoop 线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task, <span class="keyword">boolean</span> immediate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> inEventLoop = inEventLoop();</span><br><span class="line">    addTask(task);</span><br><span class="line">    <span class="keyword">if</span> (!inEventLoop) &#123;</span><br><span class="line">        startThread();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>EventLoop 中通过 state 字段来标识是否启动，通过判断该字段来决定是否启动线程，其中 state 字段是 volatile 类型，并通过 AtomicIntegerFieldUpdater 进行原子更新，保证线程的安全。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state == ST_NOT_STARTED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (STATE_UPDATER.compareAndSet(<span class="keyword">this</span>, ST_NOT_STARTED, ST_STARTED)) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                doStartThread();</span><br><span class="line">                success = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">                    STATE_UPDATER.compareAndSet(<span class="keyword">this</span>, ST_STARTED, ST_NOT_STARTED);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程的启动是通过 executor 添加一个任务，在 executor 中启动一个线程，再把该线程赋值给 EventLoop，等同于使用了只有一个线程的线程池来生成线程。可以看到，任务的主体是 SingleThreadEventExecutor.this.run() 方法，该方法就是前文说到的 EventLoop 主体业务逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doStartThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> thread == <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用 executor 来启动线程</span></span><br><span class="line">    executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 设置线程变量</span></span><br><span class="line">            thread = Thread.currentThread();</span><br><span class="line">            <span class="keyword">if</span> (interrupted) &#123;</span><br><span class="line">                thread.interrupt();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">            updateLastExecutionTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 执行 EventLoop 的业务逻辑</span></span><br><span class="line">                SingleThreadEventExecutor.<span class="keyword">this</span>.run();</span><br><span class="line">                success = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                logger.warn(<span class="string">"Unexpected exception from an event executor: "</span>, t);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>executor 使用的是 ThreadPerTaskExecutor 对象，在 NioEventLoopGroup 初始化的时候生成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Executor 为 null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(nThreads, (Executor) <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventExecutorGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        EventExecutorChooserFactory chooserFactory, Object... args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果 Executor 为 null,则使用 ThreadPerTaskExecutor</span></span><br><span class="line">    <span class="keyword">if</span> (executor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        executor = <span class="keyword">new</span> ThreadPerTaskExecutor(newDefaultThreadFactory());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    children = <span class="keyword">new</span> EventExecutor[nThreads];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nThreads; i ++) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 生成 EventLoop</span></span><br><span class="line">            children[i] = newChild(executor, args);</span><br><span class="line">            success = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"failed to create a child event loop"</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> EventLoop <span class="title">newChild</span><span class="params">(Executor executor, Object... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    EventLoopTaskQueueFactory queueFactory = args.length == <span class="number">4</span> ? (EventLoopTaskQueueFactory) args[<span class="number">3</span>] : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> NioEventLoop(<span class="keyword">this</span>, executor, (SelectorProvider) args[<span class="number">0</span>],</span><br><span class="line">        ((SelectStrategyFactory) args[<span class="number">1</span>]).newSelectStrategy(), (RejectedExecutionHandler) args[<span class="number">2</span>], queueFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ThreadPerTaskExecutor 执行器会生成一个新的线程来执行新的任务，该线程就是 FastThreadLocalThread 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPerTaskExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 线程工厂对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadFactory threadFactory;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 生成一个新的线程执行任务</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        threadFactory.newThread(command).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成一个新的线程对象</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        Thread t = newThread(FastThreadLocalRunnable.wrap(r), prefix + nextId.incrementAndGet());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成 FastThreadLocalThread 线程</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Thread <span class="title">newThread</span><span class="params">(Runnable r, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FastThreadLocalThread(threadGroup, r, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的代码分析，EventLoop 中的线程由 ThreadPerTaskExecutor 执行器生成，线程对象为 DefaultThreadFactory。</p>
<h3 id="2-3-监听网络-I-O-事件"><a href="#2-3-监听网络-I-O-事件" class="headerlink" title="2.3 监听网络 I/O 事件"></a>2.3 监听网络 I/O 事件</h3><p>Selector 相关的变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NioEventLoop</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Selector selector;</span><br><span class="line"><span class="keyword">private</span> Selector unwrappedSelector;</span><br><span class="line"><span class="keyword">private</span> SelectedSelectionKeySet selectedKeys;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SelectorProvider provider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> AWAKE = -<span class="number">1L</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> NONE = Long.MAX_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// nextWakeupNanos is:</span></span><br><span class="line"><span class="comment">//    AWAKE            when EL is awake</span></span><br><span class="line"><span class="comment">//    NONE             when EL is waiting with no wakeup scheduled</span></span><br><span class="line"><span class="comment">//    other value T    when EL is waiting with wakeup scheduled at time T</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicLong nextWakeupNanos = <span class="keyword">new</span> AtomicLong(AWAKE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SelectStrategy selectStrategy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> cancelledKeys;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> needsToSelectAgain;</span><br></pre></td></tr></table></figure>
<p>在这个阶段有三个重点：</p>
<ol>
<li>设置 selector 的超时时间，主要是以下一个定时任务执行的时间间隔作为参考来设置超时时间，避免阻塞定时任务的准时执行；</li>
<li>selector 唤醒的机制，如果超时时间过长，中途有任务插入，需要执行，此时需要中断 selector；</li>
<li>重建 selector，解决 bug 8566。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> selectCnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> strategy;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                strategy = selectStrategy.calculateStrategy(selectNowSupplier, hasTasks());</span><br><span class="line">                <span class="keyword">switch</span> (strategy) &#123;</span><br><span class="line">                <span class="keyword">case</span> SelectStrategy.CONTINUE:</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> SelectStrategy.BUSY_WAIT:</span><br><span class="line">                    <span class="comment">// fall-through to SELECT since the busy-wait is not supported with NIO</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> SelectStrategy.SELECT:</span><br><span class="line">                    <span class="comment">// 1、计算出下一个定时任务的时间间隔；</span></span><br><span class="line">                    <span class="keyword">long</span> curDeadlineNanos = nextScheduledTaskDeadlineNanos();</span><br><span class="line">                    <span class="keyword">if</span> (curDeadlineNanos == -<span class="number">1L</span>) &#123;</span><br><span class="line">                        curDeadlineNanos = NONE; <span class="comment">// nothing on the calendar</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    nextWakeupNanos.set(curDeadlineNanos);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!hasTasks()) &#123;</span><br><span class="line">                            <span class="comment">// 2、以下一个定时任务的时间间隔作为超时的时间，进行网络时间的监听</span></span><br><span class="line">                            strategy = select(curDeadlineNanos);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        nextWakeupNanos.lazySet(AWAKE);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// fall through</span></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="comment">// If we receive an IOException here its because the Selector is messed up. Let's rebuild</span></span><br><span class="line">                <span class="comment">// the selector and retry. https://github.com/netty/netty/issues/8566</span></span><br><span class="line">                <span class="comment">// 3、创建 Selector，解决 bug 8566。</span></span><br><span class="line">                rebuildSelector0();</span><br><span class="line">                selectCnt = <span class="number">0</span>;</span><br><span class="line">                handleLoopException(e);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            handleLoopException(t);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>计算下一个定时任务执行的时间间隔逻辑比较简单，将 ScheduledFutureTask 任务添加到 scheduledTaskQueue 队列中，而 scheduledTaskQueue 是一个优先级队列，它已经将 ScheduledFutureTask 根据执行时间进行了排序，取出的第一个元素便是最近将要执行的任务，计算它还需要多久需要执行便可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算下一个定时任务执行的时间间隔</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">nextScheduledTaskDeadlineNanos</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ScheduledFutureTask&lt;?&gt; scheduledTask = peekScheduledTask();</span><br><span class="line">    <span class="keyword">return</span> scheduledTask != <span class="keyword">null</span> ? scheduledTask.deadlineNanos() : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取下一个执行的定时任务</span></span><br><span class="line"><span class="keyword">final</span> ScheduledFutureTask&lt;?&gt; peekScheduledTask() &#123;</span><br><span class="line">    Queue&lt;ScheduledFutureTask&lt;?&gt;&gt; scheduledTaskQueue = <span class="keyword">this</span>.scheduledTaskQueue;</span><br><span class="line">    <span class="keyword">return</span> scheduledTaskQueue != <span class="keyword">null</span> ? scheduledTaskQueue.peek() : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优先级队列</span></span><br><span class="line">PriorityQueue&lt;ScheduledFutureTask&lt;?&gt;&gt; scheduledTaskQueue = <span class="keyword">new</span> DefaultPriorityQueue&lt;ScheduledFutureTask&lt;?&gt;&gt;(</span><br><span class="line">                    SCHEDULED_FUTURE_TASK_COMPARATOR,</span><br><span class="line">                    <span class="comment">// Use same initial capacity as java.util.PriorityQueue</span></span><br><span class="line">                    <span class="number">11</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ScheduledFutureTask</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledFutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">PromiseTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">ScheduledFuture</span>&lt;<span class="title">V</span>&gt;, <span class="title">PriorityQueueNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> START_TIME = System.nanoTime();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set once when added to priority queue</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> deadlineNanos;</span><br><span class="line">    <span class="comment">/* 0 - no repeat, &gt;0 - repeat at fixed rate, &lt;0 - repeat with fixed delay */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> periodNanos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> queueIndex = INDEX_NOT_IN_QUEUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 deadlineNanos 及 id 进行排序</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ScheduledFutureTask&lt;?&gt; that = (ScheduledFutureTask&lt;?&gt;) o;</span><br><span class="line">        <span class="keyword">long</span> d = deadlineNanos() - that.deadlineNanos();</span><br><span class="line">        <span class="keyword">if</span> (d &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (d &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (id &lt; that.id) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">assert</span> id != that.id;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>外部线程执行新任务的时候，任务需要立即执行的话，需要唤醒 selector，避免因 selector 长时间等待错过执行时机。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行新任务</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task, <span class="keyword">boolean</span> immediate)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果任务需要立即执行，则需要中断 Selector。</span></span><br><span class="line">    <span class="keyword">if</span> (!addTaskWakesUp &amp;&amp; immediate) &#123;</span><br><span class="line">        wakeup(inEventLoop);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒 selector</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">wakeup</span><span class="params">(<span class="keyword">boolean</span> inEventLoop)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!inEventLoop &amp;&amp; nextWakeupNanos.getAndSet(AWAKE) != AWAKE) &#123;</span><br><span class="line">        selector.wakeup();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重建 selector，解决 bug 8566 的逻辑，后续有时间再另外分析。</p>
<h3 id="2-4-处理及分发网络-I-O-事件"><a href="#2-4-处理及分发网络-I-O-事件" class="headerlink" title="2.4 处理及分发网络 I/O 事件"></a>2.4 处理及分发网络 I/O 事件</h3><p>在 NioEventLoop 中，处理 I/O 事件的时间与执行任务的时间比率为 1:1，即两者的执行时间是相等的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认情况下处理 I/O 事件的时间比率为 50%，即 I/O 处理的时间占执行时间的 50 %。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> ioRatio = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">long</span> ioStartTime = System.nanoTime();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 处理 I/O 事件</span></span><br><span class="line">    processSelectedKeys();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// Ensure we always run tasks.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ioTime = System.nanoTime() - ioStartTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行任务</span></span><br><span class="line">    ranTasks = runAllTasks(ioTime * (<span class="number">100</span> - ioRatio) / ioRatio);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在分析 I/O 事件的处理，这里提供了两种方式，一种是经过 Netty 优化过数据结构的方式，一种是 Java 原生的方式，它们之间的区别主要是存放 SelectionKey 对象的底层数据结构的差异，而处理流程没有变。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKeys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (selectedKeys != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 优化的处理方式</span></span><br><span class="line">        processSelectedKeysOptimized();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        processSelectedKeysPlain(selector.selectedKeys());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化的方法主要是通过反射的方式，将 Selector 中 selectedKeys 和 publicSelectedKeys 字段替换为 Netty 版的 SelectedSelectionKeySet。数据结构做了那些优化可以再深入分析源码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Selector unwrappedSelector;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    unwrappedSelector = provider.openSelector();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(<span class="string">"failed to open a new selector"</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Class&lt;?&gt; selectorImplClass = (Class&lt;?&gt;) maybeSelectorImplClass;</span><br><span class="line"><span class="keyword">final</span> SelectedSelectionKeySet selectedKeySet = <span class="keyword">new</span> SelectedSelectionKeySet()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        Field selectedKeysField = selectorImplClass.getDeclaredField(<span class="string">"selectedKeys"</span>);</span><br><span class="line">        Field publicSelectedKeysField = selectorImplClass.getDeclaredField(<span class="string">"publicSelectedKeys"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// java 9 以上版本，设置 selectedKeysField 及 publicSelectedKeysField 的方式</span></span><br><span class="line">        <span class="keyword">if</span> (PlatformDependent.javaVersion() &gt;= <span class="number">9</span> &amp;&amp; PlatformDependent.hasUnsafe()) &#123;</span><br><span class="line">            <span class="keyword">long</span> selectedKeysFieldOffset = PlatformDependent.objectFieldOffset(selectedKeysField);</span><br><span class="line">            <span class="keyword">long</span> publicSelectedKeysFieldOffset =</span><br><span class="line">                    PlatformDependent.objectFieldOffset(publicSelectedKeysField);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (selectedKeysFieldOffset != -<span class="number">1</span> &amp;&amp; publicSelectedKeysFieldOffset != -<span class="number">1</span>) &#123;</span><br><span class="line">                PlatformDependent.putObject(</span><br><span class="line">                        unwrappedSelector, selectedKeysFieldOffset, selectedKeySet);</span><br><span class="line">                PlatformDependent.putObject(</span><br><span class="line">                        unwrappedSelector, publicSelectedKeysFieldOffset, selectedKeySet);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// java 9 以下版本，设置字段的方式</span></span><br><span class="line">        Throwable cause = ReflectionUtil.trySetAccessible(selectedKeysField, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> cause;</span><br><span class="line">        &#125;</span><br><span class="line">        cause = ReflectionUtil.trySetAccessible(publicSelectedKeysField, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> cause;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        selectedKeysField.set(unwrappedSelector, selectedKeySet);</span><br><span class="line">        publicSelectedKeysField.set(unwrappedSelector, selectedKeySet);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>处理 I/O 事件的大致流程如下：</p>
<ol>
<li>遍历 selectedKeys 集合，处理所有 Channel 的 I/O 事件，一个 SelectionKey 对象代表一个 Channel 的 I/O 事件；</li>
<li>取出 SelectionKey 对象中的附件，该附件由 AbstractNioChannel.doRegister 方法注册到 Selector 对象上，附件就是 AbstractNioChannel 自身，触发 I/O 事件时，再由 SelectionKey 对象返回；</li>
<li>根据附件对象的不同，调用不同的处理逻辑，这里主要是处理 Channel 的 I/O 事件</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKeysOptimized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历 selectedKeys 集合，处理所有 Channel 的 I/O 事件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; selectedKeys.size; ++i) &#123;</span><br><span class="line">        <span class="keyword">final</span> SelectionKey k = selectedKeys.keys[i];</span><br><span class="line">        <span class="comment">// null out entry in the array to allow to have it GC'ed once the Channel close</span></span><br><span class="line">        <span class="comment">// See https://github.com/netty/netty/issues/2363</span></span><br><span class="line">        selectedKeys.keys[i] = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 取出 SelectionKey 对象中的附件，由注册方法添加到 Selector 对象中。</span></span><br><span class="line">        <span class="keyword">final</span> Object a = k.attachment();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 根据附件对象的不同，调用不同的处理逻辑，这里主要是处理 Channel 的 I/O 事件 </span></span><br><span class="line">        <span class="keyword">if</span> (a <span class="keyword">instanceof</span> AbstractNioChannel) &#123;</span><br><span class="line">            processSelectedKey(k, (AbstractNioChannel) a);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            NioTask&lt;SelectableChannel&gt; task = (NioTask&lt;SelectableChannel&gt;) a;</span><br><span class="line">            processSelectedKey(k, task);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (needsToSelectAgain) &#123;</span><br><span class="line">            <span class="comment">// null out entries in the array to allow to have it GC'ed once the Channel close</span></span><br><span class="line">            <span class="comment">// See https://github.com/netty/netty/issues/2363</span></span><br><span class="line">            selectedKeys.reset(i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            selectAgain();</span><br><span class="line">            i = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractNioChannel 注册方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> selected = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将 AbstractNioChannel 以附件的方式注册到 Selector 中。</span></span><br><span class="line">            selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="number">0</span>, <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123;</span><br><span class="line">           <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册方法的申明</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> SelectionKey <span class="title">register</span><span class="params">(Selector sel, <span class="keyword">int</span> ops, Object att)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ClosedChannelException</span>;</span><br></pre></td></tr></table></figure>
<p>真正的处理逻辑在 processSelectedKey 方法中处理，这里有两个重点：</p>
<ol>
<li>写缓存空间充足，注册 OP_WRITE 事件会频繁触发，导致 cpu 空转，所以正常情况下，不需要注册 OP_WRITE 事件，只有在写缓存满的时候才会注册该事件，触发之后进行刷新操作；</li>
<li>在 Netty 中，将 OP_ACCEPT 当作读操作，只不过它读取的数据比较特殊，是 SocketChannel 对象。</li>
</ol>
<p>事件的处理逻辑包含在 AbstractNioChannel.NioUnsafe 中，由该方法调用 ChannelPipeline 中的回调方法，至此，将事件处理由网络层传递给 Netty 框架层。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKey</span><span class="params">(SelectionKey k, AbstractNioChannel ch)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// unsafe</span></span><br><span class="line">    <span class="keyword">final</span> AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> readyOps = k.readyOps();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1、处理 OP_CONNECT 事件</span></span><br><span class="line">        <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_CONNECT) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> ops = k.interestOps();</span><br><span class="line">            ops &amp;= ~SelectionKey.OP_CONNECT;</span><br><span class="line">            k.interestOps(ops);</span><br><span class="line"></span><br><span class="line">            unsafe.finishConnect();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、处理 OP_WRITE 事件，正常情况下，不需要注册 OP_WRITE 事件，</span></span><br><span class="line">        <span class="comment">// 只有在写缓存满的时候才会注册该事件。</span></span><br><span class="line">        <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_WRITE) != <span class="number">0</span>) &#123;</span><br><span class="line">           </span><br><span class="line">            ch.unsafe().forceFlush();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3、处理 OP_READ 及 OP_ACCEPT 事件。在 Netty 中，将 OP_ACCEPT 当作读操作，只不过</span></span><br><span class="line">        <span class="comment">// 它读取的数据比较特殊，是 SocketChannel 对象。</span></span><br><span class="line">        <span class="keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="number">0</span> || readyOps == <span class="number">0</span>) &#123;</span><br><span class="line">            unsafe.read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CancelledKeyException ignored) &#123;</span><br><span class="line">        unsafe.close(unsafe.voidPromise());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以 unsafe.read() 为例，在 NioMessageUnsafe 类的实现中，读取操作会调用 AbstractNioChannel 子类的 doReadMessages 方法读取网络数据，并写入到 readBuf 中，再调用 ChannelPipeline 中的 fireChannelRead 方法将数据传递给 Netty 框架层。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NioMessageUnsafe</span> <span class="keyword">extends</span> <span class="title">AbstractNioUnsafe</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读 Buffer</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Object&gt; readBuf = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">final</span> ChannelConfig config = config();</span><br><span class="line">        <span class="keyword">final</span> ChannelPipeline pipeline = pipeline();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> closed = <span class="keyword">false</span>;</span><br><span class="line">        Throwable exception = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="comment">// 1、调用读取操作</span></span><br><span class="line">                    <span class="keyword">int</span> localRead = doReadMessages(readBuf);</span><br><span class="line">                    </span><br><span class="line">                &#125; <span class="keyword">while</span> (allocHandle.continueReading());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                exception = t;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> size = readBuf.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i ++) &#123;</span><br><span class="line">                readPending = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// 2、触发 fireChannelRead 方法</span></span><br><span class="line">                pipeline.fireChannelRead(readBuf.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// .. </span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 NioServerSocketChannel 类 doReadMessages 实现中，读取到的数据是 SocketChannel，该对象会分配给 WorkerGroup 中，由 WorkerGroup 中的 EventLoop 去读取网络数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NioServerSocketChannel</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doReadMessages</span><span class="params">(List&lt;Object&gt; buf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    SocketChannel ch = SocketUtils.accept(javaChannel());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch != <span class="keyword">null</span>) &#123;</span><br><span class="line">            buf.add(<span class="keyword">new</span> NioSocketChannel(<span class="keyword">this</span>, ch));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在 NioSocketChannel 类的 doReadBytes 实现中，读取到的是 ByteBuf，传递给上层的是 ByteBuf 对象，上层对象再对其进行反序列化、业务处理等操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NioSocketChannel</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doReadBytes</span><span class="params">(ByteBuf byteBuf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();</span><br><span class="line">    allocHandle.attemptedBytesRead(byteBuf.writableBytes());</span><br><span class="line">    <span class="keyword">return</span> byteBuf.writeBytes(javaChannel(), allocHandle.attemptedBytesRead());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，根据 I/O 事件的类型，将数据分发到了上层中，上层业务可以继续处理。</p>
<h3 id="2-5-执行任务"><a href="#2-5-执行任务" class="headerlink" title="2.5 执行任务"></a>2.5 执行任务</h3><h4 id="2-5-1-执行流程"><a href="#2-5-1-执行流程" class="headerlink" title="2.5.1 执行流程"></a>2.5.1 执行流程</h4><p>执行任务相关的变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任务队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Runnable&gt; taskQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时任务队列</span></span><br><span class="line">PriorityQueue&lt;ScheduledFutureTask&lt;?&gt;&gt; scheduledTaskQueue;</span><br></pre></td></tr></table></figure>
<p>在 EventLoop 中，有两类任务，一是常规的任务，没有时间属性，二是周期性或延时的定时任务，它们分别存放到两个不同的队列。任务执行时，先将到期的定时任务从 scheduledTaskQueue 队列移动到 taskQueue 中，再统一执行 taskQueue 队列中的任务。</p>
<p>任务执行的大致如下：</p>
<ol>
<li>将到期的定时任务移动到 taskQueue 中；</li>
<li>计算此次执行的时长，如果执行的时间超过设定的执行时长，则退出进行下一轮的事件处理；</li>
<li>遍历执行 taskQueue 中的任务，在两种情况下退出任务的执行：1）任务的执行时长超过了设定的执行时长；2）taskQueue 队列为空；</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">runAllTasks</span><span class="params">(<span class="keyword">long</span> timeoutNanos)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 1、将定时任务移动到 taskQueue 中</span></span><br><span class="line">    fetchFromScheduledTaskQueue();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 2、从 taskQueue 中取出任务</span></span><br><span class="line">    Runnable task = pollTask();</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">        afterRunningAllTasks();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 3、计算任务执行的时长，如果超过传入的执行时长，需要退出进行下一轮的事件处理。</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = timeoutNanos &gt; <span class="number">0</span> ? ScheduledFutureTask.nanoTime() + timeoutNanos : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> runTasks = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> lastExecutionTime;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 4、执行任务</span></span><br><span class="line">        safeExecute(task);</span><br><span class="line"></span><br><span class="line">        runTasks ++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5、每执行完 64 个任务之后，判断是否超过传入的执行时长，若超过，则退出</span></span><br><span class="line">        <span class="keyword">if</span> ((runTasks &amp; <span class="number">0x3F</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            lastExecutionTime = ScheduledFutureTask.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (lastExecutionTime &gt;= deadline) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 6、执行下一个任务，如果任务为空，则退出</span></span><br><span class="line">        task = pollTask();</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">            lastExecutionTime = ScheduledFutureTask.nanoTime();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    afterRunningAllTasks();</span><br><span class="line">    <span class="keyword">this</span>.lastExecutionTime = lastExecutionTime;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>移动到期的定时任务逻辑相对简单：遍历 scheduledTaskQueue 队列，将到期的任务从 scheduledTaskQueue 队列中移除，再添加到 taskQueue 队列中，如果添加失败，则再添加回 scheduledTaskQueue 队列，等待下次再操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">fetchFromScheduledTaskQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 1、nanoTime 表示从程序启动到此时的时长；</span></span><br><span class="line">	<span class="comment">// 时间的判断都是根据相对时间来判断，起始时间为程序启动的时间</span></span><br><span class="line">    <span class="keyword">long</span> nanoTime = AbstractScheduledEventExecutor.nanoTime();</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 2、取出到期的任务</span></span><br><span class="line">        Runnable scheduledTask = pollScheduledTask(nanoTime);</span><br><span class="line">        <span class="keyword">if</span> (scheduledTask == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 3、将任务添加到 taskQueue 中</span></span><br><span class="line">        <span class="keyword">if</span> (!taskQueue.offer(scheduledTask)) &#123;</span><br><span class="line">           </span><br><span class="line">		   <span class="comment">// 4、如果添加失败，再添加回 scheduledTaskQueue 队列，等待下次添加</span></span><br><span class="line">            scheduledTaskQueue.add((ScheduledFutureTask&lt;?&gt;) scheduledTask);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在定时任务任务中超时的判断是基于相对时间的，起始时间为程序启动的时间。在 scheduledTask 中关联有一个任务执行的截止时间，将这个截止时间与当前计算的时间进行比较，小于当前的时间则说明已经过期，满足执行的条件，则需要将该任务移动到 taskQueue。</p>
<p>另外，scheduledTaskQueue 是一个优先级队列，已经根据截止时间排序，队首的元素是最先到期的任务，如果取到了未到期的任务，则停止遍历，因为后面的任务截止时间更大，没有必要进行比较了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Runnable <span class="title">pollScheduledTask</span><span class="params">(<span class="keyword">long</span> nanoTime)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">inEventLoop</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 1、取出队首的任务</span></span><br><span class="line">    ScheduledFutureTask&lt;?&gt; scheduledTask = peekScheduledTask();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 2、判断任务是否过期，判断的逻辑是：比较任务的截止时间与当前时间进行比较，如果</span></span><br><span class="line">	<span class="comment">// 截止时间小于当前时间，则说明过期。</span></span><br><span class="line">    <span class="keyword">if</span> (scheduledTask == <span class="keyword">null</span> || scheduledTask.deadlineNanos() - nanoTime &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 3、移出对首的任务</span></span><br><span class="line">    scheduledTaskQueue.remove();</span><br><span class="line">    scheduledTask.setConsumed();</span><br><span class="line">    <span class="keyword">return</span> scheduledTask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> START_TIME = System.nanoTime();</span><br><span class="line"><span class="comment">// 计算相对时间</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">nanoTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> System.nanoTime() - START_TIME;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 scheduledTaskQueue 队列</span></span><br><span class="line">PriorityQueue&lt;ScheduledFutureTask&lt;?&gt;&gt; scheduledTaskQueue() &#123;</span><br><span class="line">    <span class="keyword">if</span> (scheduledTaskQueue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        scheduledTaskQueue = <span class="keyword">new</span> DefaultPriorityQueue&lt;ScheduledFutureTask&lt;?&gt;&gt;(</span><br><span class="line">                SCHEDULED_FUTURE_TASK_COMPARATOR,</span><br><span class="line">                <span class="comment">// Use same initial capacity as java.util.PriorityQueue</span></span><br><span class="line">                <span class="number">11</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> scheduledTaskQueue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-5-2-任务的添加"><a href="#2-5-2-任务的添加" class="headerlink" title="2.5.2 任务的添加"></a>2.5.2 任务的添加</h4><p>上面分析了任务执行的流程，下面看下这两类任务怎么添加到任务队列中。</p>
<p><strong>1、常规任务</strong></p>
<p>常规任务是通过 execute 方法添加的，该方法含义上有执行的意思，但实际上执行该方法，只是将任务添加到 taskQueue 中，任务的执行最终是在 EventLoop 线程中完成的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加一个常规任务</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">    ObjectUtil.checkNotNull(task, <span class="string">"task"</span>);</span><br><span class="line">    execute(task, !(task <span class="keyword">instanceof</span> LazyRunnable) &amp;&amp; wakesUpForTask(task));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加或执行任务</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task, <span class="keyword">boolean</span> immediate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> inEventLoop = inEventLoop();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 将任务添加到 taskQueue 队列</span></span><br><span class="line">    addTask(task);</span><br><span class="line">    <span class="keyword">if</span> (!inEventLoop) &#123;</span><br><span class="line">		<span class="comment">// 如果当前线程不是 EventLoop 线程，则尝试启动 EventLoop 线程。</span></span><br><span class="line">        startThread();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果任务不是 LazyRunnable 或 NonWakeupRunnable 子类，则</span></span><br><span class="line">	<span class="comment">// 唤醒 EventLoop 线程，立即执行任务</span></span><br><span class="line">    <span class="keyword">if</span> (!addTaskWakesUp &amp;&amp; immediate) &#123;</span><br><span class="line">        wakeup(inEventLoop);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加任务</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addTask</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">    ObjectUtil.checkNotNull(task, <span class="string">"task"</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果任务添加不成功，则拒绝任务</span></span><br><span class="line">    <span class="keyword">if</span> (!offerTask(task)) &#123;</span><br><span class="line">        reject(task);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加任务到 taskQueue 中</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">offerTask</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isShutdown()) &#123;</span><br><span class="line">        reject();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> taskQueue.offer(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2、定时任务</strong><br>定时任务有两种：1）延时任务；2）周期性任务。它们是通过 schedule 方法添加，方法定义如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 延时任务</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">ScheduledFuture&lt;?&gt; schedule(Runnable command, <span class="keyword">long</span> delay, TimeUnit unit);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带返回结果的延时任务</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">&lt;V&gt; <span class="function">ScheduledFuture&lt;V&gt; <span class="title">schedule</span><span class="params">(Callable&lt;V&gt; callable, <span class="keyword">long</span> delay, TimeUnit unit)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 固定比率的周期性任务</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, <span class="keyword">long</span> initialDelay, <span class="keyword">long</span> period, TimeUnit unit);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 固定延时的周期性任务</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, <span class="keyword">long</span> initialDelay, <span class="keyword">long</span> delay, TimeUnit unit);</span><br></pre></td></tr></table></figure>
<p>两种类型的定时任务统一封装为 ScheduledFutureTask 任务，添加一个定时任务实际就是添加一个 ScheduledFutureTask 对象到 scheduledTaskQueue 中。添加 ScheduledFuture 的过程中，如果当前线程就是 EventLoop 线程，则直接操作即可，如果当前线程不是 EventLoop 线程，则添加一个常规任务，用来执行该操作。这样设计，应该是出于线程安全的考虑，保证只有 EventLoop 线程执行添加操作。在这里，还需要考虑定时任务已经过期，需要唤醒 EventLoop 线程执行任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;V&gt; <span class="function">ScheduledFuture&lt;V&gt; <span class="title">schedule</span><span class="params">(<span class="keyword">final</span> ScheduledFutureTask&lt;V&gt; task)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果当前线程是 EventLoop 线程则直接将任务添加到 scheduledTaskQueue 中；</span></span><br><span class="line">	<span class="comment">// 如果不是，添加一个常规任务，用来执行添加操作。</span></span><br><span class="line">    <span class="keyword">if</span> (inEventLoop()) &#123;</span><br><span class="line">        scheduleFromEventLoop(task);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 计算任务执行的截止时间</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadlineNanos = task.deadlineNanos();</span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 比较任务的执行时间与 EventLoop 线程被唤醒的时间的大小，</span></span><br><span class="line">		<span class="comment">// 如果小于线程的唤醒时间，除了向 taskQueue 添加任务之外，需要唤醒线程执行任务；</span></span><br><span class="line">		<span class="comment">// 如果大于线程的唤醒时间，只是向 taskQueue 添加任务，不需要唤醒线程。</span></span><br><span class="line">        <span class="keyword">if</span> (beforeScheduledTaskSubmitted(deadlineNanos)) &#123;</span><br><span class="line">            execute(task);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            lazyExecute(task);</span><br><span class="line">            <span class="keyword">if</span> (afterScheduledTaskSubmitted(deadlineNanos)) &#123;</span><br><span class="line">                execute(WAKEUP_TASK);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向 scheduledTaskQueue 队列添加定时任务</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleFromEventLoop</span><span class="params">(<span class="keyword">final</span> ScheduledFutureTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// nextTaskId a long and so there is no chance it will overflow back to 0</span></span><br><span class="line">    scheduledTaskQueue().add(task.setId(++nextTaskId));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断任务的执行截止时间与 EventLoop 线程被唤醒的时间的大小</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">beforeScheduledTaskSubmitted</span><span class="params">(<span class="keyword">long</span> deadlineNanos)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Note this is also correct for the nextWakeupNanos == -1 (AWAKE) case</span></span><br><span class="line">    <span class="keyword">return</span> deadlineNanos &lt; nextWakeupNanos.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ScheduledFutureTask 对象封装了三个功能：</p>
<ol>
<li>执行添加任务，将 ScheduledFutureTask 对象本身添加到 scheduledTaskQueue 队列；</li>
<li>执行延时任务，由于延时任务只会执行一次，执行完便结束；</li>
<li>执行周期性任务，执行完本轮的任务之外，还需要将 ScheduledFutureTask 添加回 scheduledTaskQueue 队列，等待下一轮执行。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledFutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">PromiseTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">ScheduledFuture</span>&lt;<span class="title">V</span>&gt;, <span class="title">PriorityQueueNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> START_TIME = System.nanoTime();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// set once when added to priority queue</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> deadlineNanos;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// periodNanos 表示任务的任务：</span></span><br><span class="line">	<span class="comment">// 0 - no repeat, &gt;0 - repeat at fixed rate, &lt;0 - repeat with fixed delay </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> periodNanos;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> queueIndex = INDEX_NOT_IN_QUEUE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">nanoTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.nanoTime() - START_TIME;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">initialNanoTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> START_TIME;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">executor</span><span class="params">()</span>.<span class="title">inEventLoop</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 如果未到期，则执行添加任务</span></span><br><span class="line">            <span class="keyword">if</span> (delayNanos() &gt; <span class="number">0L</span>) &#123;</span><br><span class="line">                <span class="comment">// Not yet expired, need to add or remove from queue</span></span><br><span class="line">                <span class="keyword">if</span> (isCancelled()) &#123;</span><br><span class="line">                    scheduledExecutor().scheduledTaskQueue().removeTyped(<span class="keyword">this</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">// 向 scheduledTaskQueue 添加自己</span></span><br><span class="line">                    scheduledExecutor().scheduleFromEventLoop(<span class="keyword">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 如果是延时任务，只需要执行一次</span></span><br><span class="line">            <span class="keyword">if</span> (periodNanos == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (setUncancellableInternal()) &#123;</span><br><span class="line">					<span class="comment">// 执行任务</span></span><br><span class="line">                    V result = runTask();</span><br><span class="line">					</span><br><span class="line">					<span class="comment">// 通知执行成功</span></span><br><span class="line">                    setSuccessInternal(result);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果是周期性任务，执行完任务之后，还需要重新再调度</span></span><br><span class="line">                <span class="comment">// check if is done as it may was cancelled</span></span><br><span class="line">                <span class="keyword">if</span> (!isCancelled()) &#123;</span><br><span class="line">					<span class="comment">// 执行任务</span></span><br><span class="line">                    runTask();</span><br><span class="line">                    <span class="keyword">if</span> (!executor().isShutdown()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (periodNanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            deadlineNanos += periodNanos;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            deadlineNanos = nanoTime() - periodNanos;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (!isCancelled()) &#123;</span><br><span class="line">							</span><br><span class="line">							<span class="comment">// 添加回 scheduledTaskQueue 队列，等待下一次执行</span></span><br><span class="line">                            scheduledExecutor().scheduledTaskQueue().add(<span class="keyword">this</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable cause) &#123;</span><br><span class="line">            setFailureInternal(cause);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，任务的执行分析完毕。</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>EventLoop 担当了网络层与 Netty 框架间的桥梁作用，本质是一个事件循环，不断监听 Channel 的网络 I/O 事件，并进行分发处理。另外，也承担了执行任务的作用，包括常规的任务及定时任务。理解 EventLoop 的事件循环会极大加深对 Netty 的理解。</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/28/netty-channel-pipeline/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2021/08/28/netty-channel-pipeline/" class="post-title-link" itemprop="http://yoursite.com/index.html">Netty 系列：ChannelPipeline</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2021-08-28 22:48:35" itemprop="dateCreated datePublished" datetime="2021-08-28T22:48:35+08:00">2021-08-28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-09-04 11:01:20" itemprop="dateModified" datetime="2021-09-04T11:01:20+08:00">2021-09-04</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Netty/" itemprop="url" rel="index"><span itemprop="name">Netty</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">28k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">25 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>ChannelPipeline 可以理解为一个 ChannelHandler 列表，而 ChannelHandler 是一个能够独立处理 channel 入站 (inbound) 事件或出站 (outbound) 操作的处理器。ChannelPipeline 实现了 “Intercepting Filter” 模式，它给用户提供了事件处理及 ChannelHandler 之间交互的能力，用户可以根据业务场景定义 ChannelHandler，以类似插件的方式添加到 ChannelPipeline 中。</p>
<h3 id="1-1-整体流程"><a href="#1-1-整体流程" class="headerlink" title="1.1 整体流程"></a>1.1 整体流程</h3><p>每一个 channel 都包含一个属于自己的 ChannelPipeline，在创建 channel 的时候自动创建，下图描述了 ChannelPipeline 是如何处理 I/O 事件的，一个 I/O 事件要么被 ChannelInboundHandler 处理，要么被 ChannelOutboundHandler，同时通过 ChannelHandlerContext 将事件传递给下一个 ChannelHandler，如通过如下方法：ChannelHandlerContext#fireChannelRead(Object) 和 ChannelHandlerContext#write(Object)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">                                                I/O Request</span><br><span class="line">                                          via Channel or ChannelHandlerContext</span><br><span class="line">                                                    |</span><br><span class="line">                                                    |</span><br><span class="line">+---------------------------------------------------+---------------+</span><br><span class="line">|                           ChannelPipeline         |               |</span><br><span class="line">|                                                  \|/              |</span><br><span class="line">|    +---------------------+            +-----------+----------+    |</span><br><span class="line">|    | Inbound Handler  N  |            | Outbound Handler  1  |    |</span><br><span class="line">|    +----------+----------+            +-----------+----------+    |</span><br><span class="line">|              /|\                                  |               |</span><br><span class="line">|               |                                  \|/              |</span><br><span class="line">|    +----------+----------+            +-----------+----------+    |</span><br><span class="line">|    | Inbound Handler N-1 |            | Outbound Handler  2  |    |</span><br><span class="line">|    +----------+----------+            +-----------+----------+    |</span><br><span class="line">|              /|\                                  .               |</span><br><span class="line">|               .                                   .               |</span><br><span class="line">| ChannelHandlerContext.fireIN_EVT() ChannelHandlerContext.OUT_EVT()|</span><br><span class="line">|        [ method call]                       [method call]         |</span><br><span class="line">|               .                                   .               |</span><br><span class="line">|               .                                  \|/              |</span><br><span class="line">|    +----------+----------+            +-----------+----------+    |</span><br><span class="line">|    | Inbound Handler  2  |            | Outbound Handler M-1 |    |</span><br><span class="line">|    +----------+----------+            +-----------+----------+    |</span><br><span class="line">|              /|\                                  |               |</span><br><span class="line">|               |                                  \|/              |</span><br><span class="line">|    +----------+----------+            +-----------+----------+    |</span><br><span class="line">|    | Inbound Handler  1  |            | Outbound Handler  M  |    |</span><br><span class="line">|    +----------+----------+            +-----------+----------+    |</span><br><span class="line">|              /|\                                  |               |</span><br><span class="line">+---------------+-----------------------------------+---------------+</span><br><span class="line">                |                                  \|/</span><br><span class="line">+---------------+-----------------------------------+---------------+</span><br><span class="line">|               |                                   |               |</span><br><span class="line">|       [ Socket.read() ]                    [ Socket.write() ]     |</span><br><span class="line">|                                                                   |</span><br><span class="line">|  Netty Internal I/O Threads (Transport Implementation)            |</span><br><span class="line">+-------------------------------------------------------------------+</span><br></pre></td></tr></table></figure>
<p>如左边的图所示，入站（inbound）事件从自底向上的方向被 inbound handler 处理，处理的数据来自于 I/O 线程，这些数据通常来自于远程的机器，通过 SocketChannel#read(ByteBuffer) 方法读到。如果一个入站事件传递到了最后一个 inbound handler，它通常会被丢弃，或者日志输出。</p>
<p>出站（outbound）事件从自顶向下的方向被 outbound handler 处理，outbound handler 通常对写数据进行转换或处理，并传递给 I/O 线程，I/O 线程最后通过 SocketChannel#write(ByteBuffer) 方法写入到网络上，传输给远程的机器。</p>
<p>举一个例子，假设以下面的方式创建 pipeline：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ChannelPipeline p = <span class="keyword">new</span> DefaultChannelPipeline();</span><br><span class="line">p.addLast(<span class="string">"1"</span>, <span class="keyword">new</span> InboundHandlerA());</span><br><span class="line">p.addLast(<span class="string">"2"</span>, <span class="keyword">new</span> InboundHandlerB());</span><br><span class="line">p.addLast(<span class="string">"3"</span>, <span class="keyword">new</span> OutboundHandlerA());</span><br><span class="line">p.addLast(<span class="string">"4"</span>, <span class="keyword">new</span> OutboundHandlerB());</span><br><span class="line">p.addLast(<span class="string">"5"</span>, <span class="keyword">new</span> InboundOutboundHandlerX());</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，以 Inbound 开头的 Handler 代表 InboundHandler，以 Outbound 开头的 Handler 代表 OutboundHandler。对于入站（inbound）事件而言，Handler 执行顺序为 1，2，3，4，5，由于 3 和 4 是 Outbound Handler，执行的时候会直接跳过，真正执行的 Handler 顺序为 1，2，5；对于 Outbound 而言，执行相反的顺序：5，4，3，2，1，跳过 2 和 1，最后的执行顺序为 5，4，3。因为 5 同时实现了 ChannelInboundHandler 和 ChannelOutboundHandler，入站和出站事件都需要执行它。</p>
<p>如果添加的 Handler 比较耗时，建议将该 Handler 提交到指定的线程中处理，以免阻塞 I/O 线程，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ChannelPipeline p = <span class="keyword">new</span> DefaultChannelPipeline();</span><br><span class="line"></span><br><span class="line">pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> MyProtocolDecoder());</span><br><span class="line">pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> MyProtocolEncoder());</span><br><span class="line"></span><br><span class="line">EventExecutorGroup group = <span class="keyword">new</span>  DefaultEventExecutorGroup(<span class="number">16</span>);</span><br><span class="line">pipeline.addLast(group, <span class="string">"handler"</span>, <span class="keyword">new</span> MyBusinessLogicHandler());</span><br></pre></td></tr></table></figure>
<h3 id="1-2-事件传播"><a href="#1-2-事件传播" class="headerlink" title="1.2 事件传播"></a>1.2 事件传播</h3><p>在 ChannelPipeline 中，事件主要主要是通过调用 ChannelHandlerContext 中的方法进行传播，这些方法包括：</p>
<p><strong>Inbound event propagation method</strong></p>
<ul>
<li>ChannelHandlerContext#fireChannelRegistered()        </li>
<li>ChannelHandlerContext#fireChannelActive()            </li>
<li>ChannelHandlerContext#fireChannelRead(Object)        </li>
<li>ChannelHandlerContext#fireChannelReadComplete()      </li>
<li>ChannelHandlerContext#fireExceptionCaught(Throwable) </li>
<li>ChannelHandlerContext#fireUserEventTriggered(Object) </li>
<li>ChannelHandlerContext#fireChannelWritabilityChanged()</li>
<li>ChannelHandlerContext#fireChannelInactive()          </li>
<li>ChannelHandlerContext#fireChannelUnregistered() </li>
</ul>
<p><strong>Outbound event propagation method</strong></p>
<ul>
<li>ChannelHandlerContext#bind(SocketAddress, ChannelPromise)</li>
<li>ChannelHandlerContext#connect(SocketAddress, SocketAddress, ChannelPromise)</li>
<li>ChannelHandlerContext#write(Object, ChannelPromise)</li>
<li>ChannelHandlerContext#flush()</li>
<li>ChannelHandlerContext#read()</li>
<li>ChannelHandlerContext#disconnect(ChannelPromise)</li>
<li>ChannelHandlerContext#close(ChannelPromise)</li>
<li>ChannelHandlerContext#deregister(ChannelPromise)</li>
</ul>
<p>在处理完当前的 Handler 之后，需要调用 ChannelHandlerContext 中的传播方法，如 ctx.fireChannelActive() 和 ctx.close(promise)，如下面的代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInboundHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Connected!"</span>);</span><br><span class="line">        <span class="comment">// 将入站事件传播给下一个 Handler</span></span><br><span class="line">        ctx.fireChannelActive();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyOutboundHandler</span> <span class="keyword">extends</span> <span class="title">ChannelOutboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">( ChannelHandlerContext ctx, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Closing .."</span>);</span><br><span class="line">        <span class="comment">// 将 close 事件传播给下一个 Handler</span></span><br><span class="line">        ctx.close(promise);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-数据结构"><a href="#2-数据结构" class="headerlink" title="2. 数据结构"></a>2. 数据结构</h2><p>上面讲述了 ChannelPipeline 的整体流程，现在我们分析下 ChannelPipeline 的数据结构及 ChannelPipeline,ChannelHandlerContext,ChannelHandler 三者之间的关系。</p>
<h3 id="2-1-整体结构"><a href="#2-1-整体结构" class="headerlink" title="2.1 整体结构"></a>2.1 整体结构</h3><p><img src="/images/netty/netty-channel-pipeline.jpg" alt="netty-channel-pipeline" title="netty-channel-pipeline"></p>
<p>如图所示：</p>
<ol>
<li>ChannelHandler 与 ChannelHandlerContext 是一一对应关系，ChannelHandlerContext 持有 ChannelHandler 的引用；</li>
<li>多个 ChannelHandlerContext 之间使用双向循环链表进行关联；</li>
<li>ChannelPipeline 持有 ChannelHandlerContext 链表 head,tail 结点的引用；</li>
<li>HeadContext,TailContext 是特殊的 ChannelHandlerContext，它们不仅继承了 ChannelHandlerContext，也继承了 ChannelHandler，所以不需要引用 ChannelHandler；</li>
<li>入站事件 Handler 执行顺序为：head –&gt; tail，出站事件则相反：tail –&gt; head。</li>
</ol>
<p><strong>HeadContext</strong><br>HeadContext 是一个特殊的 ChannelHandlerContext，它不仅继承了 AbstractChannelHandlerContext，同时也继承了出站和入站的 ChannelHandler，这有以下的特点：</p>
<ol>
<li>对于入站事件，它是第一个执行的 ChannelHandler，内部做了一些处理之后，调用 ChannelHandlerContext 相对应的方法，将事件传播给下一个 ChannelHandler；</li>
<li>对于出站事件，它是最后一个执行的 ChannelHandler，它直接调用 AbstractChannel.AbstractUnsafe 的方法，由 AbstractUnsafe 做处理。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HeadContext</span> <span class="keyword">extends</span> <span class="title">AbstractChannelHandlerContext</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ChannelOutboundHandler</span>, <span class="title">ChannelInboundHandler</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 指向 AbstractChannel.AbstractUnsafe</span></span><br><span class="line">    <span class="comment">// 调用 channel 底层的网络接口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Unsafe unsafe;</span><br><span class="line"></span><br><span class="line">    HeadContext(DefaultChannelPipeline pipeline) &#123;</span><br><span class="line">        <span class="keyword">super</span>(pipeline, <span class="keyword">null</span>, HEAD_NAME, HeadContext<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        unsafe = pipeline.channel().unsafe();</span><br><span class="line">        setAddComplete();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 出站回调，调用底层的 bind 接口</span></span><br><span class="line">    <span class="comment">// HeadContext 是最后一个出站的 handler, 不用再调用 handler</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">        unsafe.bind(localAddress, promise);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 入站回调，传播下一个 handler</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        invokeHandlerAddedIfNeeded();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将事件传播给下一个 handler</span></span><br><span class="line">        ctx.fireChannelRegistered();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">        ctx.fireChannelRead(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>TailContext</strong></p>
<p>TailContext 同样是一个特殊的 ChannelHandlerContext，它除了继承 AbstractChannelHandlerContext，也同时继承了入站的 ChannelInboundHandler，它是最后一个执行的 ChannelInboundHandler，回调的方法大部分是空方法，不做业务处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TailContext</span> <span class="keyword">extends</span> <span class="title">AbstractChannelHandlerContext</span> <span class="keyword">implements</span> <span class="title">ChannelInboundHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    TailContext(DefaultChannelPipeline pipeline) &#123;</span><br><span class="line">        <span class="keyword">super</span>(pipeline, <span class="keyword">null</span>, TAIL_NAME, TailContext<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        setAddComplete();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelHandler <span class="title">handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 入站方向，最后一个ChannelInboundHandler，不处处理</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入站方向，最后一个ChannelInboundHandler，不处处理</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">        onUnhandledInboundMessage(ctx, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        onUnhandledInboundChannelReadComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-初始化"><a href="#2-2-初始化" class="headerlink" title="2.2 初始化"></a>2.2 初始化</h3><p>ChannelInitializer 是一个特殊的 ChannelInboundHandlerAdapter 子类，通过 initChannel 方法，当 Channel 注册到 EventLoop 之后，就会调用该方法，完成 ChannelHandler 的添加。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义 ChannelInitializer，初始化 Handler</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyChannelInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">        channel.pipeline().addLast(<span class="string">"myHandler1"</span>, <span class="keyword">new</span> MyHandler1());</span><br><span class="line">        channel.pipeline().addLast(<span class="string">"myHandler2"</span>, <span class="keyword">new</span> MyHandler2());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"><span class="comment">// 设置 ChannelInitializer</span></span><br><span class="line">bootstrap.childHandler(<span class="keyword">new</span> MyChannelInitializer());</span><br><span class="line"></span><br><span class="line"><span class="comment">// ChannelInitializer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">C</span> <span class="keyword">extends</span> <span class="title">Channel</span>&gt; <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(C ch)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ctx.channel().isRegistered()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (initChannel(ctx)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 执行完 initChannel 之后 ，将 ChannelInitializer 自己移除</span></span><br><span class="line">                removeState(ctx);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ChannelInitializer 类特殊的地方在于，执行 initChannel 方法之后，ChannelInitializer 实例将会从 ChannelPipeline 中移除。</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>ChannelPipeline 是 Netty 中的一个重要组件，它是 ChannelHandler 的容器类，管理着入站和出站 ChannelHandler 列表，并通过 ChannelHandlerContext 在 ChannelHandler 间传播 I/O 事件。同时ChannelPipeline 实现了责任链的设计模式， 业务逻辑可以按照功能拆分为多个独立的 ChannelHandler ，如果需要更新某个 ChannelHandler ，不用改动其它 ChannelHandler，使得应用具有较好的扩展性。</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/26/netty-server-bootstrap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2021/08/26/netty-server-bootstrap/" class="post-title-link" itemprop="http://yoursite.com/index.html">Netty 系列：ServerBootstrap</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2021-08-26 14:39:14" itemprop="dateCreated datePublished" datetime="2021-08-26T14:39:14+08:00">2021-08-26</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-08-28 20:45:13" itemprop="dateModified" datetime="2021-08-28T20:45:13+08:00">2021-08-28</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Netty/" itemprop="url" rel="index"><span itemprop="name">Netty</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">49k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">45 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>因 Netty 中大量使用异步的调用方式，启动流程中的代码在不同的线程中执行，给分析其启动的顺序带来了一定的麻烦。这篇文章主要是对 ServerBootstrap 服务器启动流程做一个整体性的讲述，分析了每一个步骤所承担的工作，以及前后步骤的触发关系，即前一个步骤怎么调用后一个步骤，仍然以服务器启动的代码为例，分析其流程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"><span class="keyword">final</span> EchoServerHandler serverHandler = <span class="keyword">new</span> EchoServerHandler();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">    b.group(bossGroup, workerGroup)</span><br><span class="line">     .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)      // 设置服务器 <span class="title">channel</span> 对象</span></span><br><span class="line"><span class="class">     .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">SO_BACKLOG</span>, 100)</span></span><br><span class="line"><span class="class">     .<span class="title">handler</span>(<span class="title">new</span> <span class="title">LoggingHandler</span>(<span class="title">LogLevel</span>.<span class="title">INFO</span>)) // 配置 <span class="title">ChannelHandler</span> 对象</span></span><br><span class="line"><span class="class">     .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">             ChannelPipeline p = ch.pipeline();</span><br><span class="line">             <span class="keyword">if</span> (sslCtx != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 p.addLast(sslCtx.newHandler(ch.alloc()));</span><br><span class="line">             &#125;</span><br><span class="line">             </span><br><span class="line">             p.addLast(serverHandler);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定端口并等待完成</span></span><br><span class="line">    ChannelFuture f = b.bind(PORT).sync();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待 channel 关闭</span></span><br><span class="line">    f.channel().closeFuture().sync();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    </span><br><span class="line">    bossGroup.shutdownGracefully();</span><br><span class="line">    workerGroup.shutdownGracefully();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前后的文章已经分析过 EventLoopGroup 及 ChannelFutue，这里重点分析 bind 流程。</p>
<p><img src="/images/netty/netty-bind-v2.jpg" alt="netty-bind" title="netty-bind"></p>
<p>主要流程如下：</p>
<ol>
<li>新建 NioServerSocketChannel 对象；</li>
<li>初始化 NioServerSocketChannel 对象，主要是向其添加 ChannelHandler 对象；</li>
<li>注册 NioServerSocketChannel 对象，主要是将该对象注册到 EventLoop 和 底层的 Selector 对象中；</li>
<li>执行 NioServerSocketChannel 对象的 bind 操作；</li>
<li>执行 NioServerSocketChannel read 操作，主要是向 Selector 对象注册 OP_ACCEPT 事件，完成之后便可接收网络请求。</li>
</ol>
<h2 id="2-执行流程"><a href="#2-执行流程" class="headerlink" title="2. 执行流程"></a>2. 执行流程</h2><h3 id="2-1-新建-NioServerSocketChannel-对象"><a href="#2-1-新建-NioServerSocketChannel-对象" class="headerlink" title="2.1 新建 NioServerSocketChannel 对象"></a>2.1 新建 NioServerSocketChannel 对象</h3><p>在 Netty 中，Nio Tcp Channel 有两种类型，一种是 NioServerSocketChannel，它代表了服务器 Channel，接收网络请求（OP_ACCEPT），另外一种是 NioSocketChannel，它代表了一次网络连接，读取网络数据。在 ServerBootstrap 中使用是 NioServerSocketChannel 对象，该对象通过反射方式生成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置 channel 为 NioServerSocketChannel</span></span><br><span class="line">b.group(bossGroup, workerGroup)</span><br><span class="line">    .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>) </span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">// 设置 <span class="title">channelFactory</span> 为 <span class="title">ReflectiveChannelFactory</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">B</span> <span class="title">channel</span>(<span class="title">Class</span>&lt;? <span class="keyword">extends</span> <span class="title">C</span>&gt; <span class="title">channelClass</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> channelFactory(<span class="keyword">new</span> ReflectiveChannelFactory&lt;C&gt;(</span><br><span class="line">            ObjectUtil.checkNotNull(channelClass, <span class="string">"channelClass"</span>)</span><br><span class="line">    ));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReflectiveChannelFactory 对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectiveChannelFactory</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Channel</span>&gt; <span class="keyword">implements</span> <span class="title">ChannelFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Constructor&lt;? extends T&gt; constructor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器，参数为 channel 对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReflectiveChannelFactory</span><span class="params">(Class&lt;? extends T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        ObjectUtil.checkNotNull(clazz, <span class="string">"clazz"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.constructor = clazz.getConstructor();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过反射方式生成 channel 对象</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">newChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> constructor.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ServerBootstrap 方法调用</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Channel channel = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用 channelFactory 生成 NioServerSocketChannel</span></span><br><span class="line">        channel = channelFactory.newChannel();</span><br><span class="line">        init(channel);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> regFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新建 NioServerSocketChannel 对象实际是使用 ReflectiveChannelFactory 对象来生成。</p>
<h3 id="2-2-初始化-NioServerSocketChannel-对象"><a href="#2-2-初始化-NioServerSocketChannel-对象" class="headerlink" title="2.2 初始化 NioServerSocketChannel 对象"></a>2.2 初始化 NioServerSocketChannel 对象</h3><p>初始化工作主要是设置 NioServerSocketChannel 对象中的 ChannelPipeline，该 ChannelPipeline 对象以责任链模式维护一个 ChannelHandler 链表，用于处理后续的网络连接。在这里主要是加入一个 ChannelInitializer handler 类，它是一个特殊的 ChannelHandler 类，用于完成 ChannelHandler 列表的添加。在这个例子中，它加入了两个 ChannelHandler 类，一个是 LoggingHandler 类，它的功能是打印日志，由 ServerBootstrap.handler 方法加入， 一个是 ServerBootstrapAcceptor 类，它主要用来对新加入的 SocketChannel 进行初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    setChannelOptions(channel, newOptionsArray(), logger);</span><br><span class="line">    setAttributes(channel, attrs0().entrySet().toArray(EMPTY_ATTRIBUTE_ARRAY));</span><br><span class="line"></span><br><span class="line">    ChannelPipeline p = channel.pipeline();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> EventLoopGroup currentChildGroup = childGroup;</span><br><span class="line">    <span class="keyword">final</span> ChannelHandler currentChildHandler = childHandler;</span><br><span class="line">    <span class="keyword">final</span> Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions;</span><br><span class="line">    <span class="keyword">synchronized</span> (childOptions) &#123;</span><br><span class="line">        currentChildOptions = childOptions.entrySet().toArray(EMPTY_OPTION_ARRAY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs = childAttrs.entrySet().toArray(EMPTY_ATTRIBUTE_ARRAY);</span><br><span class="line"></span><br><span class="line">    p.addLast(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">            ChannelHandler handler = config.handler();</span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pipeline.addLast(handler);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> ServerBootstrapAcceptor(</span><br><span class="line">                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ServerBootstrapAcceptor 主要的功能是处理 NioServerSocketChannel 的 OP_ACCEPT，即接收一个新的网络请求（对应一个 SocketChannel 对象），对其设置相关的参数及 ChannelHandler列表，这些配置来来自于 ServerBootstrap 的启动配置参数，最后为该 SocketChannel 分配一个 EventLoop 对象，实现网络连接的负载。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServerBootstrapAcceptor</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Channel child = (Channel) msg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 ChannelHandler</span></span><br><span class="line">    child.pipeline().addLast(childHandler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置参数</span></span><br><span class="line">    setChannelOptions(child, childOptions, logger);</span><br><span class="line">    setAttributes(child, childAttrs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 分配一个 EventLoop</span></span><br><span class="line">        childGroup.register(child).addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">                    forceClose(child, future.cause());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        forceClose(child, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外说明一点，ChannelPipeline 的 addLast 操作需要在 NioServerSocketChannel 对象注册到 EventLoop 中之后再会执行，此时 NioServerSocketChannel 还未注册，所以执行 addLast 方法只是简单向 ChannelPipeline 中添加一个 PendingHandlerAddedTask，等注册操作完成之后再进行调用。</p>
<h3 id="2-3-注册-NioServerSocketChannel-对象"><a href="#2-3-注册-NioServerSocketChannel-对象" class="headerlink" title="2.3 注册 NioServerSocketChannel 对象"></a>2.3 注册 NioServerSocketChannel 对象</h3><p>注册的操作主要包括两个部分：</p>
<ul>
<li>将 NioServerSocketChannel 分配给 EventLoop，该操作是通过 BossGropu 来完成；</li>
<li>将 NioServerSocketChannel 注册到 Selector 对象上，用于接收网络请求。 每一个 NioServerSocketChannel 都包含一个 Java SelectableChannel 对象，网络请求最终都是通过这个对象来完成。</li>
</ul>
<p>register 调用顺序为 AbstractBootstrap.initAndRegister –&gt; MultithreadEventLoopGroup.register –&gt; SingleThreadEventLoop –&gt; AbstractUnsafe.register，注册操作最终是调用 AbstractUnsafe 类来完成的。这里先看下 initAndRegister 方法，register 与 后续的 bind 都是异步操作，而 bind 操作需要 register 操作成功之后再执行，这两个操作的协调就是在这一步完成的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractBootstrap</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Channel channel = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        channel = channelFactory.newChannel();</span><br><span class="line">        init(channel);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、 返回注册操作的 ChannelFuture</span></span><br><span class="line">    ChannelFuture regFuture = config().group().register(channel);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> regFuture;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractBootstrap</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回注册操作的 ChannelFuture</span></span><br><span class="line">    <span class="keyword">final</span> ChannelFuture regFuture = initAndRegister();</span><br><span class="line">    <span class="keyword">final</span> Channel channel = regFuture.channel();</span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> regFuture;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、判断注册操作是否完成，若完成则执行 doBind0 方法；</span></span><br><span class="line">    <span class="keyword">if</span> (regFuture.isDone()) &#123;</span><br><span class="line">       </span><br><span class="line">        ChannelPromise promise = channel.newPromise();</span><br><span class="line">        <span class="comment">// 调用 doBind0 方法</span></span><br><span class="line">        doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 3、若注册操作未完成，则添加一个回调函数，注册完成后执行 doBind0 方法；</span></span><br><span class="line">        <span class="keyword">final</span> PendingRegistrationPromise promise = <span class="keyword">new</span> PendingRegistrationPromise(channel);</span><br><span class="line">        regFuture.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Throwable cause = future.cause();</span><br><span class="line">                <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    promise.setFailure(cause);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    promise.registered();</span><br><span class="line">                    <span class="comment">// 调用 doBind0 方法</span></span><br><span class="line">                    doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码可以看出，register 与 bind 的操作是借助 ChannelFuture 完成的，主要是通过向 regFuture 中添加 ChannelFutureListener 监听器，在 register 完成之后调用 safeSetSuccess(regFuture) 触发调用监听器代码。</p>
<p>注册操作的核心代码在 AbstractUnsafe.register 方法中，再将 将 EventLoop 赋值给 AbstractChannel 对象，会向 EventLoop 提交一个异步任务用来执行 register0 方法，该方法包括了将 AbstractChannel 注册到 Selector 的 I/O 操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1、将 EventLoop 赋值给 AbstractChannel 对象，</span></span><br><span class="line">    <span class="comment">// 一个 EventLoop 对象可以赋值给多个 AbstractChannel 对象 </span></span><br><span class="line">    AbstractChannel.<span class="keyword">this</span>.eventLoop = eventLoop;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、将 AbstractChannel 注册到 Selector 对象是一个 I/O 操作，</span></span><br><span class="line">    <span class="comment">// 需要提交给 eventLoop 执行</span></span><br><span class="line">    <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class="line">        register0(promise);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            eventLoop.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    register0(promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>register0 方法在 EventLoop 线程中执行，它主要包括下面几个步骤：</p>
<ul>
<li>执行操作系统层面的注册操作，主要是调用 java api 来实现；</li>
<li>将 channel 状态设置为注册完成状态；</li>
<li>向 pipeline 添加 ChannelHandler，在这里调用 channel 初始化时添加到 pipeline 中的 PendingHandlerAddedTask；</li>
<li>将 regFuture 设置为成功完成状态，并触发调用 ChannelFutureListener 监听器，最终会调用 bind 操作；</li>
<li>触发 ChannelRegistered 事件，调用 ChannelHandler 中的回调函数。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractUnsafe</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register0</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">boolean</span> firstRegistration = neverRegistered;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1、执行操作系统层面的注册操作，主要是调用 java api 来实现；</span></span><br><span class="line">        doRegister();</span><br><span class="line">        neverRegistered = <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2、设置 channel 的注册状态；</span></span><br><span class="line">        registered = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3、执行 HandlerAdd 操作；</span></span><br><span class="line">        pipeline.invokeHandlerAddedIfNeeded();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、成功设置 channelFuture 完成状态，将触发回调操作； </span></span><br><span class="line">        safeSetSuccess(promise);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5、触发 ChannelRegistered 事件，调用 ChannelHandler 中的回调函数</span></span><br><span class="line">        pipeline.fireChannelRegistered();</span><br><span class="line">       </span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>doRegister 方法调用的是 Java NIO api 完成网络层面的注册操作，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractNioChannel</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> selected = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将 channel 注册到 eventLoop 中的 Selector 对象中，此时未注册感兴趣的 I/O 事件 </span></span><br><span class="line">            selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="number">0</span>, <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!selected) &#123;</span><br><span class="line">                eventLoop().selectNow();</span><br><span class="line">                selected = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>doRegister 方法在 AbstractNioChannel 中实现，在这个方法中，主要是将 ServerSocketChannel 注册到底层的 selector 上，由它来监听 ServerSocketChannel 的 I/O 事件，不过在此时还没有注册感兴趣的 I/O 事件，是由后面的 read 操作来完成。</p>
<h3 id="2-4-执行-bind-操作"><a href="#2-4-执行-bind-操作" class="headerlink" title="2.4 执行 bind 操作"></a>2.4 执行 bind 操作</h3><p>bind 操作主要是完成底层 ServerSocketChannel 对象的地址绑定操作，其调用顺序为：AbstractBootstrap.doBind0 –&gt; AbstractChannel.bind –&gt; DefaultChannelPipeline.bind –&gt; AbstractChannelHandlerContext.bind –&gt; HeadContext.bind –&gt; AbstractUnsafe.bind。最后调用 AbstractUnsafe 中的 bind 方法。</p>
<p>在 bind 方法中，主要做了下面的工作：</p>
<ul>
<li>执行地址绑定操作，具体实现取决于 Channel 的子类；</li>
<li>判断 channel 是否 Active，正常情况，绑定成功之后便会激活 channel；</li>
<li>触发 channelActive 事件，执行后续的 read 操作；</li>
<li>设置成功完成 bind 操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractUnsafe</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">boolean</span> wasActive = isActive();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1、执行地址绑定操作</span></span><br><span class="line">        doBind(localAddress);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        safeSetFailure(promise, t);</span><br><span class="line">        closeIfClosed();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、判断该 channel是否 Active</span></span><br><span class="line">    <span class="comment">// bind 操作之后正常就是 Active 了</span></span><br><span class="line">    <span class="keyword">if</span> (!wasActive &amp;&amp; isActive()) &#123;</span><br><span class="line">        invokeLater(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 3、回调 ChannelActive 事件</span></span><br><span class="line">                pipeline.fireChannelActive();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4、设置成功完成 bind 操作</span></span><br><span class="line">    safeSetSuccess(promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>doBind 方法的实现由 channel 的子类实现，在这里由 NioServerSocketChannel 来实现，如代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NioServerSocketChannel</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBind</span><span class="params">(SocketAddress localAddress)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (PlatformDependent.javaVersion() &gt;= <span class="number">7</span>) &#123;</span><br><span class="line">        javaChannel().bind(localAddress, config.getBacklog());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        javaChannel().socket().bind(localAddress, config.getBacklog());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>doBind 执行完成之后，触发 channelActive 事件，在 channelActive 回调函数中再触发读事件，最后完成 OP_ACCEPT 事件的注册。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HeadContext</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">    ctx.fireChannelActive();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、 执行 read 操作</span></span><br><span class="line">    readIfIsAutoRead();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HeadContext</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readIfIsAutoRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (channel.config().isAutoRead()) &#123;</span><br><span class="line">        channel.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 channelActive 中触发调用 channel.read() 操作。</p>
<h3 id="2-5-执行-read-操作"><a href="#2-5-执行-read-操作" class="headerlink" title="2.5 执行 read 操作"></a>2.5 执行 read 操作</h3><p>在 channelActive 中触发调用 read 的顺序为：AbstractChannel.read –&gt; DefaultChannelPipeline.read –&gt; AbstractChannelHandlerContext.read –&gt; HeadContext.read –&gt; AbstractUnsafe.beginRead，最终调用 AbstractUnsafe.beginRead 方法。</p>
<p>AbstractUnsafe.beginRead 中会调用 channel 的 doBeginRead 方法，该方法也是抽象文件，具体实现取决于子类，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractUnsafe</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">beginRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertEventLoop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isActive()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1、开始读操作，具体实现在子类中定义</span></span><br><span class="line">        doBeginRead();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractNioChannel</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBeginRead</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// Channel.read() or ChannelHandlerContext.read() was called</span></span><br><span class="line">    <span class="keyword">final</span> SelectionKey selectionKey = <span class="keyword">this</span>.selectionKey;</span><br><span class="line">    <span class="keyword">if</span> (!selectionKey.isValid()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    readPending = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> interestOps = selectionKey.interestOps();</span><br><span class="line">    <span class="keyword">if</span> ((interestOps &amp; readInterestOp) == <span class="number">0</span>) &#123;</span><br><span class="line">        selectionKey.interestOps(interestOps | readInterestOp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NioServerSocketChannel</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">(ServerSocketChannel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="keyword">null</span>, channel, SelectionKey.OP_ACCEPT);</span><br><span class="line">    config = <span class="keyword">new</span> NioServerSocketChannelConfig(<span class="keyword">this</span>, javaChannel().socket());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NioServerSocketChannel 类中，selectionKey 为 SelectionKey.OP_ACCEPT，即监听 ServerSocket 的 OP_ACCEPT 事件，注册完该事件之后，NioServerSocketChannel 便可接收网络请求了。</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>ServerBootstrap bind 方法是相对比较复杂的一个方法，它涉及到了 Netty 中各个组件，并将它们有机整合在一起。通过对 bind 方法的分析，对 Netty 的整体流程有了一个初步的理解，这会对使用 Netty 大有裨益。</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/22/netty-reactor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2021/08/22/netty-reactor/" class="post-title-link" itemprop="http://yoursite.com/index.html">Netty 系列：Reactor</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2021-08-22 13:22:53" itemprop="dateCreated datePublished" datetime="2021-08-22T13:22:53+08:00">2021-08-22</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-09-04 11:01:20" itemprop="dateModified" datetime="2021-09-04T11:01:20+08:00">2021-09-04</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Netty/" itemprop="url" rel="index"><span itemprop="name">Netty</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">78k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">1:11</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>Reactor 模式是一种服务器网络编程模式，它根据网络数据接收的特点，将连接的建立、网络数据的读写分离，用 mainReactor 线程处理网络的连接，用 subReactor 处理数据的读写，同时为了有效利用 CPU 多核的优势，subActor 可以有多个。它的整体结构如下图所示：</p>
<p><img src="/images/netty/ractor.jpeg" alt="reactor" title="reactor"></p>
<p><strong>特点：</strong></p>
<ol>
<li>客户端的所有连接请求统一由 mainReactor 线程处理，同时将收到请求转交 subReactor 处理；</li>
<li>subReactor 线程处理连接的读写，为了实现处理的负载，可以有多个 subReactor，通过一定的算法分配网络连接；</li>
<li>考虑到连接的 I/O 读写比较耗时，为了提高吞吐量，读写操作可以交由线程池处理。</li>
</ol>
<p><strong>说明：</strong><br>文中说到的“网络连接”与下文说到的 “channel” 和 “socketChannel” 是一个概念。</p>
<p>另外，这篇文章主要包含三个部分的内容：1）Reactor 概念的介绍；2）Reactor 的模拟；3）Netty 中的实现；现在我们用 Java 模拟一个 Reactor 的实现。</p>
<h2 id="2-原理"><a href="#2-原理" class="headerlink" title="2. 原理"></a>2. 原理</h2><h3 id="2-1-MainReactor"><a href="#2-1-MainReactor" class="headerlink" title="2.1 MainReactor"></a>2.1 MainReactor</h3><p>我们以一个例子来模拟一个 Reactor，先看 MainReactor 类的代码，它主要的功能是监听 9090 端口接收网络连接，并将网络请求注册到 SubReactor 类，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainReactor</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 监听的端口</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">9090</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Selector 对象，用于实现网络 I/O 事件的监听</span></span><br><span class="line">	<span class="keyword">private</span> Selector selector;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 服务器套接字，用于接收网络请求</span></span><br><span class="line">	<span class="keyword">private</span> ServerSocketChannel serverChannel;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用于分配 SocketChannel 到 subReactor</span></span><br><span class="line">	<span class="comment">// SelectorManager 存有多个 subReactor 对象</span></span><br><span class="line">	<span class="keyword">private</span> SelectorManager manager;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 标识线程是关闭</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> isStop;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MainReactor</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		init();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化 MainReactor</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		isStop = <span class="keyword">false</span>;</span><br><span class="line">		selector = Selector.open();</span><br><span class="line">		serverChannel = ServerSocketChannel.open();</span><br><span class="line">		serverChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(PORT));</span><br><span class="line">		serverChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 向 selector 注册 OP_ACCEPT 事件</span></span><br><span class="line">		<span class="comment">// MainReactor 只处理网络连接事件</span></span><br><span class="line">		serverChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">		manager = <span class="keyword">new</span> SelectorManager();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动 MainReactor 线程</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Thread seletorThread = <span class="keyword">new</span> Thread(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">		seletorThread.start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 处理收到的网络连接，将该请求分配给 subReactor</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(SocketChannel channel)</span> </span>&#123;</span><br><span class="line">		manager.register(channel);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		isStop = <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 事件处理循环</span></span><br><span class="line">			<span class="keyword">while</span> (!isStop) &#123;</span><br><span class="line">				selector.select();</span><br><span class="line"></span><br><span class="line">				Set&lt;SelectionKey&gt; set = selector.selectedKeys();</span><br><span class="line">				Iterator&lt;SelectionKey&gt; iterator = set.iterator();</span><br><span class="line"></span><br><span class="line">				<span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">					System.out.println(<span class="string">"accept thread:"</span> + Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">					SelectionKey key = iterator.next();</span><br><span class="line">					iterator.remove();</span><br><span class="line"></span><br><span class="line">					ServerSocketChannel server = (ServerSocketChannel) key.channel();</span><br><span class="line"></span><br><span class="line">					<span class="comment">// 接收新的网络请求</span></span><br><span class="line">					SocketChannel client = server.accept();</span><br><span class="line"></span><br><span class="line">					System.out.println(<span class="string">"receive a connection:"</span> + client.socket().getRemoteSocketAddress());</span><br><span class="line"></span><br><span class="line">					<span class="comment">// 分配网络请求</span></span><br><span class="line">					process(client);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动 MainReactor</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		MainReactor server = <span class="keyword">new</span> MainReactor();</span><br><span class="line">		server.doStart();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MainReactor 有几个主要的属性：</p>
<ol>
<li>Selector：Selector 对象，用于实现网络 I/O 事件的监听，它只监听网络请求事件；</li>
<li>ServerSocketChannel：服务器套接字，用于接收网络请求；</li>
<li>SelectorManager：用于分配 SocketChannel 到 subReactor，SelectorManager 存有多个 subReactor 对象。</li>
</ol>
<h3 id="2-2-SubReactor"><a href="#2-2-SubReactor" class="headerlink" title="2.2 SubReactor"></a>2.2 SubReactor</h3><p>SubReactor 主要是处理 SocketChannel 的读写，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubReactor</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Selector 对象，用于 channel 数据的读写</span></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SocketChannel 列表，一个 SubReactor 可以处理多个 SocketChannel</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;SocketChannel&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标示线程是否结束</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isStop;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 业务线程池，用于处理读写业务</span></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolManager pool;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SubReactor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        isStop = <span class="keyword">false</span>;</span><br><span class="line">        pool = ThreadPoolManager.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SubReactor</span><span class="params">(Selector sel)</span> </span>&#123;</span><br><span class="line">        isStop = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">this</span>.selector = sel;</span><br><span class="line">        queue = <span class="keyword">new</span> LinkedList&lt;SocketChannel&gt;();</span><br><span class="line"></span><br><span class="line">        pool = ThreadPoolManager.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动 subReactor</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(SocketChannel channel)</span> </span>&#123;</span><br><span class="line">        queue.add(channel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        isStop = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 事件处理循环</span></span><br><span class="line">            <span class="keyword">while</span> (!isStop) &#123;</span><br><span class="line">                <span class="comment">// 配置</span></span><br><span class="line">                configuration();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> count = selector.select();</span><br><span class="line">                <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Set&lt;SelectionKey&gt; set = selector.selectedKeys();</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = set.iterator();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"io thread:"</span> + Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">                    SelectionKey key = iterator.next();</span><br><span class="line">                    iterator.remove();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (!key.isValid()) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 判断 channel 是否可读</span></span><br><span class="line">                    <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">" read........"</span>);</span><br><span class="line">                        handleRead(key);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 判断 channel 是否可写</span></span><br><span class="line">                    <span class="keyword">if</span> (key.isValid() &amp;&amp; key.isWritable()) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">" write........"</span>);</span><br><span class="line">                        handleWrite(key);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将读业务提交给线程池处理</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(SelectionKey key)</span> </span>&#123;</span><br><span class="line">        HandlerContainer container = (HandlerContainer) key.attachment();</span><br><span class="line">        IoHandler handler = container.getHandler();</span><br><span class="line">        handler.setKey(key);</span><br><span class="line"></span><br><span class="line">        pool.execute(handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置相关参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">configuration</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            SocketChannel channel = queue.get(i);</span><br><span class="line">            channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 配置监听 channel 可读事件，channel 可写事件不用监听（可写事件会导致事件处理循环空转）</span></span><br><span class="line">            SelectionKey key = channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line">            IoHandler handler = <span class="keyword">new</span> IoHandler();</span><br><span class="line">            HandlerContainer container = <span class="keyword">new</span> HandlerContainer(handler);</span><br><span class="line"></span><br><span class="line">            key.attach(container);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理读请求</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRead</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SocketChannel clntChan = (SocketChannel) key.channel();</span><br><span class="line"></span><br><span class="line">        ByteBuffer input = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        HandlerContainer container = (HandlerContainer) key.attachment();</span><br><span class="line">        ByteBuffer buf = container.getBuf();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> bytesRead = clntChan.read(input);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bytesRead == -<span class="number">1</span>) &#123;</span><br><span class="line">            clntChan.close();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"connection closed!"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        input.flip();</span><br><span class="line">        <span class="keyword">while</span> (input.hasRemaining()) &#123;</span><br><span class="line">            <span class="keyword">byte</span> b = input.get();</span><br><span class="line">            buf.put(b);</span><br><span class="line">            <span class="keyword">if</span> (b == <span class="string">'\n'</span>) &#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"meet a new line!"</span>);</span><br><span class="line">                buf.flip();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">byte</span>[] msg = <span class="keyword">new</span> <span class="keyword">byte</span>[buf.limit()];</span><br><span class="line">                buf.get(msg);</span><br><span class="line"></span><br><span class="line">                buf.flip();</span><br><span class="line"></span><br><span class="line">                String message = <span class="keyword">new</span> String(msg);</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"receive message:"</span> + message);</span><br><span class="line"></span><br><span class="line">                process(key);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理写请求</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleWrite</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        HandlerContainer container = (HandlerContainer) key.attachment();</span><br><span class="line">        IoHandler handler = container.getHandler();</span><br><span class="line"></span><br><span class="line">        handler.handleWrite(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SubReactor 的功能主要是负载监听 SocketChannel 的读写事件，然后分发给线程池去处理。</p>
<h3 id="2-3-Channel-的分配"><a href="#2-3-Channel-的分配" class="headerlink" title="2.3 Channel 的分配"></a>2.3 Channel 的分配</h3><p>MainReactor 接收到新的连接，会产生一个 SocketChannel 对象，按照一定的算法分配给 SubReactor。这个分配主要由 SelectorManager 对象完成，我们分析下其代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectorManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Selector 数组，一个 SubReactor 对应一个 selector</span></span><br><span class="line">    <span class="keyword">private</span> Selector[] selector;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SubReactor 数组，数组大小等于 cpu 数</span></span><br><span class="line">    <span class="keyword">private</span> SubReactor[] subReactors;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配的 SubReactor 下标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SubReactor 数组的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 SelectorManager 对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SelectorManager</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// SubReactor 数组大小等于 cpu 数</span></span><br><span class="line">        length = Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line">        selector = <span class="keyword">new</span> Selector[length];</span><br><span class="line">        subReactors = <span class="keyword">new</span> SubReactor[length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            selector[i] = Selector.open();</span><br><span class="line">            subReactors[i] = <span class="keyword">new</span> SubReactor(selector[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        next = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            subReactors[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配 channel,使用是轮洵算法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(SocketChannel channel)</span> </span>&#123;</span><br><span class="line">        subReactors[next].register(channel);</span><br><span class="line">        selector[next].wakeup();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"chose subRactor:"</span> + next);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (++next == length) &#123;</span><br><span class="line">            next = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，SelectorManager 的功能主要包括两个方面：1）创建及初始化 SubReactor 数组；2）根据轮洵算法分配 Channel。</p>
<h2 id="3-实现"><a href="#3-实现" class="headerlink" title="3. 实现"></a>3. 实现</h2><p>Netty 实现了 Reactor 模式，其整体结构如下所示：<br><img src="/images/netty/netty-reactor-v2.jpg" alt="netty-reactor" title="netty-reactor"></p>
<p>在 Netty 服务启动的时候会配置两个 EventLoopGroup bossGroup 和 WrokerGroup，EventLoopGroup 可以包含一个或多处 EventLoop，每一个 EventLoop 包含一个 Selector (也可能是 epoll，取决于实现)对象，同时它是一个独立的线程，可独立负载 I/O 请求。对比 Reactor，bossGroup 相当于 MainReactor，这负责监听网络的连接请求（生成 SocketChannle对象），并将其分配给 workerGroup，在这里，只包含一个 EventLoop；workerGroup 相当于 subReactor，监听连接的读写请求。下面分析下 Netty 中关于 EventLoopGroup 的代码实现。</p>
<h3 id="3-1-初始化"><a href="#3-1-初始化" class="headerlink" title="3.1 初始化"></a>3.1 初始化</h3><p><strong>1、线程数设置</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置 EventLoop</span></span><br><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"><span class="keyword">final</span> EchoServerHandler serverHandler = <span class="keyword">new</span> EchoServerHandler();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">    b.group(bossGroup, workerGroup)</span><br><span class="line">     .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">     .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">SO_BACKLOG</span>, 100)</span></span><br><span class="line"><span class="class">     .<span class="title">handler</span>(<span class="title">new</span> <span class="title">LoggingHandler</span>(<span class="title">LogLevel</span>.<span class="title">INFO</span>))</span></span><br><span class="line"><span class="class">     .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">             ChannelPipeline p = ch.pipeline();</span><br><span class="line">             <span class="keyword">if</span> (sslCtx != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 p.addLast(sslCtx.newHandler(ch.alloc()));</span><br><span class="line">             &#125;</span><br><span class="line">             </span><br><span class="line">             p.addLast(serverHandler);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定端口并等待完成</span></span><br><span class="line">    ChannelFuture f = b.bind(PORT).sync();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待 channel 关闭</span></span><br><span class="line">    f.channel().closeFuture().sync();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    </span><br><span class="line">    bossGroup.shutdownGracefully();</span><br><span class="line">    workerGroup.shutdownGracefully();</span><br><span class="line">&#125;</span><br><span class="line">b.group(bossGroup, workerGroup);</span><br></pre></td></tr></table></figure>
<p>在这里使用的是 NioEventLoopGroup，bossGroup 设置的线程数为 1，而 workerGroup 没有设置线程数，使用默认配置的数量：2 * cpu size。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor, Object... args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 线程数为 0 ，则设置为 DEFAULT_EVENT_LOOP_THREADS</span></span><br><span class="line">    <span class="keyword">super</span>(nThreads == <span class="number">0</span> ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DEFAULT_EVENT_LOOP_THREADS 设置为 io.netty.eventLoopThreads 变量的值，</span></span><br><span class="line"><span class="comment">// 如果没有设置则为 2 * cpu size</span></span><br><span class="line">DEFAULT_EVENT_LOOP_THREADS = Math.max(<span class="number">1</span>, SystemPropertyUtil.getInt(</span><br><span class="line">    <span class="string">"io.netty.eventLoopThreads"</span>, NettyRuntime.availableProcessors() * <span class="number">2</span>));</span><br></pre></td></tr></table></figure>
<p><strong>2、创建 EventLoop 数组</strong></p>
<p>NioEventLoopGroup 是 EventLoop 对象的容器集合，持有多个 EventLoop 对象，它的数量与线程数量一致，同时 NioEventLoopGroup 负责分配 SocketChannel，需要有一个分配的策略对象，这些是在其父类的构造函数中实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventExecutorGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        EventExecutorChooserFactory chooserFactory, Object... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nThreads &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">"nThreads: %d (expected: &gt; 0)"</span>, nThreads));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、定义 EventLoop 中的线程执行器</span></span><br><span class="line">    <span class="keyword">if</span> (executor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        executor = <span class="keyword">new</span> ThreadPerTaskExecutor(newDefaultThreadFactory());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2、初始化 EventLoop 数量</span></span><br><span class="line">    children = <span class="keyword">new</span> EventExecutor[nThreads];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nThreads; i ++) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 3、生成 EventLoop 实例对象</span></span><br><span class="line">            children[i] = newChild(executor, args);</span><br><span class="line">            success = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"failed to create a child event loop"</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4、定义 channel 的分配策略</span></span><br><span class="line">    chooser = chooserFactory.newChooser(children);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 MultithreadEventExecutorGroup 构造函数中，主要做了三个工作：</p>
<ul>
<li>定义 EventLoop 中的线程执行器，每一个 EventLoop 都包含一个线程，其线程由 ThreadPerTaskExecutor 生成；</li>
<li>初始化及生成 EventLoop 数组 ，newChild 方法由子类来实现，不同的模式有不同的实现；</li>
<li>定义 channel 的分配策略，根据 EventLoop 的数量有不同的实现。</li>
</ul>
<p>在 NioEventLoopGroup 中，newChild 实现代码所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> EventLoop <span class="title">newChild</span><span class="params">(Executor executor, Object... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    EventLoopTaskQueueFactory queueFactory = args.length == <span class="number">4</span> ? (EventLoopTaskQueueFactory) args[<span class="number">3</span>] : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> NioEventLoop(<span class="keyword">this</span>, executor, (SelectorProvider) args[<span class="number">0</span>],</span><br><span class="line">        ((SelectStrategyFactory) args[<span class="number">1</span>]).newSelectStrategy(), (RejectedExecutionHandler) args[<span class="number">2</span>], queueFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>newChild 方法的细节在后面的文章中再进行介绍。</p>
<p><strong>3、Channel 分配策略</strong></p>
<p>channel 的分配策略有两种，分别是：PowerOfTwoEventExecutorChooser 和 GenericEventExecutorChooser，它们本质上都是轮洵算法，只是当 EventLoop 的数量是 2 的幂次方时，对算法做了优化，使用位操作代替取余操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> EventExecutorChooser <span class="title">newChooser</span><span class="params">(EventExecutor[] executors)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isPowerOfTwo(executors.length)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PowerOfTwoEventExecutorChooser(executors);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> GenericEventExecutorChooser(executors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PowerOfTwoEventExecutorChooser</span> <span class="keyword">implements</span> <span class="title">EventExecutorChooser</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger idx = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventExecutor[] executors;</span><br><span class="line"></span><br><span class="line">    PowerOfTwoEventExecutorChooser(EventExecutor[] executors) &#123;</span><br><span class="line">        <span class="keyword">this</span>.executors = executors;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用位操作</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EventExecutor <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> executors[idx.getAndIncrement() &amp; executors.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericEventExecutorChooser</span> <span class="keyword">implements</span> <span class="title">EventExecutorChooser</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong idx = <span class="keyword">new</span> AtomicLong();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventExecutor[] executors;</span><br><span class="line"></span><br><span class="line">    GenericEventExecutorChooser(EventExecutor[] executors) &#123;</span><br><span class="line">        <span class="keyword">this</span>.executors = executors;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用取余操作</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EventExecutor <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> executors[(<span class="keyword">int</span>) Math.abs(idx.getAndIncrement() % executors.length)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-2-Channel-注册"><a href="#3-2-Channel-注册" class="headerlink" title="3.2 Channel 注册"></a>3.2 Channel 注册</h3><p>在 Nio 模式下，Channel 有两种类型，分别是：NioServerSocketChannel 和 NioSocketChannel，其中 NioServerSocketChannel 用于监听网络连接请求，生成 NioSocketChannel 连接，该 Channle 注册到 BossGroup 的 EventLoop 中，而 NioSocketChannel 负责真正的网络读写，注册到 WorkerGroup 的 EventLoop 中。</p>
<p><strong>1、NioServerSocketChannel 注册</strong></p>
<p><img src="/images/netty/netty-bind-v2.jpg" alt="netty-bind" title="netty-bind"></p>
<p>在 Netty 的服务器启动过程中，主要的流程是一个 bind 操作，其流程包括：</p>
<ul>
<li>创建 NioServerSocketChannel 类，完成初始化的工作，其中包括添加 ChannelHandler 类；</li>
<li>将 NioServerSocketChannel 注册到 EventLoop 中，同时向 Selector 对象中注册，不过此时并没有注册 OP_ACCEPT 事件；</li>
<li>执行网络层的 bind 操作；</li>
<li>执行读操作，主要是向 Selector 注册 OP_ACCEPT 事件。执行该操作后，便可接收网线的连接请求了。</li>
</ul>
<p>NioServerSocketChannel 注册穿插在上面的 4 个步骤中，主要包括 1）将 NioServerSocketChannel 注册到 EventLoop 中；2）向 Selector 对象注册 OP_ACCEPT 事件。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractUnsafe 对象中的 register 操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、将 eventLoop 赋值给 AbstractChannel对象</span></span><br><span class="line">    AbstractChannel.<span class="keyword">this</span>.eventLoop = eventLoop;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class="line">        register0(promise);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            eventLoop.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// 2、向 Selector 对象注册 Channel</span></span><br><span class="line">                    register0(promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">           ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractNioChannel, 向 Selector 对象 注册 channel</span></span><br><span class="line"><span class="comment">// 此时没有注册 OP_ACCEPT 事件</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> selected = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.selectionKey = <span class="keyword">this</span>.javaChannel().register(<span class="keyword">this</span>.eventLoop().selector, <span class="number">0</span>, <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CancelledKeyException var3) &#123;</span><br><span class="line">            <span class="keyword">if</span> (selected) &#123;</span><br><span class="line">                <span class="keyword">throw</span> var3;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.eventLoop().selectNow();</span><br><span class="line">            selected = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractNioChannel，注册 OP_ACCEPT 事件</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBeginRead</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// Channel.read() or ChannelHandlerContext.read() was called</span></span><br><span class="line">    <span class="keyword">final</span> SelectionKey selectionKey = <span class="keyword">this</span>.selectionKey;</span><br><span class="line">    <span class="keyword">if</span> (!selectionKey.isValid()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    readPending = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> interestOps = selectionKey.interestOps();</span><br><span class="line">    <span class="keyword">if</span> ((interestOps &amp; readInterestOp) == <span class="number">0</span>) &#123;</span><br><span class="line">        selectionKey.interestOps(interestOps | readInterestOp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码可以看到 registor 操作主要是分配一个 EventLoop，并将 EventLoop 赋值给 NioServerSocketChannel。向 Selector 注册 Channel 则分为两次，第一次注册时事件参数为 0，等于没有注册任何事件；第二次是在底层 Channel bind 操作之后，准备就绪之后，再注册 OP_ACCEPT 事件。</p>
<p><strong>2、NioSocketChannel 注册</strong><br>在 bind 操作的流程中，第一步是创建 NioServerSocketChannel 类，并进行初始化，此时会注册 ChannelHandler 类，其中就有一个 ServerBootstrapAcceptor handler 类，它的主要功能就是收到网络请求之后对NioSocketChannel 类进行参数配置，将其注册到 workerGroup 中，其核心代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Channel child = (Channel) msg;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 1、添加 channelHandler 类</span></span><br><span class="line">    child.pipeline().addLast(childHandler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、设置 channel 的对数</span></span><br><span class="line">    setChannelOptions(child, childOptions, logger);</span><br><span class="line">    setAttributes(child, childAttrs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 3、向 wokerGroup 注册 Channel</span></span><br><span class="line">        childGroup.register(child).addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">                    forceClose(child, future.cause());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        forceClose(child, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NioSocketChannel 和 NioServerSocketChannel 注册流程是一致的，差别只是注册到不同的 EventLoopGroup 及注册不同的 I/O 事件，其中  NioSocketChannel 注册的是 OP_READ 事件，而 NioServerSocketChannel 注册的是 OP_ACCEPT 事件。</p>
<h3 id="3-3-事件循环"><a href="#3-3-事件循环" class="headerlink" title="3.3 事件循环"></a>3.3 事件循环</h3><p>EventLoop 本质是一个事件循环，不断地从 Selector (Epoll) 对象中获取 I/O 事件，执行解码/反序列化操作后，再分发到上层的业务线程进行处理。另外一方面它可以执行用户自定义任务，如定时进行 Channel 空闲状态的检测，其核心代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> selectCnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> strategy;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">				</span><br><span class="line">                <span class="comment">// 1、计算执行策略</span></span><br><span class="line">                strategy = selectStrategy.calculateStrategy(selectNowSupplier, hasTasks());</span><br><span class="line">                <span class="keyword">switch</span> (strategy) &#123;</span><br><span class="line">                <span class="keyword">case</span> SelectStrategy.CONTINUE:</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                ...</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            selectCnt++;</span><br><span class="line">            cancelledKeys = <span class="number">0</span>;</span><br><span class="line">            needsToSelectAgain = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> ioRatio = <span class="keyword">this</span>.ioRatio;</span><br><span class="line">            <span class="keyword">boolean</span> ranTasks;</span><br><span class="line">            <span class="keyword">if</span> (ioRatio == <span class="number">100</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (strategy &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 2、执行 I/O 事件</span></span><br><span class="line">                        processSelectedKeys();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 3、执行自定义任务</span></span><br><span class="line">                    ranTasks = runAllTasks();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strategy &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> ioStartTime = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 2、执行 I/O 事件</span></span><br><span class="line">                    processSelectedKeys();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">long</span> ioTime = System.nanoTime() - ioStartTime;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 3、执行自定义任务</span></span><br><span class="line">                    ranTasks = runAllTasks(ioTime * (<span class="number">100</span> - ioRatio) / ioRatio);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ranTasks = runAllTasks(<span class="number">0</span>); <span class="comment">// This will run the minimum number of tasks</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">           ...</span><br><span class="line">		   </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            handleLoopException(t);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           ... </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码可以看到，根据计算的执行策略，可以为 I/O 事件处理及自定义任务分配不同的执行时间，详尽的代码在后面的文章介绍。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKey</span><span class="params">(SelectionKey k, AbstractNioChannel ch)</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> readyOps = k.readyOps();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、处理 OP_CONNECT 事件</span></span><br><span class="line">        <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_CONNECT) != <span class="number">0</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> ops = k.interestOps();</span><br><span class="line">            ops &amp;= ~SelectionKey.OP_CONNECT;</span><br><span class="line">            k.interestOps(ops);</span><br><span class="line"></span><br><span class="line">            unsafe.finishConnect();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、处理 OP_WRITE 事件</span></span><br><span class="line">        <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_WRITE) != <span class="number">0</span>) &#123;</span><br><span class="line">            ch.unsafe().forceFlush();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、处理 OP_READ 或 OP_ACCEPT 事件</span></span><br><span class="line">        <span class="keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="number">0</span> || readyOps == <span class="number">0</span>) &#123;</span><br><span class="line">            unsafe.read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CancelledKeyException ignored) &#123;</span><br><span class="line">        unsafe.close(unsafe.voidPromise());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>I/O 事件的处理本质是处理 channel 的各种 I/O 事件，其中将 OP_ACCEPT 抽象为 Netty的 read 事件，可以理解为读取的数据是 NioSocketChannel 对象，其代码如下所示：</p>
<pre><code class="java"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doReadMessages</span><span class="params">(List&lt;Object&gt; buf)</span> <span class="keyword">throws</span> Exception </span>{
    SocketChannel ch = <span class="keyword">this</span>.javaChannel().accept();

    <span class="keyword">try</span> {
        <span class="keyword">if</span> (ch != <span class="keyword">null</span>) {
            buf.add(<span class="keyword">new</span> NioSocketChannel(<span class="keyword">this</span>, ch));
            <span class="keyword">return</span> <span class="number">1</span>;
        }
    } <span class="keyword">catch</span> (Throwable var6) {
        logger.warn(<span class="string">"Failed to create a new channel from an accepted socket."</span>, var6);

        <span class="keyword">try</span> {
            ch.close();
        } <span class="keyword">catch</span> (Throwable var5) {
            logger.warn(<span class="string">"Failed to close a socket."</span>, var5);
        }
    }

    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>
<p>可以看出来，NioServerSocketChannel 收到 OP_ACCEPT 事件后，会生成 SocketChannel 对象，然后通过 ServerBootstrapAcceptor handle 类处理后，注册到 workerGroup 中，再监听 SocketChannel 对象的 OP_READ 事件，最终实现网络数据的读写。</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>通过对 Netty 中 Reactor 模型的分析，对 Netty 的线程模型及 I/O 的事件处理有了一个初步的认识，后续的文章将对涉及到的模块进行详尽的分析，希望能够深入理解 Netty 的设计思路。</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/18/netty-channelfuture/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2021/08/18/netty-channelfuture/" class="post-title-link" itemprop="http://yoursite.com/index.html">Netty 系列：ChannelFuture</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2021-08-18 14:33:15" itemprop="dateCreated datePublished" datetime="2021-08-18T14:33:15+08:00">2021-08-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-08-21 23:12:07" itemprop="dateModified" datetime="2021-08-21T23:12:07+08:00">2021-08-21</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Netty/" itemprop="url" rel="index"><span itemprop="name">Netty</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">43k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">39 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>Netty 中所有的的 I/O 操作都是异步的。I/O 操作是比较耗时的，为了不阻塞调用线程，Netty 提供了 ChannelFuture 接口，使用 addListener()方法注册一个 ChannelFutureListener 监听器，可以在 I/O 操作结束之后进行通知返回结果。在下面的代码中，bind 操作返回一个 ChannelFuture 对象，可以继续执行后续操作，也可以调用 sync() 方法同步等待执行结果，给程序开发带来了更多的开发模式，结合不同的业务场景，可以方便选择异步还是同步模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Configure the server.</span></span><br><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"><span class="keyword">final</span> EchoServerHandler serverHandler = <span class="keyword">new</span> EchoServerHandler();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">    b.group(bossGroup, workerGroup)</span><br><span class="line">     .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">     .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">SO_BACKLOG</span>, 100)</span></span><br><span class="line"><span class="class">     .<span class="title">handler</span>(<span class="title">new</span> <span class="title">LoggingHandler</span>(<span class="title">LogLevel</span>.<span class="title">INFO</span>))</span></span><br><span class="line"><span class="class">     .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">             ChannelPipeline p = ch.pipeline();</span><br><span class="line">             <span class="keyword">if</span> (sslCtx != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 p.addLast(sslCtx.newHandler(ch.alloc()));</span><br><span class="line">             &#125;</span><br><span class="line">             </span><br><span class="line">             p.addLast(serverHandler);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定端口并等待完成</span></span><br><span class="line">    ChannelFuture f = b.bind(PORT).sync();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待 channel 关闭</span></span><br><span class="line">    f.channel().closeFuture().sync();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    </span><br><span class="line">    bossGroup.shutdownGracefully();</span><br><span class="line">    workerGroup.shutdownGracefully();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这篇文章的主要目的是分析 ChannelFuture 在 Netty 中的实现原理。</p>
<h2 id="2-原理"><a href="#2-原理" class="headerlink" title="2. 原理"></a>2. 原理</h2><p>ChannelFutrue 本质上是线程间交换数据的方式，一个线程等待另外一个线程的处理结果，取得结果一般有两种方式：1）同步等待，如同 get() 方法；2）注册回调，在设置结果的同时调用回调函数。其伪代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelFutrue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于同步操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于保存回调函数</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;GenericFutureListener&gt; listeners = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存返回结果</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Object result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置结果并调用回调</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSuccess</span><span class="params">(Object result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.result = result;</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用回调函数</span></span><br><span class="line">        listeners.stream().forEach(listener -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                listener.operationComplete(result);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加回调</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addListener</span><span class="params">(GenericFutureListener listener)</span> </span>&#123;</span><br><span class="line">        listeners.add(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步获取结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">bind</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GenericFutureListener</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(Object result)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过持有 ChannelFutrue 类，调用方可以同步或异步获取执行的结果，在这个例子中，为了简化操作，我们使用 CountDownLatch 进行同步，而在 ChannelFutrue 使用 synchronized + notify/await 来实现线程的同步。</p>
<h2 id="3-Netty-实现"><a href="#3-Netty-实现" class="headerlink" title="3. Netty 实现"></a>3. Netty 实现</h2><p>我们以 ServerBootstrap 中的 bind 方法为例，分析 ChannelFuture 在这个流程中的使用方式，bind 方法的主要流程如下所示（其中的实现细节在后续篇章介绍）：</p>
<p><img src="/images/netty/ChannelFuture-flow.jpg" alt="ChannelFuture-flow" title="ChannelFuture-flow"></p>
<p>在 bind 方法中主要包含在 4 个步骤：</p>
<ol>
<li>生成 NioServerSocketChannel 对象；</li>
<li>将 NioServerSocketChannel 对象注册到 EventLoop 中；</li>
<li>执行 bind 操作；</li>
<li>同步等待 bind 操作执行完成。</li>
</ol>
<h3 id="3-1-register-流程"><a href="#3-1-register-流程" class="headerlink" title="3.1 register 流程"></a>3.1 register 流程</h3><p>可以看到第 2 和 3 步都是一个 I/O 操作，为了避免调用线程被阻塞，它们都被提交到 EventLoop 线程（每一个 EventLoop 对象都会绑定一个线程）中执行，并返回一个 ChannelFuture 对象，一个 I/O 操作会对应一个ChannelFuture 对象，调用线程与 EventLoop 通过该对象完成执行结果的交换。下面以 register 方法为例，分析下 ChannelFuture 对象的使用。</p>
<p><strong>1、生成 ChannelFuture 对象</strong></p>
<p>调用 register 之后返回一个 DefaultChannelPromise 对象，该对象是 ChannelFuture 的子类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SingleThreadEventLoop</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> register(<span class="keyword">new</span> DefaultChannelPromise(channel, <span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(<span class="keyword">final</span> Channel channel, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    ObjectUtil.checkNotNull(promise, <span class="string">"promise"</span>);</span><br><span class="line">    ObjectUtil.checkNotNull(channel, <span class="string">"channel"</span>);</span><br><span class="line">    channel.unsafe().register(<span class="keyword">this</span>, promise);</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2、提交异步注册任务</strong></p>
<p>提交注册任务的逻辑在 AbstractChannel.AbstractUnsafe 中，提交的时候会判断当前线程，如果当前线程是 eventLoop 线程，直接执行即可，如果不是，则提交一个任务到 eventLoop 线程 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractChannel.AbstractUnsafe</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    ObjectUtil.checkNotNull(eventLoop, <span class="string">"eventLoop"</span>);</span><br><span class="line">    <span class="keyword">if</span> (isRegistered()) &#123;</span><br><span class="line">        promise.setFailure(<span class="keyword">new</span> IllegalStateException(<span class="string">"registered to an event loop already"</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isCompatible(eventLoop)) &#123;</span><br><span class="line">        promise.setFailure(</span><br><span class="line">                <span class="keyword">new</span> IllegalStateException(<span class="string">"incompatible event loop type: "</span> + eventLoop.getClass().getName()));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AbstractChannel.<span class="keyword">this</span>.eventLoop = eventLoop;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前线程是 eventLoop 线程，直接执行即可；</span></span><br><span class="line">    <span class="comment">// 如果不是，则提交一个任务到 eventLoop 线程 中。</span></span><br><span class="line">    <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class="line">        register0(promise);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            eventLoop.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    register0(promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            logger.warn(</span><br><span class="line">                    <span class="string">"Force-closing a channel whose registration task was not accepted by an event loop: &#123;&#125;"</span>,</span><br><span class="line">                    AbstractChannel.<span class="keyword">this</span>, t);</span><br><span class="line">            closeForcibly();</span><br><span class="line">            closeFuture.setClosed();</span><br><span class="line">            safeSetFailure(promise, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3、执行注册逻辑</strong></p>
<p>register0 是在 EventLoop 线程中执行的，与调用注册方法的线程不是同一个。注册的逻辑通过子类的 doRegister() 方法实现，注册完成之后通过 safeSetSuccess(promise) 和 safeSetFailure(promise, t) 通知注册结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractChannel.AbstractUnsafe</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register0</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> firstRegistration = neverRegistered;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 真正的注册逻辑，由子类实现</span></span><br><span class="line">        doRegister();</span><br><span class="line">        neverRegistered = <span class="keyword">false</span>;</span><br><span class="line">        registered = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        pipeline.invokeHandlerAddedIfNeeded();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行成功之后调用 promise 对象通知注册完成</span></span><br><span class="line">        safeSetSuccess(promise);</span><br><span class="line">        pipeline.fireChannelRegistered();</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span> (isActive()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line">                pipeline.fireChannelActive();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config().isAutoRead()) &#123;</span><br><span class="line">               </span><br><span class="line">                beginRead();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        </span><br><span class="line">        closeForcibly();</span><br><span class="line">        closeFuture.setClosed();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 失败之后调用 promise 对象通知注册失败</span></span><br><span class="line">        safeSetFailure(promise, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4、结果通知</strong></p>
<p>结果通知主要包含两个操作：</p>
<ol>
<li>设置处理结果，唤醒所有等待的线程；</li>
<li>调用注册到 ChannelFuture 中的监听器；</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractChannel.AbstractUnsafe</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">safeSetSuccess</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(promise <span class="keyword">instanceof</span> VoidChannelPromise) &amp;&amp; !promise.trySuccess()) &#123;</span><br><span class="line">        logger.warn(<span class="string">"Failed to mark a promise as success because it is done already: &#123;&#125;"</span>, promise);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终调到 DefaultPromis 类的 setValue0 方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">setValue0</span><span class="params">(Object objResult)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (RESULT_UPDATER.compareAndSet(<span class="keyword">this</span>, <span class="keyword">null</span>, objResult) ||</span><br><span class="line">        RESULT_UPDATER.compareAndSet(<span class="keyword">this</span>, UNCANCELLABLE, objResult)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (checkNotifyWaiters()) &#123;</span><br><span class="line">            notifyListeners();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果有线程等待，唤醒所有等待的线程</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">checkNotifyWaiters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (waiters &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> listeners != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用监听器</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyListeners</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EventExecutor executor = executor();</span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        <span class="keyword">final</span> InternalThreadLocalMap threadLocals = InternalThreadLocalMap.get();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> stackDepth = threadLocals.futureListenerStackDepth();</span><br><span class="line">        <span class="keyword">if</span> (stackDepth &lt; MAX_LISTENER_STACK_DEPTH) &#123;</span><br><span class="line">            threadLocals.setFutureListenerStackDepth(stackDepth + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                notifyListenersNow();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                threadLocals.setFutureListenerStackDepth(stackDepth);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    safeExecute(executor, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            notifyListenersNow();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">notifyListener0</span><span class="params">(Future future, GenericFutureListener l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        l.operationComplete(future);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(<span class="string">"An exception was thrown by "</span> + l.getClass().getName() + <span class="string">".operationComplete()"</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-异步操作的协同"><a href="#3-2-异步操作的协同" class="headerlink" title="3.2 异步操作的协同"></a>3.2 异步操作的协同</h3><p>在上面的操作中，bind 操作依赖 register 操作的结果，由于这两个操作都是异步操作，如何进行协同？即在 register 操作成功执行 bind 操作。正常情况下，有两种办法：1）同步等待操作执行完成；2）通过添加 GenericFutureListener 监听器，执行完由 EventLoop 线程进行回调。在这里是通过第二种方式来操作的。<br>在执行 initAndRegister 操作之后，会得到一个 ChannelFuture regFuture 对象，此时 register 已经提交给 EventLoop 执行，不一定执行完成，需要判断执行结果，如果未完成，则向 regFuture 对象中添加监听器，在监听器中调用 bind 操作，而监听器会中注册完成之后调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractBootstrap</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 执行初始化及注册操作</span></span><br><span class="line">        <span class="keyword">final</span> ChannelFuture regFuture = initAndRegister();</span><br><span class="line">        <span class="keyword">final</span> Channel channel = regFuture.channel();</span><br><span class="line">        <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> regFuture;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果注册操作完成，则执行 bind 操作。</span></span><br><span class="line">        <span class="keyword">if</span> (regFuture.isDone()) &#123;</span><br><span class="line">            </span><br><span class="line">            ChannelPromise promise = channel.newPromise();</span><br><span class="line">            doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">            <span class="keyword">return</span> promise;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           </span><br><span class="line">            <span class="comment">// 如果注册操作示完成，则向 regFuture 中添加监听器，在监听器中调用 bind 操作</span></span><br><span class="line">            <span class="keyword">final</span> PendingRegistrationPromise promise = <span class="keyword">new</span> PendingRegistrationPromise(channel);</span><br><span class="line">            regFuture.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    Throwable cause = future.cause();</span><br><span class="line">                    <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        promise.setFailure(cause);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        promise.registered();</span><br><span class="line"></span><br><span class="line">                        doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> promise;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 bind 任务到 EventLoop 任务中</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doBind0</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> ChannelFuture regFuture, <span class="keyword">final</span> Channel channel,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    channel.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (regFuture.isSuccess()) &#123;</span><br><span class="line">                channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                promise.setFailure(regFuture.cause());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-sync-同步操作"><a href="#3-3-sync-同步操作" class="headerlink" title="3.3 sync 同步操作"></a>3.3 sync 同步操作</h3><p>由于 bind 操作是一个异步操作，此时在调用线程中需要等待绑定的结果，所以调用了 sync 方法。另外，在程序的最后，也使用了一个 ChannelFuture，用于等待 Channel 关闭事件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 绑定端口并等待完成</span></span><br><span class="line">ChannelFuture f = b.bind(PORT).sync();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待 channel 关闭</span></span><br><span class="line">f.channel().closeFuture().sync();</span><br></pre></td></tr></table></figure>
<h3 id="3-3-ChannelFuture-线程同步"><a href="#3-3-ChannelFuture-线程同步" class="headerlink" title="3.3 ChannelFuture 线程同步"></a>3.3 ChannelFuture 线程同步</h3><p>ChannelFuture 中的线程同步方式是 synchronized 同步块，如下代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 等待操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Promise&lt;V&gt; <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isDone()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException(toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    checkDeadLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!isDone()) &#123;</span><br><span class="line">            incWaiters();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                decWaiters();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒操作</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">checkNotifyWaiters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (waiters &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> listeners != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在调用 await 操作时，如果没有结果（操作未完成），则会调用 wait 方法阻塞该线程，同时增加等待的线程数；操作完成之后会调用 notifyAll 方法，通知所有等待的线程继续执行，这样完成了调用结果在不同线程间的交互。</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>ChannelFuture 本质是线程间通信的一种工具，通过 ChannelFuture，可以实现 I/O 的异步操作，并完成操作结果的通知功能。</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Noahsark</p>
              <p class="site-description motion-element" itemprop="description">不畏将来，不念过往</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">44</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">19</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">153</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Noahsark</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数">184k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
    <span title="站点阅读时长">2:47</span>
  
</div>

<div class="BbeiAn-info">
    <a target="_blank" href="https://beian.miit.gov.cn/" rel="nofollow">粤ICP备 2021097726号-1 </a>
	<a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44030702004132" style="text-decoration:none;padding-left:30px;background:url(https://s1.ax1x.com/2018/09/29/ilmwIH.png) no-repeat left center" rel="nofollow">粤公网安备 44030702004132号</a>
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v6.5.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.5.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.5.0"></script>



  



  










  





  

  

  

  

  

  
  

  

  

  

  

  

  

</body>
</html>
