<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.5.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.5.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.5.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.5.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="不畏将来，不念过往">
<meta name="keywords" content="Java">
<meta property="og:type" content="website">
<meta property="og:title" content="以太格">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="以太格">
<meta property="og:description" content="不畏将来，不念过往">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="以太格">
<meta name="twitter:description" content="不畏将来，不念过往">






  <link rel="canonical" href="http://yoursite.com/page/3/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>以太格</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">以太格</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-commonweal">

    
    
    
      
    

    

    <a href="/404/" rel="section"><i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>公益 404</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于我</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/08/java-stream-pipeline/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/12/08/java-stream-pipeline/" class="post-title-link" itemprop="http://yoursite.com/page/3/index.html">Java Stream Pipeline</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-12-08 20:13:30" itemprop="dateCreated datePublished" datetime="2019-12-08T20:13:30+08:00">2019-12-08</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-07-31 17:17:10" itemprop="dateModified" datetime="2021-07-31T17:17:10+08:00">2021-07-31</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java基础/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><blockquote>
<p>Java 8中的Stream是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作（Aggregate operation），或者大批量数据操作(Bulk data operation)。Stream API借助于同样新出现的Lambda表达式，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用fork/join并行方式来拆分任务和加速处理过程<sup>1</sup>。</p>
</blockquote>
<p>这篇文章重点分析Stream背后的数据结构及执行流程，以下面代码为例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">int</span> sum = list.stream().filter(x -&gt; x % <span class="number">2</span> == <span class="number">0</span>).sorted(Comparator.reverseOrder()).map(x -&gt; x * x).reduce((x, y) -&gt; x + y).get();</span><br></pre></td></tr></table></figure></p>
<p>在这段执行代码之后，将会生成以下的数据结构：</p>
<p><img src="/images/java-stream-pipeline.jpg" alt="java-stream-pipeline" title="java-stream-pipeline"></p>
<ul>
<li>操作的定义：对数据的一次处理，如过滤(filter)，排序(sorted)，映射(map)及规约（reduce）等等。操作有三种类型：1)Head，头结点，没有实际操作，包含了数据源；2)ReferencePipeline，中间操作，代表了一次数据处理；3)TerminalOp，结束操作，代表处理的结束。</li>
<li>ReferencePipeline对象代表了一次中间操作，描述了操作的静态信息，Stream执行的一次中间操作之后都会生成一个ReferencePipeline对象(StatelessOp及StatefulOp)，这些对象在最终操作（reduce）之前会形成一个双向链表，此时只是建立操作的前后关系，还未执行真正的操作。</li>
<li>Sink对象代表了真正的所要执行的操作，执行terminal操作(如reduce)之后，将会从后往前生成一个”操作序列”，如上图所示的wrapedSink对象。每一个ReferencePipeline对象对应一个Sink对象，代表了ReferencePipeline所要执行的操作，前一个Sink对象会持有下一个操作的Sink对象，形成一个单向链表。</li>
<li>Sink对象有四个基本方法：1）begin()，操作的开始；2）end()，代表操作结束；3）accept(E e)，真正的操作,如filter,sorted,map及reduce等数据处理；4）cancellationRequested，是否取消操作，用于断路操作，如anyMatch表示找到第一个匹配的对象，后面的数据不用再执行，直接退出；Sink对象根据需要实现这四个方法，来满足不同的数据处理需求。</li>
<li>ReferencePipeline对象有两种不同的类型：StatelessOp（无状态操作）和StatefulOp（有状态操作），这两种类型的区别就在于数据元素之间是否有依赖，如排序(sotred)操作，是一个有状态操作，需要知道所有数据元素才能进行排序，它会临时生成一个列表存放所有的数据，排序之后，重新迭代处理后面的操作，而对于无状态操作，前一个数据元素的操作与后一个数据元素操作没有关系，可以直接将多个无状态操作合并起来，即前一个操作结束之后，可将操作结果直接传给下一个操作（downstream）,在一次迭代中将所有操作执行完毕，这就是Stream处理数据高效的原因。相对而言，有状态操作会存储临时结果，重起一次迭代，而无状态操作一次迭代即可完成所有操作，如上图所示，因为有sorted操作，所有的数据处理需要两次迭代完成。</li>
<li>上图中的执行流程是一个没有短路操作（后面会讲短路操作的流程）的流程，可以看到，主要分为三个步骤：1）执行begin()，进行初始化操作；2）执行accept()，数据处理；3）执行end()操作，进行数据收尾操作，这三个操作会递归调用，直到碰到有状态操作或结束操作才结束，如果碰到的是有状态操作，如sorted，前一个迭代的end操作将会触发下一个迭代的开始。</li>
</ul>
<p>在文章开始前，先讲述下几个重要概念：<br>1、Stream</p>
<blockquote>
<p>A sequence of elements supporting sequential and parallel aggregate operations.  The following example illustrates an aggregate operation using<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = widgets.stream()</span><br><span class="line">                   .filter(w -&gt; w.getColor() == RED)</span><br><span class="line">                   .mapToInt(w -&gt; w.getWeight())</span><br><span class="line">                   .sum();</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>2、AbstractPipeline</p>
<blockquote>
<p>Abstract base class for “pipeline” classes, which are the core implementations of the Stream interface and its primitive specializations. Manages construction and evaluation of stream pipelines.<br>An AbstractPipelinere presents an initial portion of a stream pipeline, encapsulating a stream source and zero or more intermediate operations. The individual AbstractPipeline objects are often referred to as stages, where each stage describes either the stream source or an intermediate operation.</p>
</blockquote>
<p>3、Sink</p>
<blockquote>
<p>An extension of Consumer used to conduct values through the stages of a stream pipeline, with additional methods to manage size information, control flow, etc.  Before calling the  accept() method on a code Sink for the first time, you must first call the  begin() method to inform it that data is coming (optionally informing the sink how much data is coming), and after all data has been sent, you must call the end() method.  After calling end(), you should not call accept() without again calling begin(). Sink also offers a mechanism by which the sink can cooperatively signal that it does not wish to receive any more data (the cancellationRequested() method), which a source can poll before sending more data to the Sink.</p>
</blockquote>
<h2 id="2-AbstractPipeline"><a href="#2-AbstractPipeline" class="headerlink" title="2. AbstractPipeline"></a>2. AbstractPipeline</h2><p>在Stream中执行的一个数据处理都对应一个操作，最终以双向链表的形式组织起来，而操作的类型分为三种：1）head头结点；2）ReferencePipeline，中间操作；3）TerminalOp，结束操作，实际上head头结点也是ReferencePipeline类型，只是它有点特殊，它没有实际的操作，所以单独把它拿出来。ReferencePipeline中间操作分为两种操作：1）有状态操作(StatefulOp)；2）无状态操作（StatelessOp）,两者的操作在上面内容已经讲述过，在这里不再赘述。TerminalOp结束操作也分为两种操作：1）非短路操作；2）短路操作，这两者之间的区别在短路操作会终止后续的操作，提前返回，关于短路操作在后面的内容重点讲述。这几种分类如下图所示：</p>
<table width="600"><tr><td colspan="3" style="text-align:center" border="0">Stream操作分类</td></tr><tr><td rowspan="2" border="1">中间操作(Intermediate operations)</td><td>无状态(Stateless)</td><td>unordered() filter() map() mapToInt() mapToLong() mapToDouble() flatMap() flatMapToInt() flatMapToLong() flatMapToDouble() peek()</td></tr><tr><td>有状态(Stateful)</td><td>distinct() sorted() sorted() limit() skip() </td></tr><tr><td rowspan="2" border="1">结束操作(Terminal operations)</td><td>非短路操作</td><td>forEach() forEachOrdered() toArray() reduce() collect() max() min() count()</td></tr><tr><td>短路操作(short-circuiting)</td><td>anyMatch() allMatch() noneMatch() findFirst() findAny()</td></tr></table>

<p>中间操作的类图如下所示：<br><img src="/images/ReferencePipeline.jpg" alt="ReferencePipeline" title="ReferencePipeline"><br>Head,Stateful及StatelessOp都继承自ReferencePipeline类，Head相对其它两种类型，没有实际的操作，只是包含了一个数据源。另外，这三个类也实现了Stream接口，每一个操作都可以继续调用下一个操作，实现链式调用。<br>ReferencePipeline类，有两个比较重要的作用：1）将中间操作以双向链表的形式组织起来，方便后面构建”操作序列”（Sink对象链）；2）构建当前操作的Sink对象，该对象是包含了真正的处理流程。以map方法为例介绍这两个作用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R&gt; <span class="function">Stream&lt;R&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> P_OUT, ? extends R&gt; mapper)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(mapper);</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StatelessOp&lt;P_OUT, R&gt;(<span class="keyword">this</span>, StreamShape.REFERENCE,</span><br><span class="line">                                 StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function">Sink&lt;P_OUT&gt; <span class="title">opWrapSink</span><span class="params">(<span class="keyword">int</span> flags, Sink&lt;R&gt; sink)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Sink.ChainedReference&lt;P_OUT, R&gt;(sink) &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(P_OUT u)</span> </span>&#123;</span><br><span class="line">                    downstream.accept(mapper.apply(u));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在map方法调用中，会生成一个StatelessOp对象，在构造函数中将当前的Pipeline对象（this对象）作为参数传递给新生成的对象，该StatelessOp对象继承了AbstractPipeline抽象类，在AbstractPipeline类中通过nextStage、previousStage两个字段将前后两个操作建立起前后的关联关系，代码如下图所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> previousStage 前一个阶段的操作,就是构建函数中传入的this对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> opFlags the operation flags for the new stage 操作的标志</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">AbstractPipeline(AbstractPipeline&lt;?, E_IN, ?&gt; previousStage, <span class="keyword">int</span> opFlags) &#123;</span><br><span class="line">    <span class="keyword">if</span> (previousStage.linkedOrConsumed)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(MSG_STREAM_LINKED);</span><br><span class="line">    previousStage.linkedOrConsumed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 上一个阶段(前一个操作)的nextStage指向当前的StatelessOp对象</span></span><br><span class="line">    previousStage.nextStage = <span class="keyword">this</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前对象的previousStage指向上一个阶段的对象(前一个操作)</span></span><br><span class="line">    <span class="keyword">this</span>.previousStage = previousStage;</span><br><span class="line">    <span class="keyword">this</span>.sourceOrOpFlags = opFlags &amp; StreamOpFlag.OP_MASK;</span><br><span class="line">    <span class="keyword">this</span>.combinedFlags = StreamOpFlag.combineOpFlags(opFlags, previousStage.combinedFlags);</span><br><span class="line">    <span class="keyword">this</span>.sourceStage = previousStage.sourceStage;</span><br><span class="line">    <span class="keyword">if</span> (opIsStateful())</span><br><span class="line">        sourceStage.sourceAnyStateful = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.depth = previousStage.depth + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外，在StatelessOp对象的opWrapSink方法中，构建了一个Sink.ChainedReference对象，该对象包含了map的处理逻辑。这个方法相对比较简单，数据用mapper方法处理完之后，将结果传递给下个操作(downstream)处理，其中mapper对应是Lamdba表达式：x -&gt; x * x。</p>
<p>TerminalOp终止操作的类图如下所示：<br><img src="/images/TerminalOp.jpg" alt="TerminalOp" title="TerminalOp"><br>TerminalOp有四种类型，分别是：1）ForEachOp；2）FindOp；3）MatchOp；4）ReduceOp。表格中提到的所有终止操作都是基于这四种类型来实现的，另外终止类型的操作并没有加入到由ReferencePipeline组成的双向链表中。<br>最后的终止操作是通过调用诸如forEach(), reduce(), collect(), anyMatch()等这些方法来触发的，这些方法最终会调用ReferencePipeline类中的evaluate()方法来完成操作，在evaluate()方法，生成一个TerminalOp对象，且封装了一个统一的处理流程，现在来看下这个evaluate()方法，其流程如下：<br><img src="/images/stream-evaluate.jpg" alt="stream-evaluate" title="stream-evaluate"></p>
<ul>
<li>根据不同的终止操作生成不同的TerminalOp对象，可以是上面四种类型中的任意一种；</li>
<li>构建数据源Spliterator；</li>
<li>执行evaluate()方法的中间操作ReferencePipeline对象合并TerminalOp对象的操作标志位，如是否短路操作等等；</li>
<li>判断执行的模式，并发模式暂不分析，我们主要分析Sequential模式；</li>
<li>从TerminalOp对象中构建TerminalSink对象；</li>
<li>从后往前遍历中间操作（ReferencePipeline）对象，构建每一个中间操作对应的Sink对象，并将这些Sink对象从前往后生成链表，TerminalSink对象在链尾；</li>
<li>根据操作标志位判来触发真正的动作，如短路操作，或者非短路操作，该部分内容在后面讲述；</li>
</ul>
<p>在这里重点看一个步骤：包装Sink对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sink TerminalSink对象,链尾对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 链首Sink对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">final</span> &lt;P_IN&gt; <span class="function">Sink&lt;P_IN&gt; <span class="title">wrapSink</span><span class="params">(Sink&lt;E_OUT&gt; sink)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(sink);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历所有的中间操作</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>) AbstractPipeline p=AbstractPipeline.<span class="keyword">this</span>; p.depth &gt; <span class="number">0</span>; p=p.previousStage) &#123;</span><br><span class="line">        sink = p.opWrapSink(p.previousStage.combinedFlags, sink);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (Sink&lt;P_IN&gt;) sink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过wrapSink方法，从后往前遍历所有的AbstractPipeline对象，生成每个操作对应的Sink对象，并将后一个Sink对象作为参数传入，赋值给dowonstream字段，从而将所有的Sink对象串连起来，通过链首的Sink对象访问所有的Sink对象。</p>
<h2 id="3-Sink"><a href="#3-Sink" class="headerlink" title="3. Sink"></a>3. Sink</h2><p>Sink对象是扩展自Comsumer接口，主要用来处理数据，除了Comsumer接口的accept()方法，还增加了三个方法：begin(),end()及cancellationRequested()。在调用accept()方法之前，先调用begin(int size)方法，告之数据源的大小，调用accept()方法之后，再调用end()方法，通知数据处理已经结束，如果有短路操作（中止后续数据的处理），必须先调用cancellationRequested()方法，这两种处理模式如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非短路操作</span></span><br><span class="line"><span class="keyword">if</span> (!StreamOpFlag.SHORT_CIRCUIT.isKnown(getStreamAndOpFlags())) &#123;</span><br><span class="line">    <span class="comment">// 1、调用begin()方法，告之数据源大小；</span></span><br><span class="line">    wrappedSink.begin(spliterator.getExactSizeIfKnown());</span><br><span class="line">    <span class="comment">// 2、遍历数据源元素，调用wrappedSink.accept()方法处理数据；</span></span><br><span class="line">    spliterator.forEachRemaining(wrappedSink);</span><br><span class="line">    <span class="comment">// 3、处理完数据之后，调用end()方法</span></span><br><span class="line">    wrappedSink.end();</span><br><span class="line">	</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  <span class="comment">// 短路操作</span></span><br><span class="line">    <span class="comment">// 调用begin()方法，告之数据源大小；</span></span><br><span class="line">    wrappedSink.begin(spliterator.getExactSizeIfKnown());</span><br><span class="line">    <span class="comment">// 2、遍历数据源元素，调用wrappedSink.accept()方法处理数据，</span></span><br><span class="line">    <span class="comment">// 如果上一个元素设置了“短路”标志，说明数据已经完毕，则退出遍历；</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!wrappedSink.cancellationRequested() &amp;&amp; spliterator.tryAdvance(wrappedSink));</span><br><span class="line">    <span class="comment">// 3、处理完数据之后，调用end()方法</span></span><br><span class="line">    wrappedSink.end();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面的代码可以看出，所有的操作都是在一次遍历中完成的，对数据的处理操作已经按照书写顺序串连起来，即Sink对象链表，数据源中的每一个元素依次传递给Sink对象，被Sink对象的accept()方法处理，如果是短路操作，则需要设置”短路”标志，在处理下一个数据元素时，调用cancellationRequested()方法便可知道数据已经处理完毕，退出遍历返回即可。这里有两个问题，1）“短路”标志是如何设置的？2）数据的处理是否只需要一次遍历？<br>1) “短路”标志设置<br>在两个地方需要判断“短路”标志，一个是根据“短路”标志，是否执行“短路”操作，另外一个是在遍历数据源的过程中，判断数据处理是否已经被取消，需要中止操作，以anyMatch()方法为例。<br><img src="/images/short_circuit-1.jpg" alt="short_circuit-1" title="short_circuit-1"><br>如上图所示，判断“短路”的逻辑如下：</p>
<ul>
<li><p>在短路操作的TerminalOp对象中设置短路的标志位；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MatchOp.getOpFlags()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOpFlags</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> StreamOpFlag.IS_SHORT_CIRCUIT | StreamOpFlag.NOT_ORDERED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将TerminalOp对象中短路标志位合并到最后一个ReferencePipeline对象的combinedFlags中；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractPipeline.sourceSpliterator()</span></span><br><span class="line"><span class="keyword">if</span> (terminalFlags != <span class="number">0</span>)  &#123;</span><br><span class="line">    <span class="comment">// Apply flags from the terminal operation to last pipeline stage</span></span><br><span class="line">    combinedFlags = StreamOpFlag.combineOpFlags(terminalFlags, combinedFlags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据combinedFlags判断是否执行短路操作；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractPipeline.copyInto()</span></span><br><span class="line"><span class="keyword">if</span> (!StreamOpFlag.SHORT_CIRCUIT.isKnown(getStreamAndOpFlags())) &#123;</span><br><span class="line">    wrappedSink.begin(spliterator.getExactSizeIfKnown());</span><br><span class="line">    spliterator.forEachRemaining(wrappedSink);</span><br><span class="line">    wrappedSink.end();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    copyIntoWithCancel(wrappedSink, spliterator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>中止操作的逻辑如下：<br><img src="/images/short_circuit-2.jpg" alt="short_circuit-2" title="short_circuit-2"><br>在MatchSink中一个stop的字段，如果找到匹配的数据，则设置stop=true，在进行下一个数据匹配之前递归调用cancellationRequested()，取得stop的值，从而中止操作。</p>
<ul>
<li><p>找到匹配的数据并设置stop；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MatchSink.accept()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 条件匹配</span></span><br><span class="line">    <span class="keyword">if</span> (!stop &amp;&amp; predicate.test(t) == matchKind.stopOnPredicateMatches) &#123;</span><br><span class="line">        stop = <span class="keyword">true</span>; <span class="comment">// 设置stop</span></span><br><span class="line">        value = matchKind.shortCircuitResult;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对下一个数据元素进行数据处理前递归调用cancellationRequested()方法，调用到TerminalSink，结束调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReferencePipeline.forEachWithCancel()</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEachWithCancel</span><span class="params">(Spliterator&lt;P_OUT&gt; spliterator, Sink&lt;P_OUT&gt; sink)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理下一个数据之前调用cancellationRequested()方法</span></span><br><span class="line">    <span class="keyword">do</span> &#123; &#125; <span class="keyword">while</span> (!sink.cancellationRequested() &amp;&amp; spliterator.tryAdvance(sink));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ChainedReference.cancellationRequested()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancellationRequested</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归调用一个Sink的cancellationRequested()方法</span></span><br><span class="line">    <span class="keyword">return</span> downstream.cancellationRequested();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BooleanTerminalSink.cancellationRequested</span></span><br><span class="line"><span class="comment">// 调用到TerminalSink，结束调用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancellationRequested</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> stop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>2）遍历次数<br>中间操作ReferencePipeline对象分为两种类型：1）无状态操作StatelessOp；2）有状态操作StatefulOp。这两种操作的区别在于：在无状态操作StatelessOp中数据元素没有依赖关系，每一个数据元素可以独立处理，而有状态操作StatefulOp中数据元素的处理依赖其它元素，每一个元素不能独立处理，以filter()和sorted()两个方法为例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReferencePipeline.filter()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Stream&lt;P_OUT&gt; <span class="title">filter</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> P_OUT&gt; predicate)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(predicate);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StatelessOp&lt;P_OUT, P_OUT&gt;(<span class="keyword">this</span>, StreamShape.REFERENCE,</span><br><span class="line">                                 StreamOpFlag.NOT_SIZED) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function">Sink&lt;P_OUT&gt; <span class="title">opWrapSink</span><span class="params">(<span class="keyword">int</span> flags, Sink&lt;P_OUT&gt; sink)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Sink.ChainedReference&lt;P_OUT, P_OUT&gt;(sink) &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">(<span class="keyword">long</span> size)</span> </span>&#123;</span><br><span class="line">                    downstream.begin(-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(P_OUT u)</span> </span>&#123;</span><br><span class="line">					<span class="comment">// 如果满足过滤条件，则传递给下一个Sink处理</span></span><br><span class="line">                    <span class="keyword">if</span> (predicate.test(u))</span><br><span class="line">                        downstream.accept(u);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在StatelessOp操作中，经过本阶段的Sink处理完毕之后，会将数据元素继续传递给下一个Sink对象处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sorted()方法对应的Sink对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RefSortingSink</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractRefSortingSink</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 临时生成一个列表对象</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;T&gt; list;</span><br><span class="line"></span><br><span class="line">    RefSortingSink(Sink&lt;? <span class="keyword">super</span> T&gt; sink, Comparator&lt;? <span class="keyword">super</span> T&gt; comparator) &#123;</span><br><span class="line">        <span class="keyword">super</span>(sink, comparator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">(<span class="keyword">long</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size &gt;= Nodes.MAX_ARRAY_SIZE)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(Nodes.BAD_SIZE);</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 2. 列表对象初始化，一般生成不限长度的列表</span></span><br><span class="line">        list = (size &gt;= <span class="number">0</span>) ? <span class="keyword">new</span> ArrayList&lt;T&gt;((<span class="keyword">int</span>) size) : <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 4. 进行排序操作</span></span><br><span class="line">        list.sort(comparator);</span><br><span class="line">	</span><br><span class="line">        <span class="comment">// 5. 重新遍历数据列表，处理后续的操作</span></span><br><span class="line">        downstream.begin(list.size()); <span class="comment">// 通知数据处理开始</span></span><br><span class="line">        <span class="comment">// 6. 判断是否进行“短路”操作</span></span><br><span class="line">        <span class="keyword">if</span> (!cancellationWasRequested) &#123;</span><br><span class="line">            <span class="comment">// 7. 执行非短路操作</span></span><br><span class="line">            list.forEach(downstream::accept);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 8. 执行短路操作</span></span><br><span class="line">            <span class="keyword">for</span> (T t : list) &#123;</span><br><span class="line">                <span class="keyword">if</span> (downstream.cancellationRequested()) <span class="keyword">break</span>;</span><br><span class="line">                downstream.accept(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 9. 通知数据处理结束</span></span><br><span class="line">        downstream.end();</span><br><span class="line">        list = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 3. 将数据元素添加到列表中</span></span><br><span class="line">        list.add(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于排序操作而言，需要知道所有的元素才能进行，所以它临时生成了一个新的列表对象，存储完所有的数据元素之后，再进行排序操作。最后遍历列表对象，重新执行短路/非短路操作，完成剩余的操作。</p>
<p>总上所述，在操作序列中只有无状态操作的话，只要遍历一次即可执行完所有操作，如果包含有状态操作，则每一个有状态操作者需要增加一次遍历。</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>通过上面的分析，Stream的实现有以下三个特点：1）通过链表的方式将操作序列串连起来，数据元素在这个链表中依次流动（传递），可以有效减少数据遍历的次数；2）定义了一套“协议”，规范了前后两个不同操作之间的交互方式，遵循了这套协议，不同操作可按不同顺序组合，完成不同的功能；3）借助Fork/Join框架，数据源可并发执行数据处理，显著提高数据处理的效率。</p>
<p><strong>参考：</strong></p>
<hr>
<p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/index.html" target="_blank" rel="noopener">1. Java 8 中的 Streams API 详解</a></p>
<p><a href="https://www.cnblogs.com/CarpenterLee/p/6637118.html" target="_blank" rel="noopener">2. 深入理解Java Stream流水线</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/19/java-fork-join/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/19/java-fork-join/" class="post-title-link" itemprop="http://yoursite.com/page/3/index.html">Java Fork/Join框架</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-19 14:15:31" itemprop="dateCreated datePublished" datetime="2019-11-19T14:15:31+08:00">2019-11-19</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-07-31 17:17:10" itemprop="dateModified" datetime="2021-07-31T17:17:10+08:00">2021-07-31</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/并发编程/" itemprop="url" rel="index"><span itemprop="name">并发编程</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>ForkJoinPool运用了Fork/Join原理，使用“分而治之”的思想，将大任务分拆成小任务，从而分配给多个线程并行执行，最后合并得到最终结果，加快计算。ForkJoinPool可以充分利用多cpu，多核cpu的优势，提高算法的执行效率，ForkJoinPool整体结构如下图所示：<br><img src="/images/fork-join.jpg" alt="fork-join" title="fork-join"></p>
<ul>
<li>ForkJoinPool：框架的主体，存放了工作队列数组，对线程、工作队列及任务进行统一的管理。</li>
<li>WorkQueue：工作队列，是任务存储的容器，也是实现Work-Stealing的关键数据结构。</li>
<li>ForkJoinWorkerThread：工作线程，是任务的执行单元。</li>
<li>ForkJoinTask：封装业务的执行逻辑，包括任务fork及join流程。</li>
</ul>
<h2 id="2-核心思想"><a href="#2-核心思想" class="headerlink" title="2. 核心思想"></a>2. 核心思想</h2><p>ForkJoinPool的两大核心就是分而治之(Divide and conquer)和工作窃取(Work Stealing)算法，下面先对两种算法作一个介绍，后面将会具体细节做说明，这部分内容来自 <a href="https://blog.hufeifei.cn/2018/09/15/Java/ForkJoinPool/" target="_blank" rel="noopener">holmofy</a>，作者进行了很好的总结。</p>
<h3 id="2-1-分而治之"><a href="#2-1-分而治之" class="headerlink" title="2.1 分而治之"></a>2.1 分而治之</h3><p>ForkJoinPool主要思想是：将一个大任务拆分成多个小任务后，使用fork可以将小任务分发给其他线程同时处理，使用join可以将多个线程处理的结果进行汇总。<br><img src="/images/devide-conquer.jpg" alt="devide-conquer" title="devide-conquer"></p>
<h3 id="2-2-工作窃取"><a href="#2-2-工作窃取" class="headerlink" title="2.2 工作窃取"></a>2.2 工作窃取</h3><p>Fork/Join框架中使用的work stealing灵感来源于Cilk(开发Cilk的公司被Intel收购，原项目后来被升级为Clik Plus)。</p>
<blockquote>
<p>Intel公司除了Clik Plus还有一个TBB(Threading Building Blocks)也是使用work stealing算法实现。</p>
</blockquote>
<p>Work Stealing算法是Fork/Join框架的核心思想：</p>
<ul>
<li>每个线程都有自己的一个WorkQueue，该工作队列是一个双端队列；</li>
<li>队列支持三个功能push、pop、poll；</li>
<li>push/pop只能被队列的所有者线程调用，而poll可以被其他线程调用；</li>
<li>划分的子任务调用fork时，都会被push到自己的队列中；</li>
<li>默认情况下，工作线程从自己的双端队列获出任务并执行；</li>
<li>当自己的队列为空时，线程随机从另一个线程的队列末尾调用poll方法窃取任务。<br><img src="/images/work-stealing.jpg" alt="work-stealing" title="work-stealing"></li>
</ul>
<h2 id="3-数据结构"><a href="#3-数据结构" class="headerlink" title="3. 数据结构"></a>3. 数据结构</h2><h3 id="3-1-ForkJoinPool"><a href="#3-1-ForkJoinPool" class="headerlink" title="3.1 ForkJoinPool"></a>3.1 ForkJoinPool</h3><p>ForkJoinPool中的几个关键字段如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">long</span> ctl;                   <span class="comment">// main pool control</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> runState;               <span class="comment">// lockable status</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> config;                    <span class="comment">// parallelism, mode</span></span><br><span class="line"><span class="keyword">int</span> indexSeed;                       <span class="comment">// to generate worker index</span></span><br><span class="line"><span class="keyword">volatile</span> WorkQueue[] workQueues;     <span class="comment">// main registry</span></span><br></pre></td></tr></table></figure></p>
<h4 id="3-1-1-ctl字段"><a href="#3-1-1-ctl字段" class="headerlink" title="3.1.1 ctl字段"></a>3.1.1 ctl字段</h4><p>ctl有64位，分成4组各16位，代表了不同的状态，在ForkJoinPool中是一个很重要的字段，很多控制逻辑都要根据ctl来完成，如下图所示：<br><img src="/images/ctl.jpg" alt="ctl" title="ctl"></p>
<ul>
<li>AC：活跃线程的数量，初始化-parallelism；</li>
<li>TC：所有线程的数量，初始化-parallelism；</li>
<li>SS：表示空闲线程栈（Treiber stack）栈顶元素的版本和状态；</li>
<li>ID：表示空闲线程栈（Treiber stack）栈顶元素在workQueues数组中的下标；</li>
</ul>
<p>parallelism表示ForkJoinPool的最大线程数，其最大值由MAX_CAP(32767)限定，默认情况下等于cpu的核数（Runtime.getRuntime().availableProcessors()），要改变这个值也可以通过构造函数设置。</p>
<p>为了方便运算，AC和TC初始化parallelism负值，当AC和TC为负数时，表示线程数未达到最大线程数，可以新建线程。SP是ctl的低32位，可通过sp=(int)ctl取到，如果是否零的情况下，表示有空闲线程。</p>
<p>在ForkJoinPool中，线程是绑定在WorkQueue上的，即一个线程必然有绑定WorkQueue（但WorkQueue不一定绑定线程，外部线程提交任务创建的WorkQueue绑定的线程为null）。ID存放的实际是空闲线程对应的WorkQueue在WorkQueue[]数组中的下标，后面为了描述的方便，统一说成是空闲线程的下标。下一个空闲线程（其实保存的也是WorkQueue[]的下标）保存在WorkQueue的stackPred字段中，讲到WorkQueue时，我们再对空闲线程栈进行深入描述。</p>
<p>ForkJoinPool中定义的常量字段：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bounds</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SMASK        = <span class="number">0xffff</span>;        <span class="comment">// short bits == max index</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_CAP      = <span class="number">0x7fff</span>;        <span class="comment">// max #workers - 1</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EVENMASK     = <span class="number">0xfffe</span>;        <span class="comment">// even short bits</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SQMASK       = <span class="number">0x007e</span>;        <span class="comment">// max 64 (even) slots</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Masks and units for WorkQueue.scanState and ctl sp subfield</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SCANNING     = <span class="number">1</span>;             <span class="comment">// false when running tasks</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INACTIVE     = <span class="number">1</span> &lt;&lt; <span class="number">31</span>;       <span class="comment">// must be negative</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SS_SEQ       = <span class="number">1</span> &lt;&lt; <span class="number">16</span>;       <span class="comment">// version count</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Mode bits for ForkJoinPool.config and WorkQueue.config</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_MASK    = <span class="number">0xffff</span> &lt;&lt; <span class="number">16</span>;  <span class="comment">// top half of int</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LIFO_QUEUE   = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FIFO_QUEUE   = <span class="number">1</span> &lt;&lt; <span class="number">16</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_QUEUE = <span class="number">1</span> &lt;&lt; <span class="number">31</span>;       <span class="comment">// must be negative</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Lower and upper word masks</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SP_MASK    = <span class="number">0xffffffffL</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> UC_MASK    = ~SP_MASK;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Active counts</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  AC_SHIFT   = <span class="number">48</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> AC_UNIT    = <span class="number">0x0001L</span> &lt;&lt; AC_SHIFT;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> AC_MASK    = <span class="number">0xffffL</span> &lt;&lt; AC_SHIFT;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Total counts</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  TC_SHIFT   = <span class="number">32</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TC_UNIT    = <span class="number">0x0001L</span> &lt;&lt; TC_SHIFT;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TC_MASK    = <span class="number">0xffffL</span> &lt;&lt; TC_SHIFT;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> ADD_WORKER = <span class="number">0x0001L</span> &lt;&lt; (TC_SHIFT + <span class="number">15</span>); <span class="comment">// sign 48位是TC的符号位</span></span><br></pre></td></tr></table></figure></p>
<p>1、ctl的初始化(ForkJoinPool)：AC=TC=-parallelism,SS=ID=0<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.config = (parallelism &amp; SMASK) | mode;</span><br><span class="line"><span class="keyword">long</span> np = (<span class="keyword">long</span>)(-parallelism); <span class="comment">// offset ctl counts</span></span><br><span class="line"><span class="keyword">this</span>.ctl = ((np &lt;&lt; AC_SHIFT) &amp; AC_MASK) | ((np &lt;&lt; TC_SHIFT) &amp; TC_MASK);</span><br></pre></td></tr></table></figure></p>
<p>假定parallelism值为4，np为-4，16进制为FFFF FFFF FFFF FFFC，np &lt;&lt; AC_SHIFT 表示np左移48（AC_SHIFT）位，得到FFFC 0000 0000 0000，再与AC_MASK(0XFFFF 0000 0000 0000)进行&amp;（与）操作，((np &lt;&lt; AC_SHIFT) &amp; AC_MASK)得到的值为FFFC 0000 0000 0000，同理，((np &lt;&lt; TC_SHIFT) &amp; TC_MASK)，得到的值为0000 FFFC 0000 0000，最后再将这两个值进行|（或）操作，得到的值为FFFC FFFC 0000 0000，即将AC，TC赋值为-4赋值，SS和ID为0。</p>
<p>2、添加线程(tryAddWorker)：AC=TC=+1<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> nc = ((AC_MASK &amp; (c + AC_UNIT)) |</span><br><span class="line">           (TC_MASK &amp; (c + TC_UNIT)));</span><br></pre></td></tr></table></figure></p>
<p>添加线程的时候，会将AC和TC都加1，其中c为当前CTL的值，新值为nc。假定c为FFFC FFFC 0000 0000，c + AC_UNIT 可以表示为FFFC FFFC 0000 0000 + 0001 0000 000 000，即在TC部分加1，得到的值为FFFD FFFC 0000 0000，再与AC_MASK(FFFF 0000 0000 0000)进行&amp;(与操作)，(AC_MASK &amp; (c + AC_UNIT))的值为FFFD 0000 0000 0000。同理TC_MASK &amp; (c + TC_UNIT))为0000 FFFD 0000 0000，最后将这个值进行|(或)操作，得到FFFD FFFD 0000 0000。</p>
<p>3、睡眠线程(scan)：AC:-1,ID=new ID<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ss = w.scanState; <span class="comment">// w为WorkQueue的变量</span></span><br><span class="line"><span class="keyword">int</span> ns = ss | INACTIVE;       <span class="comment">// try to inactivate</span></span><br><span class="line"><span class="keyword">long</span> nc = ((SP_MASK &amp; ns) |</span><br><span class="line">           (UC_MASK &amp; ((c = ctl) - AC_UNIT)));</span><br><span class="line">w.stackPred = (<span class="keyword">int</span>)c;         <span class="comment">// hold prev stack top</span></span><br></pre></td></tr></table></figure></p>
<p>ss的值为WorkQueue的scanState，scanState初始值为WorkQueue在WorkQueue[]中的下标（如果是外部线程提交任务产生的WorkQueue，scanState为INACTIVE），假定scanState为3，c为FFFD FFFD 0000 0000。ss | INACTIVE(0X8000 0000)等于8000 0011，SP_MASK &amp; ns等于0000 0000 8000 0011，(UC_MASK &amp; ((c = ctl) - AC_UNIT))等于FFFC FFFD 0000 0000，最后nc等于FFFC FFFD 8000 0011，即将空闲线程的下标设置在ID上。</p>
<p>4、唤醒空闲线程(signalWork)：AC:+1,ID=v.stackPred<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下代码进行了精简，与signalWork方法中的顺序不一定一致。</span></span><br><span class="line"><span class="keyword">long</span> c = ctl;</span><br><span class="line"><span class="keyword">int</span> sp = (<span class="keyword">int</span>)c;</span><br><span class="line"><span class="keyword">int</span> i = sp &amp; SMASK; <span class="comment">// 空闲线程的下标</span></span><br><span class="line">WorkQueue v = ws[i]; <span class="comment">// 空闲线程绑定的WorkQueue</span></span><br><span class="line"><span class="keyword">long</span> nc = (UC_MASK &amp; (c + AC_UNIT)) | (SP_MASK &amp; v.stackPred);</span><br></pre></td></tr></table></figure></p>
<p>假定c为FFFC FFFD 8000 0011,v.stackPred为5。将c的类型强制转化为int后，sp得到了c低32位的值，即SS与ID。sp与SMASK(0X0000 FFFF)得到低16位的值，即得到下标值(3)。再根据下标i得到对应的WorkQueue v，取到下一个空闲线程的下标(5)，并将这个下标设置到新ctl中的ID中。</p>
<p>c + AC_UNIT表示AC加1,(UC_MASK &amp; (c + AC_UNIT))得到的值为FFFD FFFD 0000 0000，SP_MASK &amp; v.stackPred为0000 0000 0000 0101，最后这两个值进行|(或)操作，nc的值为FFFE FFFF 0000 0101。</p>
<h4 id="3-1-2-config"><a href="#3-1-2-config" class="headerlink" title="3.1.2 config"></a>3.1.2 config</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LIFO_QUEUE   = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FIFO_QUEUE   = <span class="number">1</span> &lt;&lt; <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> asyncMode = <span class="keyword">false</span>; <span class="comment">// 默认为LIFO</span></span><br><span class="line"><span class="keyword">int</span> mode = asyncMode ? FIFO_QUEUE : LIFO_QUEUE,</span><br><span class="line"><span class="keyword">this</span>.config = (parallelism &amp; SMASK) | mode;</span><br></pre></td></tr></table></figure>
<p>config主要是存放两部分信息：1) parallelism,ForkJoinPool线程数；2) ForkJoinPool同步或异步模式，同步用LIFO模式，异步用FIFO，默认为LIFO。parallelism存放在int的低16位，LIFO_QUEUE为0，两者进行|（或）操作，还是parallelism本身。如果模式是FIFO_QUEUE的话，则将int第17位设置为1，假定parallelism为4，最后|（操作）之后，config的值为0X0001 0004。</p>
<h4 id="3-1-3-workQueues"><a href="#3-1-3-workQueues" class="headerlink" title="3.1.3 workQueues"></a>3.1.3 workQueues</h4><p>workQueues是ForkJoinPool中非常重要的数据结构，存放多个工作队列WorkQueue，工作队列主要有两种类型：1）外部线程提交一次ForkJoinTask任务，都会生成一个WorkQueue，用来存放提交的的任务（一次可提交多个任务），该队列不属于任何一个线程，会等待其它线程来偷取(Work Stealing)任务，这类WorkQueue存放在workQueues的偶数下标处；2）新增一个工作线程WorkerThread时，都会生成一个WorkQueue，用来存放该线程需要执行的子任务，该WorkQueue绑定在工作线程上，这类WorkQueue存放在workQueues的奇数下标处。</p>
<p>1、workQueues初始化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create workQueues array with size a power of two</span></span><br><span class="line"><span class="keyword">int</span> p = config &amp; SMASK; <span class="comment">// ensure at least 2 slots</span></span><br><span class="line"><span class="keyword">int</span> n = (p &gt; <span class="number">1</span>) ? p - <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">1</span>; n |= n &gt;&gt;&gt; <span class="number">2</span>;  n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">8</span>; n |= n &gt;&gt;&gt; <span class="number">16</span>; n = (n + <span class="number">1</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">workQueues = <span class="keyword">new</span> WorkQueue[n];</span><br></pre></td></tr></table></figure></p>
<p>p存放parallelism的值，经过一系列的符号右移及或操作之后，保证n为奇数，最后对n加1，再左移1位，得到一个2的倍数的值，一般情况下workQueues等于parallelism的2倍。</p>
<p>2、提交任务的WorkQueue<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SQMASK常量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SQMASK  = <span class="number">0x007e</span>;   <span class="comment">// max 64 (even) slots</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m = ws.length - <span class="number">1</span>; <span class="comment">// m等于workQueues长度减一，是一个奇数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> k = r &amp; m &amp; SQMASK;</span><br><span class="line">WorkQueue q = <span class="keyword">new</span> WorkQueue(<span class="keyword">this</span>, <span class="keyword">null</span>);</span><br><span class="line">q.hint = r; <span class="comment">// r是一个随机值， r = ThreadLocalRandom.getProbe()</span></span><br><span class="line">q.config = k | SHARED_QUEUE; <span class="comment">// k是存放在workqueue[]中的位置</span></span><br><span class="line">q.scanState = INACTIVE; <span class="comment">// 初始化scanState的状态</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rs &gt; <span class="number">0</span> &amp;&amp;  (ws = workQueues) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">    k &lt; ws.length &amp;&amp; ws[k] == <span class="keyword">null</span>)</span><br><span class="line">    ws[k] = q;  <span class="comment">// else terminated</span></span><br></pre></td></tr></table></figure></p>
<p>r是一个随机数，m是数组长度减一，r &amp; m 操作得到一个介于0~m的随机数字。SQMASK是数组的最大值64，其最低位是0，进行与操作，最低位必然是0，从而保证r &amp; m &amp; SQMASK的值是一个介于0~m的随机偶数。k是一个随机数，主要是为了减少插入位置的冲突。</p>
<p>3、工作线程的WorkQueue<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">WorkQueue w = <span class="keyword">new</span> WorkQueue(<span class="keyword">this</span>, wt);</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;                                    <span class="comment">// assign a pool index</span></span><br><span class="line"><span class="keyword">int</span> mode = config &amp; MODE_MASK;</span><br><span class="line"><span class="keyword">int</span> rs = lockRunState();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    WorkQueue[] ws; <span class="keyword">int</span> n;                    <span class="comment">// skip if no array</span></span><br><span class="line">    <span class="keyword">if</span> ((ws = workQueues) != <span class="keyword">null</span> &amp;&amp; (n = ws.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> s = indexSeed += SEED_INCREMENT;  <span class="comment">// unlikely to collide</span></span><br><span class="line">        <span class="keyword">int</span> m = n - <span class="number">1</span>;</span><br><span class="line">        i = ((s &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>) &amp; m;               <span class="comment">// odd-numbered indices</span></span><br><span class="line">        <span class="keyword">if</span> (ws[i] != <span class="keyword">null</span>) &#123;                  <span class="comment">// collision</span></span><br><span class="line">            <span class="keyword">int</span> probes = <span class="number">0</span>;                   <span class="comment">// step by approx half n</span></span><br><span class="line">            <span class="keyword">int</span> step = (n &lt;= <span class="number">4</span>) ? <span class="number">2</span> : ((n &gt;&gt;&gt; <span class="number">1</span>) &amp; EVENMASK) + <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">while</span> (ws[i = (i + step) &amp; m] != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (++probes &gt;= n) &#123;</span><br><span class="line">                    workQueues = ws = Arrays.copyOf(ws, n &lt;&lt;= <span class="number">1</span>);</span><br><span class="line">                    m = n - <span class="number">1</span>;</span><br><span class="line">                    probes = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        w.hint = s;                           <span class="comment">// use as random seed</span></span><br><span class="line">        w.config = i | mode;</span><br><span class="line">        w.scanState = i;                      <span class="comment">// publication fence</span></span><br><span class="line">        ws[i] = w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    unlockRunState(rs, rs &amp; ~RSLOCK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>重点看以下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">WorkQueue w = <span class="keyword">new</span> WorkQueue(<span class="keyword">this</span>, wt);</span><br><span class="line"></span><br><span class="line">n = ws.length</span><br><span class="line"><span class="keyword">int</span> s = indexSeed += SEED_INCREMENT;  <span class="comment">// unlikely to collide</span></span><br><span class="line"><span class="keyword">int</span> m = n - <span class="number">1</span>;</span><br><span class="line">i = ((s &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>) &amp; m;</span><br><span class="line"></span><br><span class="line">ws[i] = w;</span><br></pre></td></tr></table></figure></p>
<p>s是一个随机值， ((s &lt;&lt; 1) | 1)表达式得到一个随机的奇数，即最低为1。再与m(也是一个奇数)进行&amp;(与)操作，得到一个介于0~m(包括m)的的奇数。从而保证工作线程的WorkQueue存放在workQueues的奇数位置。</p>
<h4 id="3-1-4-indexSeed"><a href="#3-1-4-indexSeed" class="headerlink" title="3.1.4 indexSeed"></a>3.1.4 indexSeed</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Increment for seed generators. See class ThreadLocal for</span></span><br><span class="line"><span class="comment">* explanation.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SEED_INCREMENT = <span class="number">0x9e3779b9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> s = indexSeed += SEED_INCREMENT;</span><br></pre></td></tr></table></figure>
<p>indexSeed主要是用来随机生成WorkQueue的下标。</p>
<h3 id="3-2-WorkQueue"><a href="#3-2-WorkQueue" class="headerlink" title="3.2 WorkQueue"></a>3.2 WorkQueue</h3><p>WorkQueue是存储ForkJoinTask的容器，也是Work-Stealing依赖的数据结构。外部提交新的ForkJoinTask任务，会新建一个WorkQueue，将任务存放到WorkQueue的ForkJoinTask数组中，最后将该WorkQueue存放到ForkJoinPool对象的workQueues数组中（存放到偶数下标处），新的任务会被工作线程窃取。另外一方面工作线程中产生的子任务会存放到该线程绑定的工作队列中。下面是WorkQueue的一些关键字段。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Instance fields</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> scanState;    <span class="comment">// versioned, &lt;0: inactive; odd:scanning</span></span><br><span class="line"><span class="keyword">int</span> stackPred;             <span class="comment">// pool stack (ctl) predecessor</span></span><br><span class="line"><span class="keyword">int</span> nsteals;               <span class="comment">// number of steals</span></span><br><span class="line"><span class="keyword">int</span> hint;                  <span class="comment">// randomization and stealer index hint</span></span><br><span class="line"><span class="keyword">int</span> config;                <span class="comment">// pool index and mode</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> qlock;        <span class="comment">// 1: locked, &lt; 0: terminate; else 0</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> base;         <span class="comment">// index of next slot for poll</span></span><br><span class="line"><span class="keyword">int</span> top;                   <span class="comment">// index of next slot for push</span></span><br><span class="line">ForkJoinTask&lt;?&gt;[] array;   <span class="comment">// the elements (initially unallocated)</span></span><br><span class="line"><span class="keyword">final</span> ForkJoinPool pool;   <span class="comment">// the containing pool (may be null)</span></span><br><span class="line"><span class="keyword">final</span> ForkJoinWorkerThread owner; <span class="comment">// owning thread or null if shared</span></span><br><span class="line"><span class="keyword">volatile</span> Thread parker;    <span class="comment">// == owner during call to park; else null</span></span><br><span class="line"><span class="keyword">volatile</span> ForkJoinTask&lt;?&gt; currentJoin;  <span class="comment">// task being joined in awaitJoin</span></span><br><span class="line"><span class="keyword">volatile</span> ForkJoinTask&lt;?&gt; currentSteal; <span class="comment">// mainly used by helpStealer</span></span><br></pre></td></tr></table></figure></p>
<h4 id="3-2-1-stackPred"><a href="#3-2-1-stackPred" class="headerlink" title="3.2.1 stackPred"></a>3.2.1 stackPred</h4><p>通过ctl的ID字段与stackPred可以形成一个空闲线程列表栈，栈首存放在ID字段中，stackPred存放的是下一个空闲线程的下标，如下图所示：<br><img src="/images/idle-thread-list.jpg" alt="idle-thread-list" title="idle-thread-list"></p>
<h4 id="3-2-2-array-base-top"><a href="#3-2-2-array-base-top" class="headerlink" title="3.2.2 array,base,top"></a>3.2.2 array,base,top</h4><p>这三个字段主要是用来存取ForkJoinTask任务的，array是一个ForkJoinTask类型的数组，以双端队列的方式提供服务；base是队列的底部，外部线程窃取任务就是从base开始；top是队列的顶部，工作队列绑定的线程push/pop都是在top上操作。这三个值的初始状态如下图所示：<br><img src="/images/workqueue-array-init.jpg" alt="workqueue-array-init" title="workqueue-array-init"></p>
<p>array的初始大小为8192，最大为64M，base及top默认值为初始大小的一半4096，代码定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_QUEUE_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">13</span>; <span class="comment">// 8192 数组初始大小</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_QUEUE_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">26</span>; <span class="comment">// 64M 数组最大值</span></span><br><span class="line"></span><br><span class="line">base = top = INITIAL_QUEUE_CAPACITY &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">// base及top默认值</span></span><br></pre></td></tr></table></figure>
<p>工作窃取时的队列如下所示:<br><img src="/images/workqueue-array.jpg" alt="workqueue-array" title="workqueue-array"></p>
<h4 id="3-2-2-currentSteal-currentJoin"><a href="#3-2-2-currentSteal-currentJoin" class="headerlink" title="3.2.2 currentSteal,currentJoin"></a>3.2.2 currentSteal,currentJoin</h4><p>currentSteal表示当前工作线程从外部工作队列中窃取到的任务，currentJoin表示当前工作线程处在join中的任务，通过这两个参数的配合使用，可以将递归类型的任务分布在多个工作线程执行，同时父级任务线程可以帮子任务或孙子任务线程执行任务，它们的关系如下图所示：<br><img src="/images/workqueue-join-steal.jpg" alt="workqueue-join-steal" title="workqueue-join-steal"></p>
<p>wt1线程当前join的任务就是wt2线程窃取的任务，当wt1线程队列没有任务的时候，它会找到窃取它任务的wt2线程，发现wt2线程的任务队列为空，再去查找窃取wt2线程任务的wt3线程，发现wt3线程队列不为空，则窃取wt3线程工作队列base位置的任务t-1-2-1，并执行它。</p>
<h3 id="3-3-ForkJoinWorkerThread"><a href="#3-3-ForkJoinWorkerThread" class="headerlink" title="3.3 ForkJoinWorkerThread"></a>3.3 ForkJoinWorkerThread</h3><p>ForkJoinWorkerThread对象继承自Thread对象，是任务执行的实体，继承关系如下图所示：<br><img src="/images/ForkJoinWorkerThread.jpg" alt="ForkJoinWorkerThread" title="ForkJoinWorkerThread"></p>
<p>ForkJoinWorkerThread有内部有两个字段，主要是保存了WorkQueue及ForkJoinPool的引用，定义如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ForkJoinPool pool;                <span class="comment">// the pool this thread works in</span></span><br><span class="line"><span class="keyword">final</span> ForkJoinPool.WorkQueue workQueue; <span class="comment">// work-stealing mechanics</span></span><br></pre></td></tr></table></figure></p>
<h3 id="3-4-ForkJoinTask"><a href="#3-4-ForkJoinTask" class="headerlink" title="3.4 ForkJoinTask"></a>3.4 ForkJoinTask</h3><p>ForkJoinTask封装了计算的流程，实现了fork及join方法，它是分治算法中两个核心的方法，这两个方法我们在后面的部分详细介绍。ForkJoinTask有两个子类：RecursiveTask和ForkJoinTask，它们的区别主要是计算有没有返回值。这两个子类都提供了一个抽象方法compute，由具体的业务算法来实现，主要包括子任务的划分及结果的合并逻辑，其核心思想如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if(任务很小）&#123;</span><br><span class="line">    直接计算得到结果</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    分拆成N个子任务</span><br><span class="line">    调用子任务的fork()进行计算</span><br><span class="line">    调用子任务的join()合并计算结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="4-工作流程"><a href="#4-工作流程" class="headerlink" title="4. 工作流程"></a>4. 工作流程</h2><h3 id="4-1-提交任务"><a href="#4-1-提交任务" class="headerlink" title="4.1 提交任务"></a>4.1 提交任务</h3><p><img src="/images/invoke-task.jpg" alt="invoke-task" title="invoke-task"></p>
<p>流程：<br>1） 提交线程</p>
<ul>
<li>提交线程（不是工作线程）构建ForkJoinTask，提交给ForkJoinPool执行，如通过invoke方法；</li>
<li>如果ForkJoinPool中的工作队列数组workQueues没有创建，则创建该数组，默认为parallelism的2倍；</li>
<li>创建工作队列q，并将该队列添加到workQueues的偶数下标处；</li>
<li>创建工作队列q的任务数组array，默认大小了8192，base和top的初始值为数组大小的一半，即4096；</li>
<li>提交线程会走到“激活工作线程”的流程，该流程会在后面的内容讲到。</li>
</ul>
<p>2）工作线程</p>
<ul>
<li>启动工作线程wt，扫描ForkJoinPool的workQueues数组，窃取一个ForkJoinTask去执行；</li>
<li>随机生成一个在数组大小范围内的奇数，作为扫描的起始位置，这样可以避免多个线程同时从一个位置扫描，减少竞争；</li>
<li>遍历工作队列workQueues数组，如果工作队列中有任务，则从其base位置处取得任务t，如果该队列中还有其它任务，则“激活工作线程”，让其它工作线程来窃取其它任务；</li>
<li>设置工作线程wt的currentSteal（在工作队列中）的值为t，表示工作窃取了任务t；</li>
<li>执行任务t；</li>
<li>任务执行结束，将currentSteal设置为null；</li>
<li>遍历工作队列workQueues数组，如果都没有找到任务，则会将当前工作线程加入到空闲线程列表中，并睡眠当前工作线程等待激活。</li>
</ul>
<h3 id="4-2-fork流程"><a href="#4-2-fork流程" class="headerlink" title="4.2 fork流程"></a>4.2 fork流程</h3><p><img src="/images/fork-flow.jpg" alt="fork-flow" title="fork-flow"></p>
<p>流程：</p>
<ul>
<li>执行fork的线程可以是外部线程，也可以是工作线程，这两种方式处理方法不一样；</li>
<li>判断线程的类型是否ForkJoinWorkerThread；</li>
<li>如果是ForkJoinWorkerThread类型，则将任务提交到工作线程的工作队列中，执行“激活工作线程”流程；</li>
<li>如果不是ForkJoinWorkerThread类型，则将任务提交到commonForkJoinPool中，与“提交任务”流程是一样的。</li>
</ul>
<h4 id="4-2-1-激活工作线程"><a href="#4-2-1-激活工作线程" class="headerlink" title="4.2.1 激活工作线程"></a>4.2.1 激活工作线程</h4><p><img src="/images/singal-worker.jpg" alt="singal-worker" title="singal-worker"></p>
<p>流程：</p>
<ul>
<li>设置工作队列数组为ws,当前工作队列为q；</li>
<li>判断当前活跃线程是否小于parallelim，如果已经大于parallelim，则直接退出；</li>
<li>再判断是否有空闲线程，有空闲线程则唤醒空闲线程；</li>
<li>如果没有空闲线程，同时线程总数小于parallelim，则创建一个新的工作线程wt来执行任务；</li>
<li>建立线程相关的工作队列w，建立线程与队列的关联关系，并将工作队列添加到数组ws的奇数下标处；</li>
<li>启动wt线程。</li>
</ul>
<h3 id="4-3-join流程"><a href="#4-3-join流程" class="headerlink" title="4.3 join流程"></a>4.3 join流程</h3><p><img src="/images/join-flow.jpg" alt="join-flow" title="join-flow"></p>
<p>流程：</p>
<ul>
<li>执行join的任务为task，执行join方法的线程为wt，wt的工作队列为w；</li>
<li>判断task任务是否已经结束，如果已经结束，直接返回结果即可；</li>
<li>task没有结束，则判断wt的类型，是否为ForkJoinWorkerThread；</li>
<li>如果wt不是ForkJoinWorkerThread类型的线程，则说明是外部线程执行了join方法，则阻塞该线程，等待任务结束后被唤醒；</li>
<li>如果wt是ForkJoinWorkerThread类型的线程，则分为三种情况；</li>
<li>1）task在w的栈首位置，则直接将task出栈，执行task即可；</li>
<li>2）task在w中，但不在栈首位置，处于w的中间位置，则将w中的task转换为空任务（空操作，因为该任务已经被提前执行），执行task；</li>
<li>3）task不在w中，表示该任务已经被其它工作线程窃取了，此时如果w的队列为空，则执行“工作窃取流程”，帮助窃取任务的线程，让它更快结束；</li>
<li>在一个步骤中，如果w的队列不为空，则睡眠线程wt，在睡眠之前，作为补偿，会创建一个新的工作线程或唤醒一个空闲线程来执行任务。</li>
</ul>
<h4 id="4-3-1-工作窃取流程"><a href="#4-3-1-工作窃取流程" class="headerlink" title="4.3.1 工作窃取流程"></a>4.3.1 工作窃取流程</h4><p><img src="/images/work-stealing-flow.jpg" alt="work-stealing-flow" title="work-stealing-flow"></p>
<p>流程：</p>
<ul>
<li>设置task为被窃取的任务，w为当前工作线程的工作队列；</li>
<li>遍历工作队列数组，找到窃取task任务的工作线程,其工作队列为v，判断条件为工作线程的v.cureentSteal==task; </li>
<li>判断工作队列v是否为空；</li>
<li>如果v不为空，则从工作队列v的base位置窃取任务t，在当前线程w中执行任务t，并设置w.currentSteal=t，直到v为空；</li>
<li>如果v为空，则说明任务被其它线程窃取，通过其currentJoin字段找到被窃取的任务，并将该字段设置为task的值，从第一步重新执行，从而帮助儿子任务、孙子任务等等后代任务快速结束。</li>
</ul>
<h2 id="5-实例"><a href="#5-实例" class="headerlink" title="5. 实例"></a>5. 实例</h2><p>我们通过ForkJoinPool框架实现快速排序算法，来展示将在一个线程中执行的递归算法转化为在多个线程中“分治”执行的算法。维基百科关于快速排序的定义如下：</p>
<blockquote>
<p>快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为较小和较大的2个子序列，然后递归地排序两个子序列。<br>步骤为：</p>
<ul>
<li>挑选基准值：从数列中挑出一个元素，称为“基准”（pivot），</li>
<li>分割：重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（与基准值相等的数可以到任何一边）。在这个分割结束之后，对基准值的排序就已经完成，</li>
<li>递归排序子序列：递归地将小于基准值元素的子序列和大于基准值元素的子序列排序。<br>递归到最底部的判断条件是数列的大小是零或一，此时该数列显然已经有序。</li>
</ul>
</blockquote>
<h3 id="5-1-递归算法"><a href="#5-1-递归算法" class="headerlink" title="5.1 递归算法"></a>5.1 递归算法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursiveQuicksort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换数组中两个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array 数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left 左边的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 右边的下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> tmp = array[left];</span><br><span class="line">        array[left] = array[right];</span><br><span class="line">        array[right] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分隔数组为两个子数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array 数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left 左边的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 右边的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 分隔的下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算基准的下标</span></span><br><span class="line">        <span class="keyword">int</span> index = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> privot = array[index];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="keyword">int</span> j = right - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        swap(array, index, right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt;= right &amp;&amp; array[i] &lt; privot) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> ( j &gt;= left &amp;&amp; array[j] &gt; privot) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                swap(array, i, j);</span><br><span class="line">                i++;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (array[i] &gt; array[right]) &#123;</span><br><span class="line">            swap(array, i, right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 快速排序算法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array 数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left 左边的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 右边的下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right || array == <span class="keyword">null</span> || array.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> privot = partition(array, left, right);</span><br><span class="line">        quicksort(array, left, privot - <span class="number">1</span>);</span><br><span class="line">        quicksort(array, privot + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">30</span>, <span class="number">32</span>, <span class="number">65</span>, <span class="number">100</span>, <span class="number">102</span>&#125;;</span><br><span class="line">        <span class="keyword">new</span> RecursiveQuicksort().quicksort(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        IntStream stream = IntStream.of(array);</span><br><span class="line">        stream.forEach(a -&gt; System.out.println(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-2-Fork-Join"><a href="#5-2-Fork-Join" class="headerlink" title="5.2 Fork/Join"></a>5.2 Fork/Join</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinQuicksort</span> <span class="keyword">extends</span> <span class="title">RecursiveAction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> left;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForkJoinQuicksort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForkJoinQuicksort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.array = array;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right || array == <span class="keyword">null</span> || array.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> privot = partition(array, left, right);</span><br><span class="line">        ForkJoinQuicksort leftTask = <span class="keyword">new</span> ForkJoinQuicksort(array, left, privot - <span class="number">1</span>);</span><br><span class="line">        ForkJoinQuicksort rightTask = <span class="keyword">new</span> ForkJoinQuicksort(array, privot + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">        leftTask.fork();    <span class="comment">// 提交异步子任务</span></span><br><span class="line">        rightTask.fork();</span><br><span class="line"></span><br><span class="line">        rightTask.join();   <span class="comment">// 等待任务执行结束</span></span><br><span class="line">        leftTask.join();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">50</span>, <span class="number">23</span>, <span class="number">20</span>, <span class="number">44</span>, <span class="number">22</span>, <span class="number">51</span>, <span class="number">32</span>, <span class="number">65</span>, <span class="number">2</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">        ForkJoinQuicksort task = <span class="keyword">new</span> ForkJoinQuicksort(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">        pool.invoke(task);  <span class="comment">// 提交任务</span></span><br><span class="line"></span><br><span class="line">        IntStream stream = IntStream.of(array);</span><br><span class="line">        stream.forEach(value -&gt; System.out.println(value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ForkJoinQuicksort主要是继承RecursiveAction（没有返回值），算法逻辑在compute方法实现即可。</p>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>ForkJoinPool主要是提供了“分治算法”的多线程版本，基于“Work-Stealing”，可以有效使用cpu多核的优势，提高算法的速度。ForkJoinPool 最适合的是计算密集型的任务，如果存在 I/O、线程间同步、sleep() 等会造成线程长时间阻塞的情况时，最好配合使用 ManagedBlocker。</p>
<p><strong>参考：</strong></p>
<hr>
<p><a href="http://blog.dyngr.com/blog/2016/09/15/java-forkjoinpool-internals/" target="_blank" rel="noopener">1. Java 并发编程笔记：如何使用 ForkJoinPool 以及原理</a></p>
<p><a href="https://www.jianshu.com/p/f777abb7b251" target="_blank" rel="noopener">2. jdk1.8-ForkJoin框架剖析</a></p>
<p><a href="https://blog.hufeifei.cn/2018/09/15/Java/ForkJoinPool/" target="_blank" rel="noopener">3.ForkJoinPool入门篇</a></p>
<p><a href="https://www.jianshu.com/p/de025df55363" target="_blank" rel="noopener">4.分析jdk-1.8-ForkJoinPool实现原理(上)</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/07/consistent-hash/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/07/consistent-hash/" class="post-title-link" itemprop="http://yoursite.com/page/3/index.html">一致性哈希算法</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-07 18:04:49" itemprop="dateCreated datePublished" datetime="2019-11-07T18:04:49+08:00">2019-11-07</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-07-31 17:17:10" itemprop="dateModified" datetime="2021-07-31T17:17:10+08:00">2021-07-31</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构与算法/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-解决的问题"><a href="#1-解决的问题" class="headerlink" title="1. 解决的问题"></a>1. 解决的问题</h2><p>在分布式服务中，往往有这样的场景：将某个用户或某台机器的请求负载路由到固定的某台服务器上。简单的做法直接是使用哈希算法，<strong>h = hash(key) % N</strong> ，该算法的核心思想是：将服务器编号，使用哈希算法取根据某类请求参数key（用户id或IP）计算出一个哈希值，再对该哈希值用服务器数据N进行取余（%）操作，从而得到服务器编号。使用该算法有一个问题，就是服务器数据数目（N）增加中或减少的时候，h的值都会被改变，即请求会负载到新的服务器上，有可能会导致状态数据的失效。有没有一种算法，既可以将同一请求负载到同一台服务器上，又可以在服务器增加或减少的时候将请求的变更控制在一定的范围内，所以提出了一致性哈希算法。</p>
<p>一致性哈希算法（Consistent Hashing）最早在论文《Consistent Hashing and Random Trees: Distributed Caching Protocols for Relieving Hot Spots on the World Wide Web》中被提出，其原理如下：</p>
<blockquote>
<p>一致性哈希算法将整个哈希值（整数）空间组织成一个0~2^32-1的虚拟哈希环，首先，服务器按照名称（或编号）取哈希，并将该哈希值放置在哈希环上，然后再对key取哈希，按照随时针方向查找离该值最近的服务器结点哈希值，从而完成key与服务器的匹配映射工作。</p>
</blockquote>
<p>通过一致性哈希算法，服务器的增加或减少只会影响该服务器周围的请求，不会扩大到整个哈希环，从而保证算法的可扩展性。</p>
<p>一致性哈希算法也有一个问题，就是服务器较少时，可能出现服务器之间负载的请求可能不均衡，有些服务器负载的请求可能过多，而有些服务负载较少。解决这个问题的关键是增加哈希环上服务节点的数量，在物理服务器不能增加的情况下，可以将一个服务结点映射为多个虚拟结点，均匀分布在哈希环上，从而解决该问题。</p>
<h2 id="2-哈希算法"><a href="#2-哈希算法" class="headerlink" title="2. 哈希算法"></a>2. 哈希算法</h2><p>在一致性哈希算法中，哈希算法是一个重要的组成部分，它将服务器结点和请求字符串转换为一个整数，如何选择一个好的哈希算法？评判一个哈希算法的标准是什么？</p>
<p>哈希算法大致有两种类型：加密哈希算法和非加密哈希算法，加密哈希算法为了防止攻击者找出碰撞而设计的，它的速度较慢。非加密哈希算法将字符串作为输入，通过计算输出一个整数，理想的哈希算法有一个特性：输出非常均匀分布在可能的输出域，特别是当输入非常相似的时候。可以将哈希算法大致分为三代：</p>
<ul>
<li>第一代：SHA-1（1993），MD5（1992），CRC（1975），Lookup3（2006）</li>
<li>第二代：MurmurHash（2008）</li>
<li>第三代：CityHash， SpookyHash（2011）</li>
</ul>
<p>其中SHA-1和MD5属于非加密哈希算法，其它都是非加密哈希算法，在一致性哈希算法中，主要用的是非加密哈希算法。除了以上的算法，还有一些算法没有列出，如JDK中hashCode使用的算法，另外，还有专门针对一致性哈希算法设计的哈希算法，如Ketama，也得到了广泛的运用。</p>
<p>在一致性哈希算法的使用场景中，有几个比较重要的算法，单独说明一下：</p>
<ul>
<li>MurmurHash 算法：高运算性能，低碰撞率，由 Austin Appleby 创建于 2008 年，现已应用到 Hadoop、libstdc++、nginx、libmemcached 等开源系统。2011 年 Appleby被Google雇佣，随后Google推出其变种的CityHash算法。官方只提供了C语言的实现版本。Java体系中，Guava，Redis，Memcached，Cassandra，HBase，Lucene都在使用它。</li>
<li>FNV算法：全名为Fowler-Noll-Vo算法，是以三位发明人Glenn Fowler，Landon Curt Noll，Phong Vo 的名字来命名的，最早在 1991 年提出。特点和用途：FNV 能快速 hash 大量数据并保持较小的冲突率，它的高度分散使它适用于hash一些非常相近的字符串，比如URL，hostname，文件名，text，IP 地址等。</li>
<li>Ketama 算法：Ketama不仅提供了一个哈希算法，更是提供了一套一致性哈希算法的实现，在Dubbo及Memcached中使用了该算法。</li>
</ul>
<p>下面针对这些算法，作一一介绍：</p>
<p>1）Java 字符串哈希算法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Java字符串哈希算法是遍历整个字符串，按照hash * 31 + c的算法计算，最后的哈希值为s[0] *31^(n-1) + s<a href="https://www.oschina.net/translate/state-of-hash-functions" target="_blank" rel="noopener">1</a>*31^(n-2) + … + s[n-1]。</p>
<p>2）CRC 哈希算法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CRCHashStrategy</span> <span class="keyword">implements</span> <span class="title">HashStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LOOKUP_TABLE[] = &#123;<span class="number">0x0000</span>, <span class="number">0x1021</span>, <span class="number">0x2042</span>, <span class="number">0x3063</span>,</span><br><span class="line">            <span class="number">0x4084</span>, <span class="number">0x50A5</span>, <span class="number">0x60C6</span>, <span class="number">0x70E7</span>, <span class="number">0x8108</span>, <span class="number">0x9129</span>, <span class="number">0xA14A</span>, <span class="number">0xB16B</span>,</span><br><span class="line">            <span class="number">0xC18C</span>, <span class="number">0xD1AD</span>, <span class="number">0xE1CE</span>, <span class="number">0xF1EF</span>, <span class="number">0x1231</span>, <span class="number">0x0210</span>, <span class="number">0x3273</span>, <span class="number">0x2252</span>,</span><br><span class="line">            <span class="number">0x52B5</span>, <span class="number">0x4294</span>, <span class="number">0x72F7</span>, <span class="number">0x62D6</span>, <span class="number">0x9339</span>, <span class="number">0x8318</span>, <span class="number">0xB37B</span>, <span class="number">0xA35A</span>,</span><br><span class="line">            <span class="number">0xD3BD</span>, <span class="number">0xC39C</span>, <span class="number">0xF3FF</span>, <span class="number">0xE3DE</span>, <span class="number">0x2462</span>, <span class="number">0x3443</span>, <span class="number">0x0420</span>, <span class="number">0x1401</span>,</span><br><span class="line">            <span class="number">0x64E6</span>, <span class="number">0x74C7</span>, <span class="number">0x44A4</span>, <span class="number">0x5485</span>, <span class="number">0xA56A</span>, <span class="number">0xB54B</span>, <span class="number">0x8528</span>, <span class="number">0x9509</span>,</span><br><span class="line">            <span class="number">0xE5EE</span>, <span class="number">0xF5CF</span>, <span class="number">0xC5AC</span>, <span class="number">0xD58D</span>, <span class="number">0x3653</span>, <span class="number">0x2672</span>, <span class="number">0x1611</span>, <span class="number">0x0630</span>,</span><br><span class="line">            <span class="number">0x76D7</span>, <span class="number">0x66F6</span>, <span class="number">0x5695</span>, <span class="number">0x46B4</span>, <span class="number">0xB75B</span>, <span class="number">0xA77A</span>, <span class="number">0x9719</span>, <span class="number">0x8738</span>,</span><br><span class="line">            <span class="number">0xF7DF</span>, <span class="number">0xE7FE</span>, <span class="number">0xD79D</span>, <span class="number">0xC7BC</span>, <span class="number">0x48C4</span>, <span class="number">0x58E5</span>, <span class="number">0x6886</span>, <span class="number">0x78A7</span>,</span><br><span class="line">            <span class="number">0x0840</span>, <span class="number">0x1861</span>, <span class="number">0x2802</span>, <span class="number">0x3823</span>, <span class="number">0xC9CC</span>, <span class="number">0xD9ED</span>, <span class="number">0xE98E</span>, <span class="number">0xF9AF</span>,</span><br><span class="line">            <span class="number">0x8948</span>, <span class="number">0x9969</span>, <span class="number">0xA90A</span>, <span class="number">0xB92B</span>, <span class="number">0x5AF5</span>, <span class="number">0x4AD4</span>, <span class="number">0x7AB7</span>, <span class="number">0x6A96</span>,</span><br><span class="line">            <span class="number">0x1A71</span>, <span class="number">0x0A50</span>, <span class="number">0x3A33</span>, <span class="number">0x2A12</span>, <span class="number">0xDBFD</span>, <span class="number">0xCBDC</span>, <span class="number">0xFBBF</span>, <span class="number">0xEB9E</span>,</span><br><span class="line">            <span class="number">0x9B79</span>, <span class="number">0x8B58</span>, <span class="number">0xBB3B</span>, <span class="number">0xAB1A</span>, <span class="number">0x6CA6</span>, <span class="number">0x7C87</span>, <span class="number">0x4CE4</span>, <span class="number">0x5CC5</span>,</span><br><span class="line">            <span class="number">0x2C22</span>, <span class="number">0x3C03</span>, <span class="number">0x0C60</span>, <span class="number">0x1C41</span>, <span class="number">0xEDAE</span>, <span class="number">0xFD8F</span>, <span class="number">0xCDEC</span>, <span class="number">0xDDCD</span>,</span><br><span class="line">            <span class="number">0xAD2A</span>, <span class="number">0xBD0B</span>, <span class="number">0x8D68</span>, <span class="number">0x9D49</span>, <span class="number">0x7E97</span>, <span class="number">0x6EB6</span>, <span class="number">0x5ED5</span>, <span class="number">0x4EF4</span>,</span><br><span class="line">            <span class="number">0x3E13</span>, <span class="number">0x2E32</span>, <span class="number">0x1E51</span>, <span class="number">0x0E70</span>, <span class="number">0xFF9F</span>, <span class="number">0xEFBE</span>, <span class="number">0xDFDD</span>, <span class="number">0xCFFC</span>,</span><br><span class="line">            <span class="number">0xBF1B</span>, <span class="number">0xAF3A</span>, <span class="number">0x9F59</span>, <span class="number">0x8F78</span>, <span class="number">0x9188</span>, <span class="number">0x81A9</span>, <span class="number">0xB1CA</span>, <span class="number">0xA1EB</span>,</span><br><span class="line">            <span class="number">0xD10C</span>, <span class="number">0xC12D</span>, <span class="number">0xF14E</span>, <span class="number">0xE16F</span>, <span class="number">0x1080</span>, <span class="number">0x00A1</span>, <span class="number">0x30C2</span>, <span class="number">0x20E3</span>,</span><br><span class="line">            <span class="number">0x5004</span>, <span class="number">0x4025</span>, <span class="number">0x7046</span>, <span class="number">0x6067</span>, <span class="number">0x83B9</span>, <span class="number">0x9398</span>, <span class="number">0xA3FB</span>, <span class="number">0xB3DA</span>,</span><br><span class="line">            <span class="number">0xC33D</span>, <span class="number">0xD31C</span>, <span class="number">0xE37F</span>, <span class="number">0xF35E</span>, <span class="number">0x02B1</span>, <span class="number">0x1290</span>, <span class="number">0x22F3</span>, <span class="number">0x32D2</span>,</span><br><span class="line">            <span class="number">0x4235</span>, <span class="number">0x5214</span>, <span class="number">0x6277</span>, <span class="number">0x7256</span>, <span class="number">0xB5EA</span>, <span class="number">0xA5CB</span>, <span class="number">0x95A8</span>, <span class="number">0x8589</span>,</span><br><span class="line">            <span class="number">0xF56E</span>, <span class="number">0xE54F</span>, <span class="number">0xD52C</span>, <span class="number">0xC50D</span>, <span class="number">0x34E2</span>, <span class="number">0x24C3</span>, <span class="number">0x14A0</span>, <span class="number">0x0481</span>,</span><br><span class="line">            <span class="number">0x7466</span>, <span class="number">0x6447</span>, <span class="number">0x5424</span>, <span class="number">0x4405</span>, <span class="number">0xA7DB</span>, <span class="number">0xB7FA</span>, <span class="number">0x8799</span>, <span class="number">0x97B8</span>,</span><br><span class="line">            <span class="number">0xE75F</span>, <span class="number">0xF77E</span>, <span class="number">0xC71D</span>, <span class="number">0xD73C</span>, <span class="number">0x26D3</span>, <span class="number">0x36F2</span>, <span class="number">0x0691</span>, <span class="number">0x16B0</span>,</span><br><span class="line">            <span class="number">0x6657</span>, <span class="number">0x7676</span>, <span class="number">0x4615</span>, <span class="number">0x5634</span>, <span class="number">0xD94C</span>, <span class="number">0xC96D</span>, <span class="number">0xF90E</span>, <span class="number">0xE92F</span>,</span><br><span class="line">            <span class="number">0x99C8</span>, <span class="number">0x89E9</span>, <span class="number">0xB98A</span>, <span class="number">0xA9AB</span>, <span class="number">0x5844</span>, <span class="number">0x4865</span>, <span class="number">0x7806</span>, <span class="number">0x6827</span>,</span><br><span class="line">            <span class="number">0x18C0</span>, <span class="number">0x08E1</span>, <span class="number">0x3882</span>, <span class="number">0x28A3</span>, <span class="number">0xCB7D</span>, <span class="number">0xDB5C</span>, <span class="number">0xEB3F</span>, <span class="number">0xFB1E</span>,</span><br><span class="line">            <span class="number">0x8BF9</span>, <span class="number">0x9BD8</span>, <span class="number">0xABBB</span>, <span class="number">0xBB9A</span>, <span class="number">0x4A75</span>, <span class="number">0x5A54</span>, <span class="number">0x6A37</span>, <span class="number">0x7A16</span>,</span><br><span class="line">            <span class="number">0x0AF1</span>, <span class="number">0x1AD0</span>, <span class="number">0x2AB3</span>, <span class="number">0x3A92</span>, <span class="number">0xFD2E</span>, <span class="number">0xED0F</span>, <span class="number">0xDD6C</span>, <span class="number">0xCD4D</span>,</span><br><span class="line">            <span class="number">0xBDAA</span>, <span class="number">0xAD8B</span>, <span class="number">0x9DE8</span>, <span class="number">0x8DC9</span>, <span class="number">0x7C26</span>, <span class="number">0x6C07</span>, <span class="number">0x5C64</span>, <span class="number">0x4C45</span>,</span><br><span class="line">            <span class="number">0x3CA2</span>, <span class="number">0x2C83</span>, <span class="number">0x1CE0</span>, <span class="number">0x0CC1</span>, <span class="number">0xEF1F</span>, <span class="number">0xFF3E</span>, <span class="number">0xCF5D</span>, <span class="number">0xDF7C</span>,</span><br><span class="line">            <span class="number">0xAF9B</span>, <span class="number">0xBFBA</span>, <span class="number">0x8FD9</span>, <span class="number">0x9FF8</span>, <span class="number">0x6E17</span>, <span class="number">0x7E36</span>, <span class="number">0x4E55</span>, <span class="number">0x5E74</span>,</span><br><span class="line">            <span class="number">0x2E93</span>, <span class="number">0x3EB2</span>, <span class="number">0x0ED1</span>, <span class="number">0x1EF0</span>,&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create a CRC16 checksum from the bytes. implementation is from</span></span><br><span class="line"><span class="comment">     * mp911de/lettuce, modified with some more optimizations</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> CRC16 as integer value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getCRC16</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> crc = <span class="number">0x0000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> b : bytes) &#123;</span><br><span class="line">            crc = ((crc &lt;&lt; <span class="number">8</span>) ^ LOOKUP_TABLE[((crc &gt;&gt;&gt; <span class="number">8</span>) ^ (b &amp; <span class="number">0xFF</span>)) &amp; <span class="number">0xFF</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> crc &amp; <span class="number">0xFFFF</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getCRC16</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getCRC16(key.getBytes(Charset.forName(<span class="string">"UTF-8"</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHashCode</span><span class="params">(String origin)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// optimization with modulo operator with power of 2</span></span><br><span class="line">        <span class="comment">// equivalent to getCRC16(key) % 16384</span></span><br><span class="line">        <span class="keyword">return</span> getCRC16(origin) &amp; (<span class="number">16384</span> - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3）FNV1_32 算法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FnvHashStrategy</span> <span class="keyword">implements</span> <span class="title">HashStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> FNV_32_INIT = <span class="number">2166136261L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FNV_32_PRIME = <span class="number">16777619</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHashCode</span><span class="params">(String origin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> p = FNV_32_PRIME;</span><br><span class="line">        <span class="keyword">int</span> hash = (<span class="keyword">int</span>) FNV_32_INIT;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; origin.length(); i++)</span><br><span class="line">            hash = (hash ^ origin.charAt(i)) * p;</span><br><span class="line">        hash += hash &lt;&lt; <span class="number">13</span>;</span><br><span class="line">        hash ^= hash &gt;&gt; <span class="number">7</span>;</span><br><span class="line">        hash += hash &lt;&lt; <span class="number">3</span>;</span><br><span class="line">        hash ^= hash &gt;&gt; <span class="number">17</span>;</span><br><span class="line">        hash += hash &lt;&lt; <span class="number">5</span>;</span><br><span class="line">        hash = Math.abs(hash);</span><br><span class="line">        <span class="keyword">return</span> hash;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>4）MurmurHash 算法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MurmurHashStrategy</span> <span class="keyword">implements</span> <span class="title">HashStrategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHashCode</span><span class="params">(String origin)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ByteBuffer buf = ByteBuffer.wrap(origin.getBytes());</span><br><span class="line">        <span class="keyword">int</span> seed = <span class="number">0x1234ABCD</span>;</span><br><span class="line"></span><br><span class="line">        ByteOrder byteOrder = buf.order();</span><br><span class="line">        buf.order(ByteOrder.LITTLE_ENDIAN);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> m = <span class="number">0xc6a4a7935bd1e995L</span>;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">47</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> h = seed ^ (buf.remaining() * m);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> k;</span><br><span class="line">        <span class="keyword">while</span> (buf.remaining() &gt;= <span class="number">8</span>) &#123;</span><br><span class="line">            k = buf.getLong();</span><br><span class="line"></span><br><span class="line">            k *= m;</span><br><span class="line">            k ^= k &gt;&gt;&gt; r;</span><br><span class="line">            k *= m;</span><br><span class="line"></span><br><span class="line">            h ^= k;</span><br><span class="line">            h *= m;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (buf.remaining() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ByteBuffer finish = ByteBuffer.allocate(<span class="number">8</span>).order(</span><br><span class="line">                    ByteOrder.LITTLE_ENDIAN);</span><br><span class="line">            <span class="comment">// for big-endian version, do this first:</span></span><br><span class="line">            <span class="comment">// finish.position(8-buf.remaining());</span></span><br><span class="line">            finish.put(buf).rewind();</span><br><span class="line">            h ^= finish.getLong();</span><br><span class="line">            h *= m;</span><br><span class="line">        &#125;</span><br><span class="line">        h ^= h &gt;&gt;&gt; r;</span><br><span class="line">        h *= m;</span><br><span class="line">        h ^= h &gt;&gt;&gt; r;</span><br><span class="line"></span><br><span class="line">        buf.order(byteOrder);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) (h &amp; <span class="number">0xffffffffL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>5）Ketama 算法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KetamaHashStrategy</span> <span class="keyword">implements</span> <span class="title">HashStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MessageDigest md5Digest;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            md5Digest = MessageDigest.getInstance(<span class="string">"MD5"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"MD5 not supported"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHashCode</span><span class="params">(String origin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bKey = computeMd5(origin);</span><br><span class="line">        <span class="keyword">long</span> rv = ((<span class="keyword">long</span>) (bKey[<span class="number">3</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">24</span>)</span><br><span class="line">                | ((<span class="keyword">long</span>) (bKey[<span class="number">2</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">16</span>)</span><br><span class="line">                | ((<span class="keyword">long</span>) (bKey[<span class="number">1</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">8</span>)</span><br><span class="line">                | (bKey[<span class="number">0</span>] &amp; <span class="number">0xFF</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) (rv &amp; <span class="number">0xffffffffL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the md5 of the given key.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] computeMd5(String k) &#123;</span><br><span class="line">        MessageDigest md5;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            md5 = (MessageDigest) md5Digest.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"clone of MD5 not supported"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        md5.update(k.getBytes());</span><br><span class="line">        <span class="keyword">return</span> md5.digest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>相对来说，在一致性哈希算法中，FNV，MurmurHash及Ketama是相对较好的算法，用的场景也较多。</p>
<h2 id="3-算法分析"><a href="#3-算法分析" class="headerlink" title="3. 算法分析"></a>3. 算法分析</h2><p>在一致性算法中，需要将哈希值空间组织成一个虚拟的哈希环，服务器结点的哈希值放置在该哈希环上，查找离请求key的哈希值最近的值。在这里提到要构建一个哈希环，它的底层数据结构是什么样的？我们可以转换一个思路，在算法中，最重要的环节是匹配两个最近的哈希值，是否可以将服务器的哈希值存储到一个有序的数据列表中，匹配的操作就是找一个小于等待key的最大值。为了提高查询效率，底层的数据结构一般使用红黑树。下面分析一致性哈希算法的一种可能实现，该算法由作者<a href="https://www.cnkirito.moe/consistent-hash-lb/" target="_blank" rel="noopener">徐靖峰</a>实现，代码的github地址：<a href="https://github.com/lexburner/consistent-hash-algorithm" target="_blank" rel="noopener">https://github.com/lexburner/consistent-hash-algorithm</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsistentHashLoadBalancer</span> <span class="keyword">implements</span> <span class="title">LoadBalancer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  使用的哈希算法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> HashStrategy hashStrategy = <span class="keyword">new</span> FnvHashStrategy();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  虚拟结点的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> VIRTUAL_NODE_SIZE = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  服务器与虚拟结点的连接符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String VIRTUAL_NODE_SUFFIX = <span class="string">"&amp;&amp;"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据请求匹配服务器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> servers 服务器数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocation 封装了调用的请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回匹配的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Server <span class="title">select</span><span class="params">(List&lt;Server&gt; servers, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> invocationHashCode = hashStrategy.getHashCode(invocation.getHashKey());</span><br><span class="line">        TreeMap&lt;Integer, Server&gt; ring = buildConsistentHashRing(servers);</span><br><span class="line">        Server server = locate(ring, invocationHashCode);</span><br><span class="line">        <span class="keyword">return</span> server;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从TreeMap中找出高key最近的服务器，如果没有服务器匹配，</span></span><br><span class="line"><span class="comment">     * 则返回第一值，形成一个环</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ring 存储服务器结点的哈希</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocationHashCode 封装了调用的请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Server <span class="title">locate</span><span class="params">(TreeMap&lt;Integer, Server&gt; ring, <span class="keyword">int</span> invocationHashCode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 向右找到第一个 key</span></span><br><span class="line">        Map.Entry&lt;Integer, Server&gt; locateEntry = ring.ceilingEntry(invocationHashCode);</span><br><span class="line">        <span class="keyword">if</span> (locateEntry == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 想象成一个环，超过尾部则取第一个 key</span></span><br><span class="line">            locateEntry = ring.firstEntry();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> locateEntry.getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建一个带虚拟结点的哈希环，使用TreeMap结构，底层是红黑树，</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> servers 服务器数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回服务器数组的哈希环</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeMap&lt;Integer, Server&gt; <span class="title">buildConsistentHashRing</span><span class="params">(List&lt;Server&gt; servers)</span> </span>&#123;</span><br><span class="line">        TreeMap&lt;Integer, Server&gt; virtualNodeRing = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Server server : servers) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; VIRTUAL_NODE_SIZE; i++) &#123;</span><br><span class="line">                <span class="comment">// 新增虚拟节点的方式如果有影响，也可以抽象出一个由物理节点扩展虚拟节点的类</span></span><br><span class="line">                virtualNodeRing.put(hashStrategy.getHashCode(server.getUrl() + VIRTUAL_NODE_SUFFIX + i), server);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> virtualNodeRing;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在该算法中，使用TreeMap的ceilingEntry方法返回离key的哈希值最近的服务器。</p>
<p>除了上面的一致性哈希算法的实现，还有一种实现，即Ketama算法，它不仅仅是一个哈希算法，更是一套完整的一致性哈希算法，在memcached中，其介绍如下：</p>
<blockquote>
<p>Ketama is an implementation of a consistent hashing algorithm, meaning you can add or remove servers from the memcached pool without causing a complete remap of all keys.<br>Here’s how it works:</p>
<ul>
<li>Take your list of servers (eg: 1.2.3.4:11211, 5.6.7.8:11211, 9.8.7.6:11211)</li>
<li>Hash each server string to several (100-200) unsigned ints</li>
<li>Conceptually, these numbers are placed on a circle called the continuum. (imagine a clock face that goes from 0 to 2^32)</li>
<li>Each number links to the server it was hashed from, so servers appear at several points on the continuum, by each of the numbers they hashed to.</li>
<li>To map a key-&gt;server, hash your key to a single unsigned int, and find the next biggest number on the continuum. The server linked to that number is the correct server for that key.</li>
<li>If you hash your key to a value near 2^32 and there are no points on the continuum greater than your hash, return the first server in the continuum.<br>If you then add or remove a server from the list, only a small proportion of keys end up mapping to different servers.</li>
</ul>
</blockquote>
<p>代码实现如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KetamaConsistentHashLoadBalancer</span> <span class="keyword">implements</span> <span class="title">LoadBalancer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MessageDigest md5Digest;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            md5Digest = MessageDigest.getInstance(<span class="string">"MD5"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"MD5 not supported"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  虚拟结点的个数，虚拟结点一般以4个为一组计算，所以数量一般同4的倍数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> VIRTUAL_NODE_SIZE = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  服务器与虚拟结点的连接符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String VIRTUAL_NODE_SUFFIX = <span class="string">"-"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据请求匹配服务器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> servers 服务器数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocation 封装了调用的请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回匹配的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Server <span class="title">select</span><span class="params">(List&lt;Server&gt; servers, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> invocationHashCode = getHashCode(invocation.getHashKey());</span><br><span class="line">        TreeMap&lt;Long, Server&gt; ring = buildConsistentHashRing(servers);</span><br><span class="line">        Server server = locate(ring, invocationHashCode);</span><br><span class="line">        <span class="keyword">return</span> server;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从TreeMap中找出高key最近的服务器，如果没有服务器匹配，</span></span><br><span class="line"><span class="comment">     * 则返回第一值，形成一个环</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ring 存储服务器结点的哈希</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocationHashCode 封装了调用的请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Server <span class="title">locate</span><span class="params">(TreeMap&lt;Long, Server&gt; ring, Long invocationHashCode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 向右找到第一个 key</span></span><br><span class="line">        Map.Entry&lt;Long, Server&gt; locateEntry = ring.ceilingEntry(invocationHashCode);</span><br><span class="line">        <span class="keyword">if</span> (locateEntry == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 想象成一个环，超过尾部则取第一个 key</span></span><br><span class="line">            locateEntry = ring.firstEntry();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> locateEntry.getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建一个带虚拟结点的哈希环，使用TreeMap结构，底层是红黑树，</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> servers 服务器数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回服务器数组的哈希环</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeMap&lt;Long, Server&gt; <span class="title">buildConsistentHashRing</span><span class="params">(List&lt;Server&gt; servers)</span> </span>&#123;</span><br><span class="line">        TreeMap&lt;Long, Server&gt; virtualNodeRing = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Server server : servers) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; VIRTUAL_NODE_SIZE / <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">byte</span>[] digest = computeMd5(server.getUrl() + VIRTUAL_NODE_SUFFIX + i);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; <span class="number">4</span>; h++) &#123;</span><br><span class="line">                    <span class="comment">// 将digest数组按4个byte为一组，通过位操作产生一个最大32位的长整数，</span></span><br><span class="line">                    <span class="comment">// 一个16 byte的MD5，可以生成4个哈希值，即4个虚拟结点，所以一般将虚拟结点按照</span></span><br><span class="line">                    <span class="comment">// 4个为一组进行计算。</span></span><br><span class="line">                    Long k = ((<span class="keyword">long</span>) (digest[<span class="number">3</span> + h * <span class="number">4</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">24</span>)</span><br><span class="line">                            | ((<span class="keyword">long</span>) (digest[<span class="number">2</span> + h * <span class="number">4</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">16</span>)</span><br><span class="line">                            | ((<span class="keyword">long</span>) (digest[<span class="number">1</span> + h * <span class="number">4</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">8</span>)</span><br><span class="line">                            | (digest[h * <span class="number">4</span>] &amp; <span class="number">0xFF</span>);</span><br><span class="line">                    virtualNodeRing.put(k, server);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> virtualNodeRing;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算字符串的Ketama哈希值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> origin key值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 哈希值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">getHashCode</span><span class="params">(String origin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bKey = computeMd5(origin);</span><br><span class="line">        <span class="comment">// 使用前4个字符进行位运算得到32位的整数。</span></span><br><span class="line">        <span class="keyword">long</span> rv = ((<span class="keyword">long</span>) (bKey[<span class="number">3</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">24</span>)</span><br><span class="line">                | ((<span class="keyword">long</span>) (bKey[<span class="number">2</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">16</span>)</span><br><span class="line">                | ((<span class="keyword">long</span>) (bKey[<span class="number">1</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">8</span>)</span><br><span class="line">                | (bKey[<span class="number">0</span>] &amp; <span class="number">0xFF</span>);</span><br><span class="line">        <span class="keyword">return</span> rv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key生成16位的MD5摘要，因此digest数组共16位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> MD5摘</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] computeMd5(String k) &#123;</span><br><span class="line">        MessageDigest md5;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            md5 = (MessageDigest) md5Digest.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"clone of MD5 not supported"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        md5.update(k.getBytes());</span><br><span class="line">        <span class="keyword">return</span> md5.digest();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>在Ketama一致性哈希算法中，以四个虚拟结点为一组，将服务器名称以Md5编码后，得到16个字节的编码，每个虚拟结点对应Md5码16个字节中的4个，组成一个long型数值，做为这个虚拟结点在环中的惟一key。请求key的哈希值则以Md5中的前4个字节计算得到。</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>在 <a href="https://www.cnblogs.com/xrq730/p/5186728.html" target="_blank" rel="noopener">对一致性Hash算法，Java代码实现的深入研究</a> 这篇文章中，作者通过数据分析，得出使用MurmurHash，FNV及Ketama这三种哈希算法，都能得到较好的性能，具有很好的参考意义。</p>
<p><strong>参考：</strong></p>
<hr>
<p><a href="https://www.oschina.net/translate/state-of-hash-functions" target="_blank" rel="noopener">1. Hash 函数概览</a></p>
<p><a href="https://www.cnkirito.moe/consistent-hash-lb/" target="_blank" rel="noopener">2. 一致性哈希负载均衡算法的探讨</a></p>
<p><a href="http://blog.codinglabs.org/articles/consistent-hashing.html" target="_blank" rel="noopener">3. 一致性哈希算法及其在分布式系统中的应用</a></p>
<p><a href="https://www.cnblogs.com/xrq730/p/5186728.html" target="_blank" rel="noopener">4. 对一致性Hash算法，Java代码实现的深入研究</a></p>
<p><a href="https://www.iteye.com/blog/langyu-684087" target="_blank" rel="noopener">5. Ketama一致性Hash算法(含Java代码)</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/16/skip-list/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/10/16/skip-list/" class="post-title-link" itemprop="http://yoursite.com/page/3/index.html">跳跃表</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-10-16 08:57:31" itemprop="dateCreated datePublished" datetime="2019-10-16T08:57:31+08:00">2019-10-16</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-07-31 17:17:10" itemprop="dateModified" datetime="2021-07-31T17:17:10+08:00">2021-07-31</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构与算法/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>跳跃表是一种数据结构。它允许快速查询一个有序连续元素的数据链表。跳跃表的平均查找和插入时间复杂度都是O(logn)，优于普通队列的O(n)。快速查询是通过维护一个多层次的链表，且每一层链表中的元素是前一层链表元素的子集。一开始时，算法在最稀疏的层次进行搜索，直至需要查找的元素在该层两个相邻的元素中间。这时，算法将跳转到下一个层次，重复刚才的搜索，直到找到需要查找的元素为止，跳跃表示意图如下所示。<br><img src="/images/skip-list.png" alt="skip-list" title="skip-list"><br>从图中可以看到， 跳跃表主要由以下部分构成：</p>
<ul>
<li>表头（head）：负责维护跳跃表的节点指针；</li>
<li>跳跃表节点：保存着元素值，以及多个层。</li>
<li>层：保存着指向其他元素的指针，高层的指针越过的元素数量大于等于低层的指针，为了提高查找的效率，程序总是从高层先开始访问，然后随着元素值范围的缩小，慢慢降低层次。</li>
<li>表尾：全部由 NULL 组成，表示跳跃表的末尾。</li>
</ul>
<p>本篇文章将以redis中的跳跃表为例进行介绍，代码用java进行了重写，为方便看懂，简化了部分流程。</p>
<h2 id="2-层数"><a href="#2-层数" class="headerlink" title="2. 层数"></a>2. 层数</h2><p>跳跃表是按照层构建的，每一层都是一个有序链表，最底层包含了所有的元素，每一个更高层都包含了指向下层的指针，也可以说高层是下层数据的“索引”。通过对高层数据的检索可以实现类似二分查找的效果，但是要准确判断出数据是否出现在高层通且对之前数据的层次进行调整是一个复杂的过程，要实现的算法可以参考AVL树和红黑树。在跳跃表中，通过概率的方式，近似得出数据的层数，简化操作。</p>
<p>每个更高层都充当下面列表的“快速通道”，在第i层中的元素按某个固定的概率p（通常为1/2或1/4出现在第i+1层），以Redis中的跳跃表为例：</p>
<blockquote>
<p>level 1的概率为 0.75<br>level 2的概率为 0.75 * 0.25<br>level 3的概率为 0.75 * 0.25 * 0.25<br>…<br>level 31的概率为 0.75 * 0.25^30<br>level 32的概率为 0.75 * 0.25^31</p>
</blockquote>
<p>代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">zslRandomLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((random.nextInt() &amp; <span class="number">0xFFFF</span>) &lt; (ZSKIPLIST_P * <span class="number">0xFFFF</span>)) &#123;</span><br><span class="line">        level += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (level &lt; ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中ZSKIPLIST_MAXLEVEL为32，ZSKIPLIST_P为0.25（即1/4）,random.nextInt() &amp; 0xFFFF为16位整数，ZSKIPLIST_P * 0xFFFF为16位整数的1/4。从概率学的角度来说，大于ZSKIPLIST_P * 0xFFFF的概率为3/4，即level 1的概率是0.75，level 2，概率是0.75 * 0.25，后面的层次依次类推。</p>
<p>在介绍跳跃表的插入和删除之前，先看下跳跃表的数据结构（参考redis的实现进行了简化）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZSkipList</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;? <span class="title">super</span> <span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最大层数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ZSKIPLIST_MAXLEVEL = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// P，概率</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> ZSKIPLIST_P = <span class="number">0.25</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 头结点</span></span><br><span class="line">    <span class="keyword">private</span> ZSkipListNode&lt;T&gt; header;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点总数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 层数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> level;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机数</span></span><br><span class="line">    <span class="keyword">private</span> Random random;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ZSkipList</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.level = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        ZSkipListNode&lt;T&gt; nullNode = <span class="keyword">new</span> ZSkipListNode&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.header = <span class="keyword">new</span> ZSkipListNode&lt;&gt;(<span class="keyword">null</span>, ZSKIPLIST_MAXLEVEL);</span><br><span class="line"></span><br><span class="line">        random = <span class="keyword">new</span> Random();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  结点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ZSkipListNode</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;? <span class="title">super</span> <span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 键值</span></span><br><span class="line">        T key;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 层次</span></span><br><span class="line">        ZSkipListLevel&lt;T&gt;[] levels;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ZSkipListNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ZSkipListNode</span><span class="params">(T key, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.levels = <span class="keyword">new</span> ZSkipListLevel[level];</span><br><span class="line"></span><br><span class="line">            ZSkipListLevel&lt;T&gt; listLevel = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; level ; i++) &#123;</span><br><span class="line">                listLevel = <span class="keyword">new</span> ZSkipListLevel&lt;&gt;();</span><br><span class="line">                <span class="keyword">this</span>.levels[i] = listLevel;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  层</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ZSkipListLevel</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;? <span class="title">super</span> <span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下一个结点</span></span><br><span class="line">        ZSkipListNode&lt;T&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跨度，当前结点与后继结点蹭相隔几个结点</span></span><br><span class="line">        <span class="keyword">int</span> span;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ZSkipListLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.span = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-插入"><a href="#3-插入" class="headerlink" title="3. 插入"></a>3. 插入</h2><p>插入操作的步骤：</p>
<ul>
<li>1）找出插入结点每一层的前驱结点及排名；</li>
<li>2）随机生成插入结点的层数；</li>
<li>3）在每一层链表中插入结点，修改结点跨度；</li>
<li>4）更新结点数。</li>
</ul>
<p>代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向跳跃表中插入结点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 插入元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Preconditions.checkNotNull(key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// update存放插入结点每一层的前驱结点，</span></span><br><span class="line">    ZSkipListNode&lt;T&gt;[] update = <span class="keyword">new</span> ZSkipListNode[ZSKIPLIST_MAXLEVEL];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rank存放结点在每一层上的排名</span></span><br><span class="line">    <span class="keyword">int</span> [] rank = <span class="keyword">new</span> <span class="keyword">int</span>[ZSKIPLIST_MAXLEVEL];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于遍历插入结点的位置</span></span><br><span class="line">    ZSkipListNode&lt;T&gt; creeper = header;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *   1、找到每一个层次的前驱结点及每一个层次的排名。</span></span><br><span class="line"><span class="comment">     *  从最顶层开始遍历,从上往下查的插入结点的位置,如果在该层中结点大于插入结点的值,</span></span><br><span class="line"><span class="comment">     *  则移向该结点的下一层开始查找,同时记录插入结点的排名,用于计算插入结点与前一个</span></span><br><span class="line"><span class="comment">     *  结点之间的跨度(span).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用于插入结点在某一个层次的排名,在最高层排名默认值为0;</span></span><br><span class="line">        <span class="comment">// 非最高层默认值上一个层次的值,会在下面的循环中依次增加排名.</span></span><br><span class="line">        rank[i] = i == level-<span class="number">1</span> ? <span class="number">0</span> : rank[i+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前结点小于等于插入结点,则继续查找.</span></span><br><span class="line">        <span class="keyword">while</span> (creeper.levels[i].next != <span class="keyword">null</span> &amp;&amp; key.compareTo(creeper.levels[i].next.key) &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 排名数加上当前结点到一个结点之间的跨度</span></span><br><span class="line">            rank[i] += creeper.levels[i].span;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 指向后继结点</span></span><br><span class="line">            creeper = creeper.levels[i].next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到当前层次中后继结点大于等于插入结点的结点,作为插入结点的前驱结点</span></span><br><span class="line">        update[i] = creeper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、随机生成插入结点的层次</span></span><br><span class="line">    <span class="comment">// 用冥次定律,生成一个随机的层次</span></span><br><span class="line">    <span class="keyword">int</span> newLevel = zslRandomLevel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果生成的层次大于当前跳跃表的最大层次,则初始化大于的层次.</span></span><br><span class="line">    <span class="keyword">if</span> (newLevel &gt; level) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = level ; i &lt; newLevel ; i++) &#123;</span><br><span class="line">            rank[i] = <span class="number">0</span>;</span><br><span class="line">            update[i] = header;</span><br><span class="line">            update[i].levels[i].span = <span class="keyword">this</span>.length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.level = newLevel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//System.out.println("newLevel = " + newLevel + " ; key=" + key);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新建插入的结点</span></span><br><span class="line">    ZSkipListNode&lt;T&gt; node = <span class="keyword">new</span> ZSkipListNode&lt;&gt;(key, level);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *  3、插入结点及更新跨度</span></span><br><span class="line"><span class="comment">    *  1）在每一个层次中插入一个结点，该操作就是链表的插入操作，比较简单；</span></span><br><span class="line"><span class="comment">    *  2）更新产驱结点及当前结点的跨度。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; newLevel; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.1 插入结点的后继结点指向前驱结点的后继结点；</span></span><br><span class="line">        <span class="comment">// 3.2 前驱结点的后继结点指向插入结点。</span></span><br><span class="line">        node.levels[i].next = update[i].levels[i].next;</span><br><span class="line">        update[i].levels[i].next = node;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 插入一个新结点，等于在前驱结点与其后继结点之间插入一个结点，之前的</span></span><br><span class="line"><span class="comment">        *  span等于前驱结点与其后继结点之间的跨度，现在一分为二：前驱结点与插入结点的跨度和</span></span><br><span class="line"><span class="comment">        *  插入结点与后继结点的跨度。前一个值即为前驱结点的跨度，等于上下两个层次排名的差值，</span></span><br><span class="line"><span class="comment">        *  后一个值即为插入结点的跨度，等于前驱结点原先的span减去前一个值。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        node.levels[i].span = update[i].levels[i].span - (rank[<span class="number">0</span>] - rank[i]);</span><br><span class="line">        update[i].levels[i].span = (rank[<span class="number">0</span>] - rank[i]) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果插入结点的层次小于当前最大的层数，则更新高层的spsn。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = newLevel; i &lt; <span class="keyword">this</span>.level; i++) &#123;</span><br><span class="line">        update[i].levels[i].span++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 结点数加1.</span></span><br><span class="line">    <span class="keyword">this</span>.length++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以插入12, 45, 63, 21, 99, 87, 23, 47, 30, 50数组为例，分析插入结点的流程，图形的格式说明：head[00](01)–&gt;12(00)，定义为head[层数](跨度,当前结点与下一个结点之间相隔结点数)–&gt;下一个结点(跨度)。</p>
<ul>
<li><p>1）插入12，层数为1，当前只有一层，12为最底层的第一个结点，头结点到12中间的跨度为1（包括12在内）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new node = 12, level = 1</span><br><span class="line"></span><br><span class="line">head[00](01)--&gt;12(00)</span><br></pre></td></tr></table></figure>
</li>
<li><p>2）插入45，层数为2，跳跃表新增一层，在两层中插入45，其中第二层头结点到45结点的跨度为2（包括45在内）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new node = 45, level = 2 </span><br><span class="line"></span><br><span class="line">head[01](02)-----------&gt;45(00)</span><br><span class="line">head[00](01)--&gt;12(01)--&gt;45(00)</span><br></pre></td></tr></table></figure>
</li>
<li><p>3）插入63，层数为1，只插入到第一层。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new node = 63, level = 1 </span><br><span class="line"></span><br><span class="line">head[01](02)-----------&gt;45(01)</span><br><span class="line">head[00](01)--&gt;12(01)--&gt;45(01)--&gt;63(00)</span><br></pre></td></tr></table></figure>
</li>
<li><p>4）插入21，层数为2。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new node = 21, level = 2 </span><br><span class="line"></span><br><span class="line">head[01](02)-----------&gt;21(01)--&gt;45(01)</span><br><span class="line">head[00](01)--&gt;12(01)--&gt;21(01)--&gt;45(01)--&gt;63(00)</span><br></pre></td></tr></table></figure>
</li>
<li><p>5）插入99，层数为1。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new node = 99, level = 1 </span><br><span class="line"></span><br><span class="line">head[01](02)-----------&gt;21(01)--&gt;45(02)</span><br><span class="line">head[00](01)--&gt;12(01)--&gt;21(01)--&gt;45(01)--&gt;63(01)--&gt;99(00)</span><br></pre></td></tr></table></figure>
</li>
<li><p>6）插入87，层数为1。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new node = 87, level = 1 </span><br><span class="line"></span><br><span class="line">head[01](02)-----------&gt;21(01)--&gt;45(03)</span><br><span class="line">head[00](01)--&gt;12(01)--&gt;21(01)--&gt;45(01)--&gt;63(01)--&gt;87(01)--&gt;99(00)</span><br></pre></td></tr></table></figure>
</li>
<li><p>7）插入23，层数为1。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new node = 23, level = 1 </span><br><span class="line"></span><br><span class="line">head[01](02)-----------&gt;21(02)-----------&gt;45(03)</span><br><span class="line">head[00](01)--&gt;12(01)--&gt;21(01)--&gt;23(01)--&gt;45(01)--&gt;63(01)--&gt;87(01)--&gt;99(00)</span><br></pre></td></tr></table></figure>
</li>
<li><p>8）插入47，层数为2。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new node = 47, level = 2 </span><br><span class="line"></span><br><span class="line">head[01](02)-----------&gt;21(02)-----------&gt;45(01)--&gt;47(03)</span><br><span class="line">head[00](01)--&gt;12(01)--&gt;21(01)--&gt;23(01)--&gt;45(01)--&gt;47(01)--&gt;63(01)--&gt;87(01)--&gt;99(00)</span><br></pre></td></tr></table></figure>
</li>
<li><p>9）插入30，层数为1。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new node = 30, level = 1 </span><br><span class="line"></span><br><span class="line">head[01](02)-----------&gt;21(03)--------------------&gt;45(01)--&gt;47(03)</span><br><span class="line">head[00](01)--&gt;12(01)--&gt;21(01)--&gt;23(01)--&gt;30(01)--&gt;45(01)--&gt;47(01)--&gt;63(01)--&gt;87(01)--&gt;99(00)</span><br></pre></td></tr></table></figure>
</li>
<li><p>10）插入87，层数为4。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new node = 50, level = 4 </span><br><span class="line"></span><br><span class="line">head[03](07)--------------------------------------------------------&gt;50(03)</span><br><span class="line">head[02](07)--------------------------------------------------------&gt;50(03)</span><br><span class="line">head[01](02)-----------&gt;21(03)--------------------&gt;45(01)--&gt;47(01)--&gt;50(03)</span><br><span class="line">head[00](01)--&gt;12(01)--&gt;21(01)--&gt;23(01)--&gt;30(01)--&gt;45(01)--&gt;47(01)--&gt;50(01)--&gt;63(01)--&gt;87(01)--&gt;99(00)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="4-删除"><a href="#4-删除" class="headerlink" title="4. 删除"></a>4. 删除</h2><p>删除操作的步骤为：</p>
<ul>
<li>1）找出删除结点每一层的前驱结点；</li>
<li>2）将前驱结点的后继结点指向删除指点的后继结点，并修改前驱结点的跨度；</li>
<li>3）删除空的层并对结点数减一。</li>
</ul>
<p>跳跃表的删除实际就是单向链表的删除，其代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除一个已有结点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、找到key对应的结点</span></span><br><span class="line">    Preconditions.checkNotNull(key);</span><br><span class="line"></span><br><span class="line">    ZSkipListNode&lt;T&gt;[] update = <span class="keyword">new</span> ZSkipListNode[ZSKIPLIST_MAXLEVEL];</span><br><span class="line">    <span class="comment">// 获取前驱结点</span></span><br><span class="line">    predecessorLevels(key, update);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一层的后继结点有可能是删除的结点(有可能删除一个不存在的结点)</span></span><br><span class="line">    ZSkipListNode&lt;T&gt; node = update[<span class="number">0</span>].levels[<span class="number">0</span>].next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否是删除的结点</span></span><br><span class="line">    <span class="keyword">if</span> (key.compareTo(node.key) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.level; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (update[i].levels[i].next == node) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 前驱结点的跨度等于之前的跨度再加上删除结点的跨度,再减去删除结点.</span></span><br><span class="line">                update[i].levels[i].span += node.levels[i].span -<span class="number">1</span>;</span><br><span class="line">                update[i].levels[i].next = node.levels[i].next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                update[i].levels[i].span -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清理空的层</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">this</span>.level &gt; <span class="number">1</span> &amp;&amp; <span class="keyword">this</span>.header.levels[<span class="keyword">this</span>.level-<span class="number">1</span>].next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.level--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 结点数减一</span></span><br><span class="line">        <span class="keyword">this</span>.length--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取每一层的前驱结点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> update</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">predecessorLevels</span><span class="params">(T key, ZSkipListNode&lt;T&gt;[] update)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ZSkipListNode&lt;T&gt; creeper = header;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (creeper.levels[i].next != <span class="keyword">null</span> &amp;&amp; key.compareTo(creeper.levels[i].next.key) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            creeper = creeper.levels[i].next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        update[i] = creeper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>删除实例如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">删除前的跳跃表：</span><br><span class="line">head[03](04)-----------------------------&gt;30(06)</span><br><span class="line">head[02](04)-----------------------------&gt;30(05)--------------------------------------&gt;87(01)</span><br><span class="line">head[01](01)--&gt;12(01)--&gt;21(02)-----------&gt;30(05)--------------------------------------&gt;87(01)</span><br><span class="line">head[00](01)--&gt;12(01)--&gt;21(01)--&gt;23(01)--&gt;30(01)--&gt;45(01)--&gt;47(01)--&gt;50(01)--&gt;63(01)--&gt;87(01)--&gt;99(00)</span><br><span class="line"></span><br><span class="line">删除30后的跳跃表：</span><br><span class="line">head[02](08)-----------------------------------------------------------------&gt;87(01)</span><br><span class="line">head[01](01)--&gt;12(01)--&gt;21(06)-----------------------------------------------&gt;87(01)</span><br><span class="line">head[00](01)--&gt;12(01)--&gt;21(01)--&gt;23(01)--&gt;45(01)--&gt;47(01)--&gt;50(01)--&gt;63(01)--&gt;87(01)--&gt;99(00)</span><br></pre></td></tr></table></figure></p>
<p>在每一层的链表中都会删除30这个结点，同时更新前驱结点的跨度。因为第4层只有30这个结点，删除之后，该层没有结点，就要减少跳跃表的层数。</p>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>跳跃表的发明者对其的评价：</p>
<blockquote>
<p>跳跃列表是在很多应用中有可能替代平衡树而作为实现方法的一种数据结构。跳跃列表的算法有同平衡树一样的渐进的预期时间边界，并且更简单、更快速和使用更少的空间</p>
</blockquote>
<p>跳跃表相对平衡二叉树而言，实现简单，又能在近似O(logn)时间复杂度的情况下实现数据的检索和插入，这或许也是在redis中使用跳跃表代替红黑树的原因之一。</p>
<p><strong>参考：</strong></p>
<hr>
<p><a href="https://zh.wikipedia.org/wiki/%E8%B7%B3%E8%B7%83%E5%88%97%E8%A1%A8" target="_blank" rel="noopener">1. 跳跃列表</a></p>
<p><a href="https://www.jianshu.com/p/58bab10b7ab9" target="_blank" rel="noopener">2. Redis 源码研究之skiplist</a></p>
<p><a href="http://download.redis.io/redis-stable/src/t_zset.c" target="_blank" rel="noopener">3. redis源码</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/11/red-black-tree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/10/11/red-black-tree/" class="post-title-link" itemprop="http://yoursite.com/page/3/index.html">红黑树</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-10-11 09:58:08" itemprop="dateCreated datePublished" datetime="2019-10-11T09:58:08+08:00">2019-10-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-07-31 17:17:10" itemprop="dateModified" datetime="2021-07-31T17:17:10+08:00">2021-07-31</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构与算法/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>红黑树（Red–black tree）是一种平衡二叉查找树，它可以在 O(logn)时间内完成查找，插入和删除，这里的n是树中元素的数目，我们首先介绍下二叉查找树。</p>
<p>二叉查找树（Binary Search Tree），也称为二叉搜索树、有序二叉树（ordered binary tree）或排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树：</p>
<ul>
<li>若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；</li>
<li>若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；</li>
<li>任意节点的左、右子树也分别为二叉查找树；</li>
<li>没有键值相等的节点。</li>
</ul>
<p>在理想的情况下，二叉查找树插入、删除、查询的时间复杂度为O(logn)，最坏的情况下为O(N)。如果插入的数据是有序的情况下，二叉查找树会出现倾斜，退化为链表，如下图所示：<br><img src="/images/incline.jpg" alt="incline" title="incline"></p>
<p>为了解决倾斜的问题，引入了平衡二叉查找树，AVL和红黑树是其两种类型，它们都能保证在时间复杂度为O(logn)下实现二叉查找树的增删查。</p>
<p>在AVL树中，任一节点对应的两棵子树的最大高度差为1，因此它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下的时间复杂度都是O(logn)。插入和删除元素的操作需要进行一次或多次旋转，以实现树的重新平衡，实际上插入操作最多两次旋转，而删除操作需要最多O(logn)次旋转。</p>
<p>红黑树相对于AVL树来说，牺牲了部分平衡性以换取插入/删除操作时少量的旋转操作，整体来说性能要优于AVL树。在红黑树中，进行插入操作和删除操作只需要少量O(logn)的颜色变更和不超过三次树旋转（对于插入操作是两次），虽然插入和删除很复杂，但操作时间仍可以保持为O(logn)次。</p>
<p>红黑树的实际应用非常广泛，比如Linux内核中的完全公平调度器、高精度计时器、ext3文件系统等等，各种语言的函数库如Java的TreeMap和TreeSet，C++ STL的map、multimap、multiset等等。</p>
<p>红黑树的插入和删除操作相对来说还是比较复杂，为了简化算法，引入了一种新的数据结构跳跃表（Skip List）。Skip List是一种随机化的数据结构，基于并联的链表，其效率可比拟于二叉查找树（对于大多数操作需要O(logn)平均时间）。跳跃列表的插入和删除的实现与普通的链表操作类似，相对比较简单，但高层元素必须在进行多个链表中进行插入或删除。</p>
<p>跳跃列表的发明者对跳跃列表的评价是：“跳跃列表是在很多应用中有可能替代平衡树而作为实现方法的一种数据结构。跳跃列表的算法有同平衡树一样的渐进的预期时间边界，并且更简单、更快速和使用更少的空间。”，跳跃表的一个应用场景是作为Redis有序集合对象的底层实现，跳跃表将在后面的文章中讲述。</p>
<p>现在对这几种数据结构做一个比较对比：<br><img src="/images/rbt-comparison.jpg" alt="rbt-comparison" title="rbt-comparison"></p>
<h2 id="2-概念"><a href="#2-概念" class="headerlink" title="2. 概念"></a>2. 概念</h2><h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><p>红黑树是每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色。其特点如下：</p>
<ul>
<li>1)节点是红色或黑色；</li>
<li>2)根是黑色；</li>
<li>3)所有叶子都是黑色的（叶子是NIL节点）；</li>
<li>4)每个红色节点必须有两个黑色的子节点（从每个叶子到根的所有路径上不能有两个连续的红色节点）；</li>
<li>5)从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。</li>
</ul>
<p>这些约束确保了红黑树的关键特性：从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这个树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的。</p>
<p>要知道为什么这些性质确保了这个结果，注意到性质4导致了路径不能有两个毗连的红色节点就足够了。最短的可能路径都是黑色节点，最长的可能路径有交替的红色和黑色节点。因为根据性质5所有最长的路径都有相同数目的黑色节点，这就表明了没有路径能多于任何其他路径的两倍长。</p>
<p>下图就是一个红黑树的图例，来自维基百科。<br><img src="/images/red-black-tree.png" alt="red-black-tree" title="red-black-tree"></p>
<p>叶子结点用NIL节点表示。</p>
<p>红黑树的结构跟二叉查找树结构类型，在其基础上用一个属性来表示结点的颜色。代码定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RBTree</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RBNode&lt;T&gt; root; <span class="comment">// 根结点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> RED = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> BLACK = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结点定义</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">RBNode</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> color; <span class="comment">// 颜色</span></span><br><span class="line">        T key; <span class="comment">// 键值</span></span><br><span class="line">        RBNode&lt;T&gt; left; <span class="comment">// 左结点</span></span><br><span class="line">        RBNode&lt;T&gt; right; <span class="comment">// 右结点</span></span><br><span class="line">        RBNode&lt;T&gt; parent; <span class="comment">// 父结点</span></span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对红黑树进行插入及删除操作时，会改变红黑树的平衡，需要通过变色、左旋及右旋三种操作来修正，使其满足红黑树的定义。</p>
<h3 id="2-2-变色"><a href="#2-2-变色" class="headerlink" title="2.2 变色"></a>2.2 变色</h3><p>变色操作比较简单，代价也比较代，只是对结点的赋值操作，代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRed</span><span class="params">(RBNode&lt;T&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.color = RED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBlack</span><span class="params">(RBNode&lt;T&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.color = BLACK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-3-左旋"><a href="#2-3-左旋" class="headerlink" title="2.3 左旋"></a>2.3 左旋</h3><p><img src="/images/rotate-tree.jpg" alt="rotate-tree" title="rotate-tree"><br>如下图所示，左旋是X到Y的结点为“支轴”进行，它使X的右孩子Y成为该子树的新的根，X成为Y的左孩子，Y的左孩子成为X的右孩子。右旋与左旋是对称的操作，Y的左孩子X成为新子树的根，Y成为X的右孩子，X之前的右孩子成为Y的右孩子，下面的动图形象的展示了左旋的过程。<br><img src="/images/left-rotate.gif" alt="left-rotate" title="left-rotate"></p>
<p>左旋的代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 左旋示意图：对节点x进行左旋</span></span><br><span class="line"><span class="comment"> *     p                       p</span></span><br><span class="line"><span class="comment"> *    /                       /</span></span><br><span class="line"><span class="comment"> *   x                       y</span></span><br><span class="line"><span class="comment"> *  / \                     / \</span></span><br><span class="line"><span class="comment"> * lx  y      -----&gt;       x  ry</span></span><br><span class="line"><span class="comment"> *    / \                 / \</span></span><br><span class="line"><span class="comment"> *   ly ry               lx ly</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">leftRotate</span><span class="params">(RBNode&lt;T&gt; x)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    RBNode&lt;T&gt; y = x.right;</span><br><span class="line">    RBNode&lt;T&gt; parent = x.parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 将y的左子节点赋给x的右子节点,并将x赋给y左子节点的父节点(y左子节点非空时)</span></span><br><span class="line">    x.right = y.left;</span><br><span class="line">    <span class="keyword">if</span> (y.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        y.left.parent = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 将x的父节点p(非空时)赋给y的父节点，同时更新p的子节点为y(左或右)</span></span><br><span class="line">    y.parent = parent;</span><br><span class="line">    <span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.root = y;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (parent.left == x) &#123;</span><br><span class="line">            parent.left = y;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent.right = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.将y的左子节点设为x，将x的父节点设为y</span></span><br><span class="line">    y.left = x;</span><br><span class="line">    x.parent = y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>左旋做了三件事：</p>
<ul>
<li>1)将y的左子节点赋给x的右子节点,并将x赋给y左子节点的父节点(y左子节点非空时)；</li>
<li>2)将x的父节点p(非空时)赋给y的父节点，同时更新p的子节点为y(左或右)；</li>
<li>3)将y的左子节点设为x，将x的父节点设为y。</li>
</ul>
<h3 id="2-4-右旋"><a href="#2-4-右旋" class="headerlink" title="2.4 右旋"></a>2.4 右旋</h3><p>根据上面的描述我们可以知道，右旋与左旋是对称的操作，下面的动图形象地展示了右旋的过程。<br><img src="/images/right-rotate.gif" alt="right-rotate" title="right-rotate"></p>
<p>右旋的代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 右旋示意图：对节点y进行右旋</span></span><br><span class="line"><span class="comment"> *        p                   p</span></span><br><span class="line"><span class="comment"> *       /                   /</span></span><br><span class="line"><span class="comment"> *      y                   x</span></span><br><span class="line"><span class="comment"> *     / \                 / \</span></span><br><span class="line"><span class="comment"> *    x  ry   -----&gt;      lx  y</span></span><br><span class="line"><span class="comment"> *   / \                     / \</span></span><br><span class="line"><span class="comment"> * lx  rx                   rx ry</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rightRotate</span><span class="params">(RBNode&lt;T&gt; y)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    RBNode&lt;T&gt; x = y.left;</span><br><span class="line">    RBNode&lt;T&gt; parent = y.parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 将x的右子节点赋给y的左子节点,并将y赋给x右子节点的父节点(x右子节点非空时)</span></span><br><span class="line">    y.left = x.right;</span><br><span class="line">    <span class="keyword">if</span> (x.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        x.right.parent = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 将y的父节点p(非空时)赋给x的父节点，同时更新p的子节点为x(左或右)</span></span><br><span class="line">    x.parent = parent;</span><br><span class="line">    <span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.root = x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (parent.left == y) &#123;</span><br><span class="line">            parent.left = x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent.right = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 将x的右子节点设为y，将y的父节点设为x</span></span><br><span class="line">    x.right = y;</span><br><span class="line">    y.parent = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>右旋做了三件事：</p>
<ul>
<li>1)将x的右子节点赋给y的左子节点,并将y赋给x右子节点的父节点(x右子节点非空时);</li>
<li>2)将y的父节点p(非空时)赋给x的父节点，同时更新p的子节点为x(左或右);</li>
<li>3)将x的右子节点设为y，将y的父节点设为x。</li>
</ul>
<h2 id="3-插入"><a href="#3-插入" class="headerlink" title="3. 插入"></a>3. 插入</h2><h3 id="3-1-插入流程"><a href="#3-1-插入流程" class="headerlink" title="3.1 插入流程"></a>3.1 插入流程</h3><p>红黑树的插入操作如下：</p>
<ul>
<li>1) 找到插入结点的位置，即找到插入结点的父结点；</li>
<li>2) 与父结点的值进行比较，将结点插入到左结点或右结点；</li>
<li>3）插入结点颜色设置为红色,对红黑树进行修复。</li>
</ul>
<p>插入结点为什么设置为红色？主要是因为插入结点为红色，有可能违反第4条规则，如果结点为黑色，则必然会违反第5条规则。相对来说，插入结点为红色，红黑树修复的概念更低。插入的代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(RBNode&lt;T&gt; node)</span> </span>&#123;</span><br><span class="line">    RBNode&lt;T&gt; parent = <span class="keyword">null</span>;</span><br><span class="line">    RBNode&lt;T&gt; tmp = <span class="keyword">this</span>.root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.找到插入的位置</span></span><br><span class="line">    <span class="keyword">while</span> (tmp != <span class="keyword">null</span>) &#123;</span><br><span class="line">        parent = tmp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node.key.compareTo(parent.key) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            tmp = tmp.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp = tmp.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node.parent = parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 判断node是插在左子节点还是右子节点</span></span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.key.compareTo(parent.key) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            parent.left = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent.right = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.root = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 将它重新修复为一颗红黑树</span></span><br><span class="line">    insertFixUp(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-2-修复流程"><a href="#3-2-修复流程" class="headerlink" title="3.2 修复流程"></a>3.2 修复流程</h3><p>插入一个结点，有五种情况，分别是：</p>
<ul>
<li>1) 插入结点为头结点，违背了第2条规则，直接将结点设置为黑色即可；</li>
<li>2) 插入结点的父结点为黑色，那么仍然红黑树的规则，不用修复；</li>
<li>3) 插入节点的父节点和其叔叔节点（祖父节点的另一个子节点）均为红色的；</li>
<li>4) 插入节点的父节点是红色，叔叔节点是黑色，且插入节点是其父节点的右子节点；</li>
<li>5) 插入节点的父节点是红色，叔叔节点是黑色，且插入节点是其父节点的左子节点。</li>
</ul>
<p>下面主要对后面三种情况进行分析，现在假定第3)种情况为case1，第4)种情况为case2，第5)种情况为case3。<br><img src="/images/inser-up-1.jpg" alt="inser-up-1" title="inser-up-1"></p>
<p>如上图所示（省略叶子结点NIL），假定当前结点为修复的结点，父结点是祖父结点的左结点（如果父结点是右结点，则与左结点是对称操作），针对这三种情况，处理办法如下：</p>
<ul>
<li><p>case1: 插入节点的父节点和其叔叔节点（祖父节点的另一个子节点）均为红色<br>1）将父结点及叔叔结点设置为黑色；<br>2）祖父结点设置为红色，这样有可能改变了祖父结点的平衡。所以将当前结点结点设置为祖父结点，重新开始修复。</p>
</li>
<li><p>case2: 插入节点的父节点是红色，叔叔节点是黑色，且插入节点是其父节点的右子节点<br>从上图可以看出，case1转换为case2，处理办法如下：<br>1）左旋父节点，将当前结点的父亲结点设置为当前结点，重新修复；</p>
</li>
<li><p>case3: 插入节点的父节点是红色，叔叔节点是黑色，且插入节点是其父节点的左子节点<br>从case2转换为case3，处理办法如下：<br>1）将父结点设置为黑色，祖父结点设置为红色；<br>2）右旋祖父结点。</p>
</li>
</ul>
<p>从上图可以看出，这三种情况是可以互相转换的，可以从case1–&gt;case2–&gt;case3，实际上也可能从case1–&gt;case3，不经过case2，这要根据实际情况分析。</p>
<p>下面结合修复的代码分析下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修复红黑树</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 修复结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertFixUp</span><span class="params">(RBNode&lt;T&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义父节点和祖父节点</span></span><br><span class="line">    RBNode&lt;T&gt; parent = <span class="keyword">null</span>;</span><br><span class="line">    RBNode&lt;T&gt; grandParent = <span class="keyword">null</span>;</span><br><span class="line">    RBNode&lt;T&gt; uncle = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要修整的条件：父节点存在，且父节点的颜色是红色</span></span><br><span class="line">    <span class="keyword">while</span> (((parent = parentOf(node)) != <span class="keyword">null</span>) &amp;&amp; isRed(parent)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得祖父节点</span></span><br><span class="line">        grandParent = parentOf(parent);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若父节点是祖父节点的左子节点</span></span><br><span class="line">        <span class="keyword">if</span> (parent == grandParent.left) &#123;</span><br><span class="line">            <span class="comment">// 获得叔叔节点</span></span><br><span class="line">            uncle = grandParent.right;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// case1: 叔叔节点也是红色</span></span><br><span class="line">            <span class="keyword">if</span> (uncle != <span class="keyword">null</span> &amp;&amp; isRed(uncle)) &#123;</span><br><span class="line">                <span class="comment">// 把父节点和叔叔节点设置为黑色</span></span><br><span class="line">                setBlack(parent);</span><br><span class="line">                setBlack(uncle);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 把祖父节点设置为红色</span></span><br><span class="line">                setRed(grandParent);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将当前结点放到祖父节点处</span></span><br><span class="line">                node = grandParent;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// case2: 叔叔节点是黑色，且当前节点是右子节点</span></span><br><span class="line">            <span class="keyword">if</span> (node == parent.right) &#123;</span><br><span class="line">                <span class="comment">// 从父节点处左旋</span></span><br><span class="line">                leftRotate(parent);</span><br><span class="line">                RBNode&lt;T&gt; tmp = parent;</span><br><span class="line">                parent = node;</span><br><span class="line">                node = tmp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// case3: 叔叔节点是黑色，且当前节点是左子节点</span></span><br><span class="line">            setBlack(parent);</span><br><span class="line">            setRed(grandParent);</span><br><span class="line">            rightRotate(grandParent);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 若父节点是祖父节点的右子节点,与上面的操作对称（左旋变右旋，右旋变左旋）</span></span><br><span class="line">            uncle = grandParent.left;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// case1: 叔叔节点也是红色</span></span><br><span class="line">            <span class="keyword">if</span> (uncle != <span class="keyword">null</span> &amp;&amp; isRed(uncle)) &#123;</span><br><span class="line">                <span class="comment">// 把父节点和叔叔节点设置为黑色</span></span><br><span class="line">                setBlack(parent);</span><br><span class="line">                setBlack(uncle);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 把祖父节点设置为红色</span></span><br><span class="line">                setRed(grandParent);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//将位置放到祖父节点处</span></span><br><span class="line">                node = grandParent;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// case2: 叔叔节点是黑色，且当前节点是右子节点</span></span><br><span class="line">            <span class="keyword">if</span> (node == parent.left) &#123;</span><br><span class="line">                <span class="comment">// 从父节点处右旋</span></span><br><span class="line">                rightRotate(parent);</span><br><span class="line">                RBNode&lt;T&gt; tmp = parent;</span><br><span class="line">                parent = node;</span><br><span class="line">                node = tmp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// case3: 叔叔节点是黑色，且当前节点是左子节点</span></span><br><span class="line">            setBlack(parent);</span><br><span class="line">            setRed(grandParent);</span><br><span class="line">            leftRotate(grandParent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将根节点设置为黑色</span></span><br><span class="line">    setBlack(<span class="keyword">this</span>.root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-3-小结"><a href="#3-3-小结" class="headerlink" title="3.3 小结"></a>3.3 小结</h3><p>插入后的修复操作是一个向root节点回溯的操作，一旦牵涉的节点都符合了红黑树的定义，修复操作结束。之所以会向上回溯是由于case1操作会将父节点，叔叔节点和祖父节点进行换颜色，有可能会导致祖父节点不平衡(红黑树规则3)，这个时候需要对祖父节点为起点进行调节（向上回溯）。祖父节点调节后如果还是遇到它的祖父颜色问题，操作就会继续向上回溯，直到root节点为止。如果上面的3种情况发生在右子树上，做相应的对称操作即可。</p>
<h2 id="4-删除"><a href="#4-删除" class="headerlink" title="4. 删除"></a>4. 删除</h2><h3 id="4-1-删除流程"><a href="#4-1-删除流程" class="headerlink" title="4.1 删除流程"></a>4.1 删除流程</h3><p>红黑树的删除操作与平衡二叉树的删除类似，只是在平衡二叉树的基础上加入了修复的操作。与平衡二叉树的删除一样，删除操作分为三情况，1）删除结点没有子结点；2）删除结点只有一个子结点（左/右结点）；3）删除结点有两个子结点。其中第三种情况可以转换为删除其右子树最小结点来实现，而最小结点只有两种情况，要么没有子结点，要么只有右子结点，从而将第三种情况转换为1）2）两情况情况。删除结点操作主要是通过改变子结点与父结点的指针来实现，如下代码所示。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  删除分3种情况：</span></span><br><span class="line"><span class="comment"> *  1）没有子结点；</span></span><br><span class="line"><span class="comment"> *  2）只有一个子结点（左/右结点）；</span></span><br><span class="line"><span class="comment"> *  3）有两个子结点；</span></span><br><span class="line"><span class="comment"> *  1）2）两种情况删除的是结点本身，</span></span><br><span class="line"><span class="comment"> *  3）情况转换为删除其右子结点的后继结点（即右子树的最小结点），</span></span><br><span class="line"><span class="comment"> *  在这种情况下，其后继结点左子结点为空，右子结点可不为空。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(RBNode&lt;T&gt; node)</span> </span>&#123;</span><br><span class="line">    RBNode&lt;T&gt; candidate = <span class="keyword">null</span>;  <span class="comment">// 表示删除的结点</span></span><br><span class="line">    RBNode child = <span class="keyword">null</span>;</span><br><span class="line">    RBNode parent = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> color;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 寻找要删除的结点</span></span><br><span class="line">    <span class="comment">// 1.1 没有子结点或只有一个结点，删除结点本身</span></span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="keyword">null</span> || node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        candidate = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 1.2 有两个子结点，则删除右子树最小结点</span></span><br><span class="line">        candidate = node.right;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (candidate.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            candidate = candidate.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 赋值删除结点的父结点及子结点</span></span><br><span class="line">    parent = candidate.parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (candidate.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        child = candidate.left;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        child = candidate.right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 将子结点的父结点设置为删除结点的父结点</span></span><br><span class="line">    <span class="keyword">if</span> (child != <span class="keyword">null</span>) &#123;</span><br><span class="line">        child.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 将父结点的子结点设置为删除结点的子结点</span></span><br><span class="line">    <span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.root = child;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (candidate == parent.left) &#123;</span><br><span class="line">            parent.left = child;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent.right = child;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 如果删除结点有两个子结点，删除其右子树最小结点之后，</span></span><br><span class="line">    <span class="comment">// 需要将其最小结点的值赋值给删除结点，从而达到删除结点的目的。</span></span><br><span class="line">    <span class="keyword">if</span> (candidate != node) &#123;</span><br><span class="line">        node.key = candidate.key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果删除结点是黑色，则需要修复红黑树。</span></span><br><span class="line">    <span class="keyword">if</span> (candidate.color == BLACK) &#123;</span><br><span class="line">        removeFixUp(child, parent);</span><br><span class="line">    &#125;</span><br><span class="line">    node = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="4-2-修复流程"><a href="#4-2-修复流程" class="headerlink" title="4.2 修复流程"></a>4.2 修复流程</h3><p>删除结点是黑色的，就意味着原有平衡的路径上少了一个黑色结点，违反了红黑树的第5）条规则。为了保持平衡，兄弟子树上同样必须少一个黑色结点，如此操作之后，可能导致红黑树不平衡，就只能往上追溯，将每一级的黑节点数减去一个，使得整棵树符合红黑树的定义。</p>
<p>修复操作分为四种情况：</p>
<ul>
<li>1）调整结点节点的兄弟节点颜色是红色；</li>
<li>2）调整节点的兄弟节点颜色是黑色，且兄弟节点的子节点都是黑色的；</li>
<li>3）调整节点的兄弟节点颜色是黑色，且兄弟节点的左子节点是红色的，右节点是黑色的，如果兄弟在左边的话，则右子结点是红色的，左子结点是黑色的；</li>
<li>4）调整节点的兄弟节点颜色是黑色，且兄弟节点的右子节点是是红色的，左子节点任意颜色，如果兄弟在左边的话，则左子结点是红色的。</li>
</ul>
<p>在删除修复的操作中，实际有八种情况，调整结点是父结点的左/右子结点，各有四种情况，不过它们的操作是对称的，我们就以调整结点是左子结点为例介绍修复操作。</p>
<ul>
<li><p>case1: 调整节点的兄弟节点颜色是红色</p>
<ul>
<li>1）兄弟结点设置为黑色，父结点设置为红色；</li>
<li>2）左旋父结点；</li>
<li>3）将兄弟结点重新设置为父结点的右子结点。<br><img src="/images/remove-up-1.jpg" alt="remove-up-1" title="remove-up-1"></li>
</ul>
</li>
<li><p>case2: 调整节点的兄弟节点颜色是黑色，且兄弟节点的子节点都是黑色的</p>
<ul>
<li>1）兄弟结点设置为红色；</li>
<li>2）将调整结点设置为父结点，从父结点重新开始调整；<br><img src="/images/remove-up-2.jpg" alt="remove-up-2" title="remove-up-2"></li>
</ul>
</li>
<li><p>case3: 调整节点的兄弟节点颜色是黑色，且兄弟节点的左子节点是红色的，右节点是黑色的</p>
<ul>
<li>1）兄弟结点的左子结点设置为黑色，兄弟结点设置为红色；</li>
<li>2）右旋兄弟结点；</li>
<li>3）兄弟结点设置为父结点的右子结点。<br><img src="/images/remove-up-3.jpg" alt="remove-up-3" title="remove-up-3"></li>
</ul>
</li>
<li><p>case4: 调整节点的兄弟节点颜色是黑色，且兄弟节点的右子节点是是红色的</p>
<ul>
<li>1）兄弟结点颜色设置为父结点的颜色；</li>
<li>2）父结点设置为黑色；</li>
<li>3）兄弟结点的右子结点设置为黑色；</li>
<li>4）左旋父结点；</li>
<li>5）调整结点设置为根结点，从根据结点开始调整。<br><img src="/images/remove-up-4.jpg" alt="remove-up-4" title="remove-up-4"></li>
</ul>
</li>
</ul>
<p>实现代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  修复删除结点后的红黑树</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 调整的结点（删除结点的子结点）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parent 删除结点的父结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeFixUp</span><span class="params">(RBNode&lt;T&gt; node, RBNode&lt;T&gt; parent)</span> </span>&#123;</span><br><span class="line">    RBNode&lt;T&gt; sibling;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((node == <span class="keyword">null</span> || isBlack(node)) &amp;&amp; (node != <span class="keyword">this</span>.root)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parent.left == node) &#123; <span class="comment">//node是左子节点，</span></span><br><span class="line">            sibling = parent.right; <span class="comment">//node的兄弟节点</span></span><br><span class="line">            <span class="keyword">if</span> (isRed(sibling)) &#123; <span class="comment">//case1: node的兄弟节点other是红色的</span></span><br><span class="line">                setBlack(sibling);</span><br><span class="line">                setRed(parent);</span><br><span class="line">                leftRotate(parent);</span><br><span class="line">                sibling = parent.right;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// case2: node的兄弟节点other是黑色的，且other的两个子节点也都是黑色的</span></span><br><span class="line">            <span class="keyword">if</span> ((sibling.left == <span class="keyword">null</span> || isBlack(sibling.left)) &amp;&amp;</span><br><span class="line">                    (sibling.right == <span class="keyword">null</span> || isBlack(sibling.right))) &#123;</span><br><span class="line">                setRed(sibling);</span><br><span class="line">                node = parent;</span><br><span class="line">                parent = parentOf(node);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// case3: node的兄弟节点other是黑色的，且other的左子节点是红色，右子节点是黑色</span></span><br><span class="line">                <span class="keyword">if</span> (sibling.right == <span class="keyword">null</span> || isBlack(sibling.right)) &#123;</span><br><span class="line">                    setBlack(sibling.left);</span><br><span class="line">                    setRed(sibling);</span><br><span class="line">                    rightRotate(sibling);</span><br><span class="line">                    sibling = parent.right;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// case4: node的兄弟节点other是黑色的，且other的右子节点是红色，左子节点任意颜色</span></span><br><span class="line">                setColor(sibling, colorOf(parent));</span><br><span class="line">                setBlack(parent);</span><br><span class="line">                setBlack(sibling.right);</span><br><span class="line">                leftRotate(parent);</span><br><span class="line">                node = <span class="keyword">this</span>.root;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//与上面的对称</span></span><br><span class="line">            sibling = parent.left;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isRed(sibling)) &#123;</span><br><span class="line">                <span class="comment">// Case 1: node的兄弟other是红色的</span></span><br><span class="line">                setBlack(sibling);</span><br><span class="line">                setRed(parent);</span><br><span class="line">                rightRotate(parent);</span><br><span class="line">                sibling = parent.left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((sibling.left == <span class="keyword">null</span> || isBlack(sibling.left)) &amp;&amp;</span><br><span class="line">                    (sibling.right == <span class="keyword">null</span> || isBlack(sibling.right))) &#123;</span><br><span class="line">                <span class="comment">// Case 2: node的兄弟other是黑色，且other的俩个子节点都是黑色的</span></span><br><span class="line">                setRed(sibling);</span><br><span class="line">                node = parent;</span><br><span class="line">                parent = parentOf(node);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (sibling.left == <span class="keyword">null</span> || isBlack(sibling.left)) &#123;</span><br><span class="line">                    <span class="comment">// Case 3: node的兄弟other是黑色的，并且other的左子节点是红色，右子节点为黑色。</span></span><br><span class="line">                    setBlack(sibling.right);</span><br><span class="line">                    setRed(sibling);</span><br><span class="line">                    leftRotate(sibling);</span><br><span class="line">                    sibling = parent.left;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Case 4: node的兄弟other是黑色的；并且other的左子节点是红色的，右子节点任意颜色</span></span><br><span class="line">                setColor(sibling, colorOf(parent));</span><br><span class="line">                setBlack(parent);</span><br><span class="line">                setBlack(sibling.left);</span><br><span class="line">                rightRotate(parent);</span><br><span class="line">                node = <span class="keyword">this</span>.root;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="keyword">null</span>)</span><br><span class="line">        setBlack(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>红黑树相对于AVL而言，只要经过少量的变色及旋转操作，即可实现红黑树的平衡，较好地平衡了复杂度与平衡性的关系。整个红黑树的查找，插入和删除都是O(logN)的，原因就是整个红黑树的高度是logN，查找从根到叶，走过的路径是树的高度，删除和插入操作是从叶到根的，所以经过的路径都是logN。</p>
<p><strong>参考：</strong></p>
<hr>
<p><a href="https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91" target="_blank" rel="noopener">1. 红黑树</a></p>
<p><a href="https://zh.wikipedia.org/wiki/AVL%E6%A0%91" target="_blank" rel="noopener">2. AVL树</a></p>
<p><a href="https://tech.meituan.com/2016/12/02/redblack-tree.html" target="_blank" rel="noopener">3. 红黑树深入剖析及Java实现</a></p>
<p><a href="https://blog.csdn.net/eson_15/article/details/51144079" target="_blank" rel="noopener">4. 【数据结构和算法05】 红-黑树（看完包懂~）</a></p>
<p><a href="https://www.jianshu.com/p/37436ed14cc6" target="_blank" rel="noopener">5. 红黑树与AVL树，各自的优缺点总结</a></p>
<p><a href="https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/03.01.md" target="_blank" rel="noopener">6. 教你透彻了解红黑树</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/10/delayworkqueue-principles/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/09/10/delayworkqueue-principles/" class="post-title-link" itemprop="http://yoursite.com/page/3/index.html">DelayedWorkQueue 原理</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-09-10 09:50:24" itemprop="dateCreated datePublished" datetime="2019-09-10T09:50:24+08:00">2019-09-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-07-31 17:17:10" itemprop="dateModified" datetime="2021-07-31T17:17:10+08:00">2021-07-31</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/阻塞队列/" itemprop="url" rel="index"><span itemprop="name">阻塞队列</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在Java中，ScheduledThreadPoolExecutor主要作用是执行延时及周期性任务，这篇文章主要分析以下几个问题：1）任务是如何存储的？2）延时及周期性任务什么时候执行及如何执行？3）任务怎么进行取消？带着这些问题我们继续往下看。</p>
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p><img src="/images/scheduled-thread-pool-executor.jpg" alt="ScheduledThreadPoolExecutor" title="ScheduledThreadPoolExecutor"></p>
<p>从上图可以看到ScheduledThreadPoolExecutor,DelayedWorkQueue及ScheduledFutureTask三者之间的关系，在ScheduledThreadPoolExecutor中使用的队列是DelayedWorkQueue，用于存储执行的任务；提交到DelayedWorkQueue中的是ScheduledFutureTask类型的任务，通过ScheduledFutureTask的引用可以获取结果或者取消任务，下面对这三个类做一个简要描述：</p>
<ul>
<li>DelayedWorkQueue : 底层的存储结构是一个小堆，它根据延时的时间进行排序，堆顶的元素永远是最小的；加入一个元素时，首先被加到队列的最后一个元素中，然后使用siftUp操作，跟它的父结点进行比较，如果比父结点小，则交换位置，递归执行这样的操作，直到比父结点元素都大；取出元素永远是取出堆顶元素，然后将队列中的最后一个元素移动到堆顶，执行siftDown操作，跟左右子结点中的最小元素进行比较，如果比子结点大， 则交换位置，递归执行这样的操作，直到比子结点小为止。</li>
<li>ScheduledFutureTask : 提交到DalayWorkQueue队列中的元素是ScheduledFutureTask类型，它继承了Runnable接口，包含了任务的执行逻辑，同时它也继承了Future接口，具备了取消任务、同步获取返回结果的功能。在ScheduledFutureTask中有几个重要的参数：state(状态), callable(有返回值的runnable对象), outcome(返回结果), runner(执行线程), waiters(等待队列), state表示任务执行的状态，如果任务在未完成之前执行get操作（获取返回结果），那么调用线程会被阻塞，该线程会加入到waiters队列中，等待runner线程执行set操作（设置返回结果）之后被唤醒。如果ScheduledFutureTask执行了取消操作之后，它会被移除DelayedWorkQueue队列，state设置为取消状态，任务将不再被执行，如果任务已经执行，将会向其发送interrupt操作。</li>
<li>ScheduledThreadPoolExecutor : ScheduledThreadPoolExecutor扩展了ThreadPoolExecutor类，在ThreadPoolExecutor的基础上，可以执行延时任务和周期性任务，借助DelayedWorkQueue类，实现了任务的延时执行，对于周期性任务，在上一个周期执行结束之后，会重新计算下一个周期的延时时间，将任务重新加入到DelayedWorkQueue队列中，等待下次任务的调度。</li>
</ul>
<h2 id="2-DelayedWorkQueue"><a href="#2-DelayedWorkQueue" class="headerlink" title="2. DelayedWorkQueue"></a>2. DelayedWorkQueue</h2><p><img src="/images/DelayedWorkQueue.jpg" alt="DelayedWorkQueue" title="DelayedWorkQueue"><br>DelayedWorkQueue类图如上所示，DelayedWorkQueue是BlockingQueue的子类。</p>
<p>DelayedWorkQueue跟DelayQueue、PriorityQueue一样是基于堆的数据结构，它与ScheduledFutureTask配合使用。在ScheduledFutureTask中记录了在堆中的索引，可以快速定位所在的位置，方便进行task的取消操作，同时ScheduledFutureTask必须实现Comparable和Delayed接口，Comparable接口用于比较两个任务的延时的大小，Delayed返回任务的延时，即还需多久执行任务。</p>
<p>DelayedWorkQueue队列中元素的增加或删除，都会改变堆的结构，在DelayedWorkQueue中，提供了两种调整堆的操作：siftUp和siftDown，后面的章节会详细介绍。</p>
<p>在分析DelayedWorkQueue之前，先了解下堆这种数据结构：</p>
<blockquote>
<p>堆（英语：Heap）是计算机科学中的一种特别的树状数据结构。若是满足以下特性，即可称为堆：“给定堆中任意节点P和C，若P是C的父母节点，那么P的值会小于等于（或大于等于）C的值”。若父母节点的值恒小于等于子节点的值，此堆称为最小堆（min heap）；反之，若父母节点的值恒大于等于子节点的值，此堆称为最大堆（max heap）。在堆中最顶端的那一个节点，称作根节点（root node），根节点本身没有父母节点（parent node）</p>
</blockquote>
<p>一个小堆的结构如下所示：<br><img src="/images/min-heap.jpg" alt="min-heap" title="min-heap"></p>
<p>在小堆中，parent结点小于等于子结点，而对两个左右子结点大小没有要求，一个堆实际上是一颗完全二叉树，一般用数组来表示。在DelayedWorkQueue中使用的是小堆，来保证返回的是延时最小的任务。</p>
<h3 id="2-1-siftUp操作"><a href="#2-1-siftUp操作" class="headerlink" title="2.1 siftUp操作"></a>2.1 siftUp操作</h3><p>在一个小堆中的添加一个结点的过程如下：1）将结点添加到堆中的最后一个元素；2）跟parent结点进行比较，如果比parent结点小，则交换结点，直到没有parent结点为止，如下图所示：<br><img src="/images/sift-up.jpg" alt="sift-up" title="sift-up"><br>接入一个新的最小值9，会比较三次，直到堆顶。该算法的时间复杂度为O(log(n))，n为结点个数。</p>
<h3 id="2-2-siftDown操作"><a href="#2-2-siftDown操作" class="headerlink" title="2.2 siftDown操作"></a>2.2 siftDown操作</h3><p>从堆顶取走最小的结点之后，会将堆中最后一个结点移动堆顶，执行siftDown过程，parent结点会跟子结点中的最小值进行比较，如果大于子结点，需要跟子结点进行交换，调整后的结构仍然是小堆，如下图所示：<br><img src="/images/sift-down.jpg" alt="sift-down" title="sift-down"><br>该算法的时间复杂度也是O(log(n))，n为结点个数。</p>
<h3 id="2-3-数据结构"><a href="#2-3-数据结构" class="headerlink" title="2.3 数据结构"></a>2.3 数据结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayedWorkQueue</span> <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">Runnable</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">Runnable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 堆的初始容量为16</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储堆中的结点，用数组来表示堆</span></span><br><span class="line">    <span class="keyword">private</span> RunnableScheduledFuture&lt;?&gt;[] queue =</span><br><span class="line">        <span class="keyword">new</span> RunnableScheduledFuture&lt;?&gt;[INITIAL_CAPACITY];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于互斥访问    </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前在等待堆顶结点的线程，使用了leader-follower的线程模式</span></span><br><span class="line">    <span class="keyword">private</span> Thread leader = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 条件变量，堆中没有结点时，阻塞线程；堆中有新的堆顶结点时，唤醒线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition available = lock.newCondition();</span><br><span class="line">    </span><br><span class="line">    ... <span class="comment">// 略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li>初始容量：DelayedWorkQueue的容量无限的队列，其初始容量为16，随着结点数的增加，会进行自动扩容；</li>
<li>底层数据：存储结构为数组；</li>
<li>leader-follow线程模式：堆顶结点会只分配一个leader线程去消费，其它线程会等待leader线程唤醒才能消费下一个结点；如果堆顶结点还需要延时delayed（ns）才能消费，那么leader需要阻塞delayed（ns）；</li>
<li>条件变量：堆中没有结点时，阻塞线程；堆中有新的堆顶结点时，唤醒线程。</li>
</ul>
<h3 id="2-4-offer操作"><a href="#2-4-offer操作" class="headerlink" title="2.4 offer操作"></a>2.4 offer操作</h3><p>在DelayedWorkQueue中，添加结点可以调使用put/add/offer方法，前两个方法最终都是调用offer方法，那么我们重点来分析下offer方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(Runnable x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传入的任务是RunnableScheduledFuture的子类</span></span><br><span class="line">    RunnableScheduledFuture&lt;?&gt; e = (RunnableScheduledFuture&lt;?&gt;)x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取锁，互斥访问</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.如果结点数大于等于队列长度，则需要扩容</span></span><br><span class="line">        <span class="keyword">int</span> i = size;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= queue.length)</span><br><span class="line">            grow();</span><br><span class="line">        size = i + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 如果结点数为0，则直接赋值给第一个元素即可；</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            queue[<span class="number">0</span>] = e;</span><br><span class="line">            <span class="comment">// 2.1 将数组元素下标传递给RunnableScheduledFuture对象，以便该对象检索其在数组中的位置；</span></span><br><span class="line">            setIndex(e, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 3. 如果结点数大于0，则将结点插入到堆中的最后一个结点，并执行siftUp操作</span></span><br><span class="line">            siftUp(i, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4. 如果插入的结点是新的堆顶元素，说明有延时更短的任务加入到队列中，</span></span><br><span class="line">        <span class="comment">// 则将leader置空，并唤醒一个线程来消费新的堆顶。</span></span><br><span class="line">        <span class="keyword">if</span> (queue[<span class="number">0</span>] == e) &#123;</span><br><span class="line">            leader = <span class="keyword">null</span>;</span><br><span class="line">            available.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该方法主要包含4个步骤：</p>
<ul>
<li>如果结点数大于队列长度，则执行扩容；</li>
<li>如果当前结点数为0，则直接将新插入的结点赋值给数组的第一个元素；</li>
<li>如果当前结点为大于0，则将结点插入到堆中的最后一个结点，并执行siftUp操作；</li>
<li>如果插入的结点是新的堆顶元素，说明有延时更短的任务加入到队列中，则将leader置空，并唤醒一个线程来消费新的堆顶。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = queue.length;</span><br><span class="line">    <span class="comment">// 容量扩大50%</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>); <span class="comment">// grow 50%</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        newCapacity = Integer.MAX_VALUE;</span><br><span class="line">    queue = Arrays.copyOf(queue, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>扩容操作主要是新建一个数组，其容量是旧数组的1.5倍，并将老数组的元素拷贝到新数组中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> k, RunnableScheduledFuture&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 计算parent结点的下标</span></span><br><span class="line">        <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        RunnableScheduledFuture&lt;?&gt; e = queue[parent];</span><br><span class="line">        <span class="comment">// 如果插入的结点大于parent结点则退出</span></span><br><span class="line">        <span class="keyword">if</span> (key.compareTo(e) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = e;</span><br><span class="line">        setIndex(e, k);</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = key;</span><br><span class="line">    setIndex(key, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>插入结点的类型实现了Comparable接口，结点之间的比较使用compareTo方法，该方法我们在后面的内容讲述，详细的siftUp操作可以参考2.1节。</p>
<h3 id="2-5-take操作"><a href="#2-5-take操作" class="headerlink" title="2.5 take操作"></a>2.5 take操作</h3><p>获取堆顶结点以take方法为例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> RunnableScheduledFuture&lt;?&gt; take() <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 获取锁，互斥访问</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 1. 获取堆顶结点，即最小值。</span></span><br><span class="line">            RunnableScheduledFuture&lt;?&gt; first = queue[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 如果堆顶为空，说明队列中没有结点，则直接阻塞调用线程。</span></span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">                available.await();</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3. 计算堆顶结点的延时，如果已经过期，则直接返回堆顶结点，并执行siftDown操作</span></span><br><span class="line">                <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS);</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> finishPoll(first);</span><br><span class="line">                first = <span class="keyword">null</span>; <span class="comment">// don't retain ref while waiting</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 4. 如果堆顶结点还未到期，则阻塞调用线程，这里分两种情况：</span></span><br><span class="line">                <span class="comment">// 1) 如果leader不为空，说明已经有线程在等待该结点，则直接阻塞调用线程；</span></span><br><span class="line">                <span class="comment">// 2) 如果leader为空，说明该结点还没有分配leader结点，则设置当前线程为leader线程，</span></span><br><span class="line">                <span class="comment">// 同时将阻塞时间设置为结点延时的时间。</span></span><br><span class="line">                <span class="keyword">if</span> (leader != <span class="keyword">null</span>)</span><br><span class="line">                    available.await();</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Thread thisThread = Thread.currentThread();</span><br><span class="line">                    leader = thisThread;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        available.awaitNanos(delay);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">                            leader = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 5. 唤醒follower线程，消费新的堆顶结点。</span></span><br><span class="line">        <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; queue[<span class="number">0</span>] != <span class="keyword">null</span>)</span><br><span class="line">            available.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该方法主要包含5个步骤：</p>
<ul>
<li>获取堆顶结点，即最小值；</li>
<li>如果堆顶为空，说明队列中没有结点，则直接阻塞调用线程，等待被唤醒；</li>
<li>如果堆顶不为空， 计算堆顶结点的延时，如果已经过期，则直接返回堆顶结点，并执行siftDown操作；</li>
<li>如果堆顶结点还未到期，则阻塞调用线程，这里分两种情况：1) 如果leader不为空，说明已经有线程在等待该结点，则直接阻塞调用线程；2) 如果leader为空，说明该结点还没有分配leader结点，则设置当前线程为leader线程，同时将阻塞时间设置为结点延时的时间。</li>
<li>最后leader线程唤醒follower线程，消费新的堆顶结点。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> RunnableScheduledFuture&lt;?&gt; finishPoll(RunnableScheduledFuture&lt;?&gt; f) &#123;</span><br><span class="line">    <span class="comment">// 队列长度减1；</span></span><br><span class="line">    <span class="keyword">int</span> s = --size;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 取出队列中最后一个元素</span></span><br><span class="line">    RunnableScheduledFuture&lt;?&gt; x = queue[s];</span><br><span class="line">    queue[s] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行siftDown操作</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        siftDown(<span class="number">0</span>, x);</span><br><span class="line">    setIndex(f, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>finishPoll方法有两个作用：1）压缩队列，队列数减1；2）执行siftDown操作。我们接着看siftDown操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> k, RunnableScheduledFuture&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">        <span class="comment">// 1. 计算左子结点；</span></span><br><span class="line">        <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        RunnableScheduledFuture&lt;?&gt; c = queue[child];</span><br><span class="line">        <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 2. 判断左右子结点的最小值，并赋值给变量c;</span></span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp; c.compareTo(queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">            c = queue[child = right];</span><br><span class="line">        <span class="comment">// 3. 子结点中最小值与key进行比较，如果子结点大于key，则直接退出；</span></span><br><span class="line">        <span class="keyword">if</span> (key.compareTo(c) &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 4. 如果子结点小于key，则将子结点赋值给parent结点；</span></span><br><span class="line">        queue[k] = c;</span><br><span class="line">        setIndex(c, k);</span><br><span class="line">        k = child;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5. 将key赋值给最终的结点；</span></span><br><span class="line">    queue[k] = key;</span><br><span class="line">    <span class="comment">// 6. 将key在队列中的下标传递给key。</span></span><br><span class="line">    setIndex(key, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>siftDown的具体操作参考2.2节。</p>
<h3 id="2-6-小结"><a href="#2-6-小结" class="headerlink" title="2.6 小结"></a>2.6 小结</h3><p>DelayedWorkQueue底层使用了堆的数据结构来存储延时/周期性的任务，在队列中结点按照延时时间进行排序，从队列中取出的结点都是到期的结点。另外要求结点必须实现Comparable及Delayed接口，结点通过Comparable.compareTo方法比较大小，通过Delayed.getDelay方法获取结点的延时，作为判断是否过期的依据。</p>
<h2 id="3-ScheduledFutureTask"><a href="#3-ScheduledFutureTask" class="headerlink" title="3. ScheduledFutureTask"></a>3. ScheduledFutureTask</h2><p><img src="/images/ScheduledFutureTask.jpg" alt="ScheduledFutureTask" title="ScheduledFutureTask"><br>ScheduledFutureTask类的继承关系比较复杂，现在对它进行一个梳理。</p>
<ul>
<li>Comparable : 实现任务按照延时进行比较；</li>
<li>Delayed : 获取任务所剩延时；</li>
<li>Runnable ：封装任务的业务逻辑；</li>
<li>Future : 实现任务的取消及同步获取返回结果。</li>
</ul>
<p>下面将对这些功能做详细描述。</p>
<h3 id="3-1-数据结构"><a href="#3-1-数据结构" class="headerlink" title="3.1 数据结构"></a>3.1 数据结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledFutureTask</span>&lt;<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableScheduledFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sequenceNumber;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任务执行的时间，单位为ns</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> time;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任务执行的周期，单位为ns,</span></span><br><span class="line">    <span class="comment">// 如果是正数，表示固定频率执行，如果是负数，表示固定延时执行，</span></span><br><span class="line">    <span class="comment">// 如果是0，则表示非同期性任务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> period;</span><br><span class="line"></span><br><span class="line">    RunnableScheduledFuture&lt;V&gt; outerTask = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该任务在堆中的下标，用于快速取消任务</span></span><br><span class="line">    <span class="keyword">int</span> heapIndex;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// in FutureTask</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 任务的运行时状态</span></span><br><span class="line">    <span class="comment">// NEW : 任务的初始状态；</span></span><br><span class="line">    <span class="comment">// COMPLETING : 临时状态，表示任务run方法已经执行结束，但未设置返回结果；</span></span><br><span class="line">    <span class="comment">// NORMAL : 正常结束状态，已经设置返回结果；</span></span><br><span class="line">    <span class="comment">// EXCEPTIONAL : 执行有异常；</span></span><br><span class="line">    <span class="comment">// CANCELLED : 任务已经被取消；</span></span><br><span class="line">    <span class="comment">// INTERRUPTING : 临时状态，表示正在执行中断操作；</span></span><br><span class="line">    <span class="comment">// INTERRUPTED : 执行了中断操作。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 封装了runnable及结果对象，真正的业务逻辑在这里</span></span><br><span class="line">    <span class="keyword">private</span> Callable&lt;V&gt; callable;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 结果对象</span></span><br><span class="line">    <span class="keyword">private</span> Object outcome; <span class="comment">// non-volatile, protected by state reads/writes</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 正在执行任务的线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Thread runner;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 线程等待队列（在等待返回结果）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> WaitNode waiters;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// in FutureTask</span></span><br><span class="line">    </span><br><span class="line">    ... <span class="comment">// 略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ScheduledFutureTask的属性分为两类，一是与调度时间相关的，二是与Future相关的，下面对这两类属性进行讨论。</p>
<p>1）调度时间相关</p>
<ul>
<li>sequenceNumber : 第一个任务都会分配一个唯一的自增序列号；</li>
<li>time : 表示任务执行的时间点，单位为ns(纳秒)；</li>
<li>period : 任务执行的周期，如果是正数，表示固定频率执行，如果是负数，表示固定延时执行， 如果是0，则表示非同期性任务，单位为ns(纳秒)；</li>
<li>heapIndex ： 任务在堆中的下标，用于快速取消任务。</li>
</ul>
<p>2）Future相关</p>
<ul>
<li>state ：任务的运行时状态，状态值有：NEW, COMPLETING, NORMAL, EXCEPTIONAL, CANCELLED, INTERRUPTING和INTERRUPTED，含义如下：<br>NEW : 任务的初始状态；<br>COMPLETING : 临时状态，表示任务run方法已经执行结束，但未设置返回结果；<br>NORMAL : 正常结束状态，已经设置返回结果；<br>EXCEPTIONAL : 执行有异常；<br>CANCELLED : 任务已经被取消；<br>INTERRUPTING : 临时状态，表示正在执行中断操作；<br>INTERRUPTED : 执行了中断操作。<br>状态值的转换有下面几种情况：<br>NEW -&gt; COMPLETING -&gt; NORMAL<br>NEW -&gt; COMPLETING -&gt; EXCEPTIONAL<br>NEW -&gt; CANCELLED<br>NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</li>
<li>callable : 封装了runnable及结果对象，真正的业务逻辑在这里；</li>
<li>outcome ： 结果对象；</li>
<li>runner : 正在执行任务的线程；</li>
<li>waiters : 线程等待队列（在等待返回结果）。</li>
</ul>
<h3 id="3-2-compareTo方法"><a href="#3-2-compareTo方法" class="headerlink" title="3.2 compareTo方法"></a>3.2 compareTo方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed other)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (other == <span class="keyword">this</span>) <span class="comment">// compare zero if same object</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (other <span class="keyword">instanceof</span> ScheduledFutureTask) &#123;</span><br><span class="line">        ScheduledFutureTask&lt;?&gt; x = (ScheduledFutureTask&lt;?&gt;)other;</span><br><span class="line">        <span class="keyword">long</span> diff = time - x.time;</span><br><span class="line">        <span class="keyword">if</span> (diff &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (sequenceNumber &lt; x.sequenceNumber)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> diff = getDelay(NANOSECONDS) - other.getDelay(NANOSECONDS);</span><br><span class="line">    <span class="keyword">return</span> (diff &lt; <span class="number">0</span>) ? -<span class="number">1</span> : (diff &gt; <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>compareTo方法比较简单，主要是比较两个任务执行时间的大小，如果当前结点小于比较的结点，则返回-1；如果大于比较的结点，则返回1；如果时间相等，再比较序号，序号大的返回1，序号小的返回-1；如果比较的是同一个元素，则返回0；</p>
<h3 id="3-3-getDelay方法"><a href="#3-3-getDelay方法" class="headerlink" title="3.3 getDelay方法"></a>3.3 getDelay方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unit.convert(time - now(), NANOSECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getDelay方法返回当前的延时，当前延时主要是任务的执行时间点与当前时间的差值。</p>
<h3 id="3-4-FutureTask"><a href="#3-4-FutureTask" class="headerlink" title="3.4 FutureTask"></a>3.4 FutureTask</h3><p>FutureTask可以实现三个功能：1）同步转异步，将任务交给线程池处理；2）同步/异步获取返回结果；3）取消任务。第一个功能很简单，就是封装业务逻辑，交给线程池处理，下面重点分析后两个功能。</p>
<h4 id="3-4-1-获取返回结果"><a href="#3-4-1-获取返回结果" class="headerlink" title="3.4.1 获取返回结果"></a>3.4.1 获取返回结果</h4><p>获取返回结果用的是get方法，get有两个重载方法，一个不带参数，表示任务没有完成，则阻塞线程，直到任务完成被唤醒或线程被中断；一个带时间参数，表示任务没有完成，则睡眠指定时间，直到任务完成被唤醒或超时或线程被中断。现在以不带参数的get方法为例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = state;</span><br><span class="line">    <span class="comment">// state(状态)小于COMPLETING(正在完成)，则需要阻塞线程</span></span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">        s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    <span class="comment">// 到这里说明任务已经完成，任务完成有多种情况需要在这个里</span></span><br><span class="line">    <span class="comment">// 判断：1）正常结束；2）取消；3）异常退出。</span></span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>get方法主要是根据任务的运行状态(state)来判断任务是否完成，处于NEW,COMPLETING两种状态，说明任务未完成或即将完成，这时候调用awaitDone方法，可能会阻塞线程；如果大于COMPLETING，说明任务已经完成，还需要判断完成的类型：1）正常结束；2）取消；3）异常退出，这些逻辑在report方法中处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 等待任务完成或中断或超时</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timed 是否设置超时</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nanos 超时时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> state 完成状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">awaitDone</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">    WaitNode q = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> queued = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 线程中断，则抛出InterruptedException，退出方法；</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="comment">// 将线程从等待队列中移出；</span></span><br><span class="line">            removeWaiter(q);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 状态大于COMPLETING，说明任务完成，退出方法；</span></span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt; COMPLETING) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q != <span class="keyword">null</span>)</span><br><span class="line">                q.thread = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 状态等于COMPLETING，说明任务即将完成，则线程让出cpu，重新调度，</span></span><br><span class="line">        <span class="comment">// 目的是让当前线程等一小段时间；</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING) <span class="comment">// cannot time out yet</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        <span class="comment">// 4. 状态等于NEW且q等于null，说明任务未完成，则新建等待结点。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="keyword">null</span>)</span><br><span class="line">            q = <span class="keyword">new</span> WaitNode();</span><br><span class="line">        <span class="comment">// 5. 将当前线程压入等待队列的队首；</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</span><br><span class="line">            queued = UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset,</span><br><span class="line">                                                 q.next = waiters, q);</span><br><span class="line">        <span class="comment">// 6. 如果设置超时，则睡眠指定时间</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                removeWaiter(q);</span><br><span class="line">                <span class="keyword">return</span> state;</span><br><span class="line">            &#125;</span><br><span class="line">            LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 7. 未指定时间，则直接睡眠</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>awaitDone方法包含一个死循环，有三种情况退出该方法：1) 线程被中断；2）线程被唤醒，且任务已经完成，正常退出；3）超时退出。它包含以下的处理逻辑：</p>
<ul>
<li>线程被中断，则抛出InterruptedException，退出方法；</li>
<li>线程状态大于COMPLETING，说明任务完成，退出方法；</li>
<li>状态等于COMPLETING，说明任务即将完成，则线程让出cpu，重新调度；</li>
<li>状态等于NEW且q等于null，说明任务未完成，则新建等待结点，并将该结点等待队列的队首；</li>
<li>如果设置超时，则睡眠指定的时间，否则直接睡眠，等待被唤醒。</li>
</ul>
<p>分析了get方法，我们再来分析下set方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过CAS设置状态为COMPLETING</span></span><br><span class="line">    <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置结果</span></span><br><span class="line">        outcome = v;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置状态为NORMAL</span></span><br><span class="line">        UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, NORMAL); <span class="comment">// final state</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 唤醒等待队列中的线程</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>set方法流程比较清晰，包含下面这些流程：</p>
<ul>
<li>通过CAS设置状态(state)为COMPLETING；</li>
<li>设置返回结果；</li>
<li>设置状态(state)为NORMAL，可见COMPLETING是一个很短暂的状态，与NORMAL状态中间只有一个设置返回结果的操作；</li>
<li>唤醒等待队列中的线程。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishCompletion</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历等待队列，依次唤醒等待的线程</span></span><br><span class="line">    <span class="keyword">for</span> (WaitNode q; (q = waiters) != <span class="keyword">null</span>;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset, q, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                Thread t = q.thread;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    q.thread = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">// 唤醒等待的线程</span></span><br><span class="line">                    LockSupport.unpark(t);</span><br><span class="line">                &#125;</span><br><span class="line">                WaitNode next = q.next;</span><br><span class="line">                <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                q.next = <span class="keyword">null</span>; <span class="comment">// unlink to help gc</span></span><br><span class="line">                q = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    done();</span><br><span class="line"></span><br><span class="line">    callable = <span class="keyword">null</span>;        <span class="comment">// to reduce footprint</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>finishCompletion方法逻辑比较简单，就是遍历等待队列，依次唤醒等待的线程。</p>
<p>通过上面的分析可以知道，get方法获取返回结果，如果任务未完成则阻塞调用线程；set方法设置返回结果，更新任务状态，唤醒被阻塞的线程。</p>
<h4 id="3-4-2-取消任务"><a href="#3-4-2-取消任务" class="headerlink" title="3.4.2 取消任务"></a>3.4.2 取消任务</h4><p>在FutureTask中可以通过cancel方法取消一个任务，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(state == NEW &amp;&amp;</span><br><span class="line">          UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW,</span><br><span class="line">              mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;    <span class="comment">// in case call to interrupt throws exception</span></span><br><span class="line">        <span class="keyword">if</span> (mayInterruptIfRunning) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread t = runner;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">                    t.interrupt();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123; <span class="comment">// final state</span></span><br><span class="line">                UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, INTERRUPTED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>取消一个任务实际上就是一个操作：设置state(状态)为CANCELLED或INTERRUPTED。方法参数mayInterruptIfRunning为ture的情况下，状态设置为INTERRUPTED。从上面的代码可以看到INTERRUPTING是个临时状态，介于new和INTERRUPTED之间，和INTERRUPTED状态只相隔一个线程中断操作。</p>
<h3 id="3-5-任务的执行"><a href="#3-5-任务的执行" class="headerlink" title="3.5 任务的执行"></a>3.5 任务的执行</h3><p>ScheduledFutureTask实现了Runnabler接口，实现了对周期性任务的支持。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 判断是否为周期性任务</span></span><br><span class="line">    <span class="keyword">boolean</span> periodic = isPeriodic();</span><br><span class="line">    <span class="comment">// 2. 判断是否需要取消任务</span></span><br><span class="line">    <span class="keyword">if</span> (!canRunInCurrentRunState(periodic))</span><br><span class="line">        cancel(<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// 3. 执行非周期性任务</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!periodic)</span><br><span class="line">        ScheduledFutureTask.<span class="keyword">super</span>.run();</span><br><span class="line">    <span class="comment">// 4. 执行周期性任务</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ScheduledFutureTask.<span class="keyword">super</span>.runAndReset()) &#123;</span><br><span class="line">        <span class="comment">// 5. 设置下一次任务执行的时间</span></span><br><span class="line">        setNextRunTime();</span><br><span class="line">        <span class="comment">// 6. 重新调度任务</span></span><br><span class="line">        reExecutePeriodic(outerTask);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ScheduledFutureTask执行逻辑包含以下几个步骤：</p>
<ul>
<li>判断是否为周期性任务；</li>
<li>判断该任务是否应该取消，取消的情况包括：1）线程池是否关闭；2）线程池关闭的情况下，任务是否继续执行的策略；</li>
<li>如果是非周期性任务，调用FutureTask的run方法；</li>
<li>如果是周期性任务，调用FutureTask的runAndReset方法，调用成功之后设置下一次任务执行的时间，并将任务重新添加到DelayedWorkQueue中。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPeriodic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> period != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在ScheduledFutureTask中，用period属性来判断是否是周期性任务，period取值包括三种情况：1）正数，表示固定频率执行；2）负数，表示固定延时执行；3）0，表示非同期性任务，单位为ns(纳秒)。在非0的情况下，period存储了周期性任务之间的间隔时间。</p>
<p>接下来我们看下非周期性任务执行的逻辑，即FutureTask的run方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断任务的状态是否为NEW，且设置runner为当前线程</span></span><br><span class="line">    <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">        !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                                     <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 执行逻辑封装在Callable对象中</span></span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">            V result;</span><br><span class="line">            <span class="keyword">boolean</span> ran;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 调用业务逻辑</span></span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                result = <span class="keyword">null</span>;</span><br><span class="line">                ran = <span class="keyword">false</span>;</span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 设置返回结果</span></span><br><span class="line">            <span class="keyword">if</span> (ran)</span><br><span class="line">                set(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 清空runner</span></span><br><span class="line">        runner = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="comment">// 判断是否有中断操作</span></span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>非周期性任务执行的主要逻辑如下：</p>
<ul>
<li>判断当前任务的状态是为NEW，且设置任务的runner为当前线程；</li>
<li>调用Callable接口，执行真正的业务逻辑；</li>
<li>调用set操作，设置返回结果，唤醒被阻塞的线程；</li>
</ul>
<p>下面看周期性任务的的runAndReset方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">runAndReset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">        !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                                     <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> ran = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> s = state;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; s == NEW) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 执行业务逻辑</span></span><br><span class="line">                c.call(); <span class="comment">// don't set result</span></span><br><span class="line">                ran = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        runner = <span class="keyword">null</span>;</span><br><span class="line">        s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// state不改变</span></span><br><span class="line">    <span class="keyword">return</span> ran &amp;&amp; s == NEW;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>相对于非周期性任务，runAndReset有以下不同：</p>
<ul>
<li>周期性任务没有返回值；</li>
<li>周期性任务不更新state(状态)，它的状态永远是NEW，以便下一次调用。</li>
</ul>
<p>我们知道周期性任务有两种类型，一种是固定频率，另外一种是固定延时，这两种任务的不同体现在什么地方，我们接着看setNextRunTime方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setNextRunTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> p = period;</span><br><span class="line">    <span class="keyword">if</span> (p &gt; <span class="number">0</span>)</span><br><span class="line">        time += p;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        time = triggerTime(-p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">triggerTime</span><span class="params">(<span class="keyword">long</span> delay)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> now() +</span><br><span class="line">        ((delay &lt; (Long.MAX_VALUE &gt;&gt; <span class="number">1</span>)) ? delay : overflowFree(delay));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面可以看出二者的区别，下一次任务的执行时间，计算公式如下：</p>
<ul>
<li>固定频率 ：上一次任务的执行时间点 + 延时，在这种情况下，如果执行时间大于延时(delay)的话，会出现两个任务的重叠，如果已经错过了下一次任务的执行时间点，提交到DelayedWorkQueue中的任务会马上执行；</li>
<li>固定延时 ：上一次任务执行后的时间（当前时间） + 延时，这种情况下，前后两个任务不会重叠。</li>
</ul>
<p>往下看reExecutePeriodic方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">RunnableScheduledFuture&lt;V&gt; outerTask = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">reExecutePeriodic(outerTask);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reExecutePeriodic</span><span class="params">(RunnableScheduledFuture&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (canRunInCurrentRunState(<span class="keyword">true</span>)) &#123;</span><br><span class="line">        <span class="comment">// 将当前任务加入到DelayedWorkQueue中</span></span><br><span class="line">        <span class="keyword">super</span>.getQueue().add(task);</span><br><span class="line">        <span class="keyword">if</span> (!canRunInCurrentRunState(<span class="keyword">true</span>) &amp;&amp; remove(task))</span><br><span class="line">            task.cancel(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 确保线程池有线程执行</span></span><br><span class="line">            ensurePrestart();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>reExecutePeriodic方法有两个功能：1）将当前任务加入到DelayedWorkQueue中；2）确保线程池有线程执行。</p>
<h3 id="3-6-小结"><a href="#3-6-小结" class="headerlink" title="3.6 小结"></a>3.6 小结</h3><p>ScheduledFutureTask是一个比较重要的类，它包括了这些功能：1）延时任务的比较逻辑；2）执行结果的获取及任务的取消；3）对业务逻辑进行封装执行；4）对周期性任务的支持。我们讲了任务的存储及执行，那么任务的调度是在什么地方呢？接下来讲任务的任务的调度ScheduledThreadPoolExecutor类。</p>
<h2 id="4-ScheduledThreadPoolExecutor"><a href="#4-ScheduledThreadPoolExecutor" class="headerlink" title="4. ScheduledThreadPoolExecutor"></a>4. ScheduledThreadPoolExecutor</h2><p><img src="/images/ScheduledThreadPoolExecutor.jpg" alt="ScheduledThreadPoolExecutor" title="ScheduledThreadPoolExecutor"><br>从继承关系中可以看出，ScheduledThreadPoolExecutor继承了ThreadPoolExecutor类，说明支持普通任务（非周期性任务）的调度，同时实现了ScheduledExecutorService接口，加入了对周期性任务调度的支持。</p>
<h3 id="4-1-非周期性任务的调度"><a href="#4-1-非周期性任务的调度" class="headerlink" title="4.1 非周期性任务的调度"></a>4.1 非周期性任务的调度</h3><p>非周期性任务的调度主要是使用execute/submit方法，在ScheduledThreadPoolExecutor中重写了这两个方法，统一使用schedule方法，如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    schedule(command, <span class="number">0</span>, NANOSECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">return</span> schedule(task, <span class="number">0</span>, NANOSECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>非周期性任务一般是一次性任务，提交之后马上执行，所以延时(delay)设置为0，下面分析schedule方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,</span><br><span class="line">                                   <span class="keyword">long</span> delay,</span><br><span class="line">                                   TimeUnit unit) &#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span> || unit == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 构建ScheduledFutureTask对象</span></span><br><span class="line">    RunnableScheduledFuture&lt;?&gt; t = decorateTask(command,</span><br><span class="line">        <span class="keyword">new</span> ScheduledFutureTask&lt;Void&gt;(command, <span class="keyword">null</span>,</span><br><span class="line">                                      triggerTime(delay, unit)));</span><br><span class="line">    <span class="comment">// 调度执行任务</span></span><br><span class="line">    delayedExecute(t);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>schedule方法主要包含两个步骤：</p>
<ul>
<li>构建ScheduledFutureTask对象，传入的参数包括Runnable对象，返回结果对象及下一次业务执行的时间，前两个参数为会封装到callable属性中，下一次业务执行时间赋值给time属性，执行时间是一个相对于1970-01-01 00:00:00 UTC的差值(ns);</li>
<li>调度执行任务；</li>
</ul>
<p>接着看delayedExecute方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">delayedExecute</span><span class="params">(RunnableScheduledFuture&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果线程池关闭，则拒绝任务</span></span><br><span class="line">    <span class="keyword">if</span> (isShutdown())</span><br><span class="line">        reject(task);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 将任务加入到DelayedWorkQueue中</span></span><br><span class="line">        <span class="keyword">super</span>.getQueue().add(task);</span><br><span class="line">        <span class="keyword">if</span> (isShutdown() &amp;&amp;</span><br><span class="line">            !canRunInCurrentRunState(task.isPeriodic()) &amp;&amp;</span><br><span class="line">            remove(task))</span><br><span class="line">            task.cancel(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 确保有线程去执行任务</span></span><br><span class="line">            ensurePrestart();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，delayedExecute方法有两个主要的功能：1）将任务加入到DelayedWorkQueue中；2）确保有线程去执行任务。加入队列可以参考上面的内容，接下来我们看怎么确保有线程去执行任务。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ensurePrestart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> wc = workerCountOf(ctl.get());</span><br><span class="line">    <span class="keyword">if</span> (wc &lt; corePoolSize)</span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wc == <span class="number">0</span>)</span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ensurePrestart逻辑就是如果线程池线程数小于核心线程数则添加一个线程，另外，如果线程数为0也会添加一个线程，保证线程池中至少有一个线程去执行。</p>
<h3 id="4-2-周期性任务的调度"><a href="#4-2-周期性任务的调度" class="headerlink" title="4.2 周期性任务的调度"></a>4.2 周期性任务的调度</h3><p>1）固定频率的周期性任务<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,</span><br><span class="line">                                              <span class="keyword">long</span> initialDelay,</span><br><span class="line">                                              <span class="keyword">long</span> period,</span><br><span class="line">                                              TimeUnit unit) &#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span> || unit == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (period &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    ScheduledFutureTask&lt;Void&gt; sft =</span><br><span class="line">        <span class="keyword">new</span> ScheduledFutureTask&lt;Void&gt;(command,</span><br><span class="line">                                      <span class="keyword">null</span>,</span><br><span class="line">                                      triggerTime(initialDelay, unit),</span><br><span class="line">                                      unit.toNanos(period)); </span><br><span class="line">    RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft);</span><br><span class="line">    sft.outerTask = t;</span><br><span class="line">    delayedExecute(t);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2）固定延时的周期性任务<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,</span><br><span class="line">                                                 <span class="keyword">long</span> initialDelay,</span><br><span class="line">                                                 <span class="keyword">long</span> delay,</span><br><span class="line">                                                 TimeUnit unit) &#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span> || unit == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    ScheduledFutureTask&lt;Void&gt; sft =</span><br><span class="line">        <span class="keyword">new</span> ScheduledFutureTask&lt;Void&gt;(command,</span><br><span class="line">                                      <span class="keyword">null</span>,</span><br><span class="line">                                      triggerTime(initialDelay, unit),</span><br><span class="line">                                      unit.toNanos(-delay));</span><br><span class="line">    RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft);</span><br><span class="line">    sft.outerTask = t;</span><br><span class="line">    delayedExecute(t);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这两种类型之间的区别仅仅是设置period的不同，固定频率是正数period，固定延时是-delay。</p>
<h3 id="4-3-线程池的创建"><a href="#4-3-线程池的创建" class="headerlink" title="4.3 线程池的创建"></a>4.3 线程池的创建</h3><p>ScheduledThreadPoolExecutor的创建通过Executors.newScheduledThreadPool方法，可以指定一个核心线程数或ThreadFactory类。</p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>通过对DelayedWorkQueue,ScheduledFutureTask和ScheduledThreadPoolExecutor，我们回答了文章开关提到的三个问题：</p>
<p>1）任务是如何存储的？</p>
<p>任务是存储在DelayedWorkQueue中，底层是一个小堆的数据结构。</p>
<p>2）延时及周期性任务什么时候执行及如何执行？</p>
<p>延时及周期性任务根据执行时间点进行排序，时间最小的优先执行，对于周期性任务而言，在上一个任务执行结束之后，会重新计算下一个任务的时间点，把任务重新加入到等待队列中等待调度。线程池线程从等待队列中获取堆顶的任务执行，如果任务未到期，线程需要睡眠指定的时长，这个时长等于任务到期的时长。</p>
<p>3）任务怎么进行取消？</p>
<p>任务取消实际上是将任务的状态更改为CANCELLED或INTERRUPTED，在线程开始执行任务的时候，判断是否取消，如果取消的话则放弃执行。</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/01/synchronousqueue-principles/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/09/01/synchronousqueue-principles/" class="post-title-link" itemprop="http://yoursite.com/page/3/index.html">SynchronousQueue 原理</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-09-01 13:53:11" itemprop="dateCreated datePublished" datetime="2019-09-01T13:53:11+08:00">2019-09-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-07-31 17:17:10" itemprop="dateModified" datetime="2021-07-31T17:17:10+08:00">2021-07-31</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/阻塞队列/" itemprop="url" rel="index"><span itemprop="name">阻塞队列</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇文章主要讲述SynchronousQueue数据结构及在线程池中的应用。</p>
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>在生产者和消费者的线程模型下，生产者线程生产数据（事件，任务等），消费者线程消费数据。通常情况下，它们需要一个中间的数据结构来交换数据，如队列。生成者线程将数据存入队列，若队列满了则阻塞生产者线程，等待消费者线程唤醒；消费者线程从队列取数据，若队列为空则阻塞消费者线程，等待生产者线程唤醒。在这种场景下，如果生产数据过快，队列中会堆积很多数据，如果是无界队列的话，可能会造成问题。现在提供了另外一种选择，即SynchronousQueue，它内部没有容量，生产者线程和消费者线程进行一一匹配，亲手(handoff)交换数据。</p>
<p>SynchronousQueue是一种特殊的阻塞队列，它没有实际的容量，任意线程（生产者线程或者消费者线程，生产类型的操作如put/offer，消费类型的操作如poll/take）都会等待知道获得数据或者交付完成数据才会返回，一个生产者线程的使命是将线程附着着的数据交付给一个消费者线程，而一个消费者线程则是等待一个生产者线程的数据。它们会在匹配到互补线程的时候就会做数据交易，比如生产者线程遇到消费者线程时，或者消费者线程遇到生产者线程时，一个生产者线程就会将数据交付给消费者线程，然后共同退出。<sup>[1]<sup></sup></sup></p>
<p>SynchronousQueue的一个使用场景是在线程池里。Executors.newCachedThreadPool()就使用了SynchronousQueue，这个线程池根据需要（新任务到来时）创建新的线程，如果有空闲线程则会重复使用，线程空闲了60秒后会被回收。因为SynchronousQueue没有容量，因此offer和take会一直阻塞(如果操作允许超时且超时时间为0，没有匹配的线程时则直接返回不回阻塞)，直到有另一个线程已经准备好参与到交付过程中。在线程池中，提交的任务尽量是执行时间短、不会被阻塞，这样才能保证线程的重复使用，否则就会在短时间内生成大量的线程，引起内存被耗尽的问题（一个线程会申请一个线程栈）。</p>
<p>在对SynchronousQueue进一步分析前，先对SynchronousQueue的基本结构及对外接口的接口（方法）做了一个简单的描述，在后面的部分会依赖这些知识点。</p>
<p>SynchronousQueue内部逻辑封装在Transferer的实现类中，该类只有一个transfer方法，put/offer及poll/take都是用它来实现，它的声明如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Transferer</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行put/offer和poll/take方法.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 非空时,表示这个数据对象，需要消费者来消费;</span></span><br><span class="line"><span class="comment">     *          为空时, 则表示当前操作是一个请求操作。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timed 决定是否存在timeout时间。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nanos 超时时长。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果返回非空, 代表数据已经被消费或者正常提供; </span></span><br><span class="line"><span class="comment">     *         如果为空，则表示由于超时或中断导致失败。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> E <span class="title">transfer</span><span class="params">(E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>SynchronousQueue中的put/offer操作主要是生产数据，put操作主要是数据交给消费者，没有匹配的消费者则会调用LockSupport.park阻塞自己，直到有消费者线程唤醒且进行匹配，可以被中断，所以要判断是正常返回还是中断返回；而offer操作主要是尝试将数据交给消费者，如果有匹配的消费者则Transferer.transfer返回数据本身，否则直接返回null,offer根据返回的结果进行判断是是否成功，该方法不会阻塞自己。线程池中使用了offer操作，offer成功表示有消费者线程可以重复使用，否则新建一个线程来运行该任务，方法定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加一个元素到队列中，直到有消费者接收该元素</span></span><br><span class="line"><span class="comment"> * 1）如果没有匹配的线程，则会阻塞调用者线程；</span></span><br><span class="line"><span class="comment"> * 2）如果匹配成功，则直接返回</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 添加的元素</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException 可以被中断</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException 元素为null，则抛出空指针异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (transferer.transfer(e, <span class="keyword">false</span>, <span class="number">0</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Thread.interrupted();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 尝试将元素（数据）交给匹配的线程</span></span><br><span class="line"><span class="comment"> * 1）如果有匹配的消费者线程，交付成功；</span></span><br><span class="line"><span class="comment"> * 2）如果匹配不成功，返回false，不会阻塞调用者线程。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 添加的元素（数据）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果匹配成功（加入到队列）返回true，否则返回false.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException 元素为null，则抛出空指针异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> transferer.transfer(e, <span class="keyword">true</span>, <span class="number">0</span>) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>SynchronousQueue中的poll/take主要是消费数据，take操作是从队列中获取数据，调用该方法会被阻塞直到被向生产者线程唤醒，也可以调用interrupted()中断返回，返回之前需要判断是正常返回还是中断返回；不带参数的poll方法尝试获取数据，如果有数据则返回成功，否则返回失败，不会阻塞调用者线程；在带超时参数的poll方法中，如果没有数据，则会将调用线程睡眠指定时间。线程池中获取数据使用了带超时参数的poll操作，超时时间为60S，如果60S都没有数据，则唤醒该线程重新获取数据，如果仍然没有数据，则释放回收该线程。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取数据，如果没有则进行等待</span></span><br><span class="line"><span class="comment"> * 可以调用中断唤醒线程</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException 中断异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E e = transferer.transfer(<span class="keyword">null</span>, <span class="keyword">false</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    Thread.interrupted();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 尝试获取数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 成功返回队首数据，否则返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> transferer.transfer(<span class="keyword">null</span>, <span class="keyword">true</span>, <span class="number">0</span>);</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 尝试获取数据，成功返回队首数据，否则睡眠指定时间，被唤醒之后重新获获取数据。</span></span><br><span class="line"><span class="comment"> * 可以被中断。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 成功返回队首数据，否则返回null（睡眠指定时间之后，仍然没有数据）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException 中断异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E e = transferer.transfer(<span class="keyword">null</span>, <span class="keyword">true</span>, unit.toNanos(timeout));</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> || !Thread.interrupted())</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>SynchronousQueue有两个版本的Transferer实现，一种为公平模式，一种为非公平模式，公平模式的实现类为TransferQueue，它使用队列来作为存储结构，请求匹配的线程总是先尝试跟队列尾部的线程进行匹配，如果失败再将请求的线程添加到队列尾部，而非公平模式的实现类为TransferStack，它使用一个stack来作为存储结构，请求匹配的线程总是试图与栈顶线程进行匹配，失败则添加到栈顶。下面针对SynchronousQueue的两个版本进行分析。</p>
<h2 id="2-图解TransferStack"><a href="#2-图解TransferStack" class="headerlink" title="2. 图解TransferStack"></a>2. 图解TransferStack</h2><p>非公平模式底层的数据结构是TransferStack，它实际是一个LIFO的栈结构，用head指针指向栈顶，根据栈的LIFO特点，在非公平模式下，匹配操作总是与栈顶元素进行，即与最后一个入栈的元素而不是第一个元素，它的不公平性主要体现在这里。TransferStack及head定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Dual stack */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferStack</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Transferer</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 结点的模式：REQUEST(请求)，DATA(数据)及FULFILLING(正在匹配)  **/</span> </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REQUEST    = <span class="number">0</span>;  <span class="comment">// 请求数据(take/poll)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DATA       = <span class="number">1</span>;  <span class="comment">// 生产数据(put/offer)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FULFILLING = <span class="number">2</span>;  <span class="comment">// 匹配</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 结点 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> SNode next;        <span class="comment">// 指向栈中的下一个结点</span></span><br><span class="line">        <span class="keyword">volatile</span> SNode match;       <span class="comment">// 与该结点匹配的结点</span></span><br><span class="line">        <span class="keyword">volatile</span> Thread waiter;     <span class="comment">// 调用线程</span></span><br><span class="line">        Object item;                <span class="comment">// 数据，请求操作为null</span></span><br><span class="line">        <span class="keyword">int</span> mode;                   <span class="comment">// 模式</span></span><br><span class="line"></span><br><span class="line">        ... <span class="comment">// 略</span></span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/** The head (top) of the stack */</span></span><br><span class="line">    <span class="keyword">volatile</span> SNode head; <span class="comment">// 栈顶结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在以图形的方式来展示TransferStack的工作原理，SynchronousQueue为生产及消费数据提供了阻塞及不阻塞两种接口，两者都是阻塞方式是最复杂的一种情况，现在就以它为例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 生产数据 **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/** 消费数据 **/</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span></span><br></pre></td></tr></table></figure></p>
<p>在实例中SNode的内存布局如下所示:<br><img src="/images/snode.jpg" alt="snode" title="snode"></p>
<p>操作序列如下：</p>
<p><strong>1、TransferStack初始状态</strong></p>
<p><img src="/images/transferstack-null.jpg" alt="transferstack-null" title="transferstack-null"><br>栈顶元素head初始状态指向NULL。</p>
<p><strong>2、生产者线程t1执行 put(task1)操作</strong><br>TransferStack栈中没有元素，构造SNode结点SNode1，结点内容如下：</p>
<ul>
<li>mode : 1，表示为数据模式；</li>
<li>item : task1，表示需要传递给消费者的数据；</li>
<li>waiter : t1，表示生产者线程；</li>
<li>match : null，表示没有匹配的结点；</li>
<li>next : null，表示下一个结点。</li>
</ul>
<p>将SNode1结点压入TransferStack栈中，调用LockSupport.park方法阻塞t1线程，等待消费者线程唤醒。<br><img src="/images/transferstack-1.jpg" alt="transferstack-1" title="transferstack-1"></p>
<p><strong>3、生产者线程t2执行 put(task2)操作</strong></p>
<p>生产者线程t2执行的操作是生产数据，与TransferStack栈顶元素的mode是一致的，构造新的结点SNode2，并将该结点压入栈首，内容如下：</p>
<ul>
<li>mode : 1，表示为数据模式；</li>
<li>item : task2，表示需要传递给消费者的数据；</li>
<li>waiter : t2，表示生产者线程；</li>
<li>match : null，表示没有匹配的结点；</li>
<li>next : SNode1，表示下一个结点。</li>
</ul>
<p>最后阻塞t2线程，等待消费者线程唤醒。</p>
<p><img src="/images/transferstack-2.jpg" alt="transferstack-2" title="transferstack-2"></p>
<p><strong>4、消费者线程t3执行 take()操作</strong></p>
<p>消费者线程t3执行REQUEST操作，与TransferStack栈顶元素的mode是互补（FULFILLING）的，此时也会构造一个新结点SNode3，加入到栈中，内容如下：</p>
<ul>
<li>mode : 3，DATA与FULFILLING取或操作，即1 | 2 = 3, 表示正在进行匹配操作；</li>
<li>item : null，请求（REQUEST）操作没有数据；</li>
<li>waiter : t3，表示生产者线程；</li>
<li>match : null，表示没有匹配的结点；</li>
<li>next : SNode2，表示下一个结点。</li>
</ul>
<p>SNode3压入栈顶之后，同时尝试修改与之匹配的SNode2结点，将SNode2中的match字段修改为SNode3，表示与之匹配的结点，此时栈的状态如下所示：</p>
<p><img src="/images/transferstack-3.jpg" alt="transferstack-3" title="transferstack-3"></p>
<p>完成匹配操作之后，t3线程LockSupport.unpark方法唤醒t2线程，并将SNode3及SNode2弹出栈，其状态如下所示：</p>
<p><img src="/images/transferstack-4.jpg" alt="transferstack-4" title="transferstack-4"></p>
<p>最后消费者t3线程拿到生产者线程生产的数据task2，生产者线程t2被唤醒继续执行后续流程。</p>
<p><strong>5、消费者线程t4执行 take()操作</strong></p>
<p>与第4步的操作类似，此时执行的互补（FULFILLING）操作，新构建一个结点SNode4，并压入栈中，其状态如下所示：<br><img src="/images/transferstack-5.jpg" alt="transferstack-5" title="transferstack-5"></p>
<p>最后将两个结点弹出栈，此时栈中没有结点，回到初始状态，如第1步所示，同时t4线程拿到t1线程的数据task1。</p>
<h2 id="3-图解TransferQueue"><a href="#3-图解TransferQueue" class="headerlink" title="3. 图解TransferQueue"></a>3. 图解TransferQueue</h2><p>公平模式底层的数据结构是TransferQueue，它是一个队列结构。head引用指向队列头结点，而tail指向尾结点。它的公平体现在匹配的操作是从队列的第一个元素开始进行的。下面是TransferQueue的定义。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Dual Queue */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Transferer</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/** Node class for TransferQueue. */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">QNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> QNode next;          <span class="comment">// 指向队列中的下一个结点</span></span><br><span class="line">        <span class="keyword">volatile</span> Object item;         <span class="comment">// 存放数据，请求为null</span></span><br><span class="line">        <span class="keyword">volatile</span> Thread waiter;       <span class="comment">// 被阻塞的线程</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isData;         <span class="comment">// 是否数据</span></span><br><span class="line"></span><br><span class="line">        ... <span class="comment">// 略</span></span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/** Head of queue */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> QNode head;  <span class="comment">// 指向头结点</span></span><br><span class="line">    <span class="comment">/** Tail of queue */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> QNode tail;  <span class="comment">// 指向尾结点</span></span><br><span class="line"></span><br><span class="line">    ... <span class="comment">// 略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>QNode的内存布局如下所示：<br><img src="/images/qnode.jpg" alt="qnode" title="qnode"></p>
<p>以上章的操作顺序来请求数据。</p>
<p><strong>1、TransferQueue初始状态</strong></p>
<p><img src="/images/transferqueue-null.jpg" alt="transferqueue-null" title="transferqueue-null"></p>
<p>构建一个Dummy Node压入队列，当head,tail指向同一个结点表示队列为空。</p>
<p><strong>2、生产者线程t1执行 put(task1)操作</strong><br>TransferQueue队列为空，构造QNode结点QNode1，结点内容如下：</p>
<ul>
<li>isData : true，表示为数据模式；</li>
<li>item : task1，表示需要传递给消费者的数据；</li>
<li>waiter : t1，表示生产者线程；</li>
<li>next : null，表示下一结点为空。</li>
</ul>
<p>将QNode1结点压入TransferQueue队尾，调用LockSupport.park方法阻塞t1线程，等待消费者线程唤醒。<br><img src="/images/transferqueue-1.jpg" alt="transferqueue-1" title="transferqueue-1"></p>
<p><strong>3、生产者线程t2执行 put(task2)操作</strong></p>
<p>生产者线程t2执行的操作是生产数据，与TransferQueue队首元素的isData是一样的，表示模式是一致的，构造新的结点PNode2，并将该结点压入队尾，内容如下：</p>
<ul>
<li>isData : true，表示为数据模式；</li>
<li>item : task2，表示需要传递给消费者的数据；</li>
<li>waiter : t2，表示生产者线程；</li>
<li>next : null，表示下一结点为空。</li>
</ul>
<p>最后阻塞t2线程，等待消费者线程唤醒。</p>
<p><img src="/images/transferqueue-2.jpg" alt="transferqueue-2" title="transferqueue-2"></p>
<p><strong>4、消费者线程t3执行 take()操作</strong></p>
<p>消费者线程t3执行REQUEST操作，跟TransferQueue队首元素的模式是互补（FULFILLING）的，此时与TransferStack的操作不一样，不用生成新结点压入队列。它执行了以下操作：1）将PNode1(队首)元素设置为参数e，在这里是null，完成数据的交接（如果是put操作的话，传递的就是真实的数据）；2）将head指针指向PNode1，PNode1作为新的Dummy Node（等于将PNode1移除队列）；3）唤醒PNode1对应的线程，即t1。</p>
<p><img src="/images/transferqueue-3.jpg" alt="transferqueue-3" title="transferqueue-3"></p>
<p>最后t3从PNode1中拿出数据task1并返回，生产者线程t1被唤醒继续执行后续流程。</p>
<p><strong>5、消费者线程t4执行 take()操作</strong></p>
<p>与第4步的操作类似，此时执行的互补（FULFILLING）操作，队列状态如下所示：<br><img src="/images/transferqueue-4.jpg" alt="transferqueue-4" title="transferqueue-4"></p>
<p>回到初始状态，如第1步所示，同时t4线程拿到t2线程的数据task2，t2线程被唤醒。</p>
<h2 id="4-代码分析"><a href="#4-代码分析" class="headerlink" title="4. 代码分析"></a>4. 代码分析</h2><p>现在以TransferStack为例，分析SynchronousQueue的流程。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Puts or takes an item.</span></span><br><span class="line"><span class="comment"> * put和take方法都调用这个方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function">E <span class="title">transfer</span><span class="params">(E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    SNode s = <span class="keyword">null</span>; <span class="comment">// constructed/reused as needed</span></span><br><span class="line">    <span class="comment">// 判断请求的模型：e为null表示消费数据，不为空为消费数据</span></span><br><span class="line">    <span class="keyword">int</span> mode = (e == <span class="keyword">null</span>) ? REQUEST : DATA;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        SNode h = head;</span><br><span class="line">        <span class="comment">// 1.  栈为空或请求与栈顶节点模式相同，根据情况入栈</span></span><br><span class="line">        <span class="keyword">if</span> (h == <span class="keyword">null</span> || h.mode == mode) &#123;  <span class="comment">// empty or same-mode</span></span><br><span class="line">            <span class="comment">// 1.1 设置了超时且超时时间小于等于0，则直接返回不用等待</span></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0</span>) &#123;      <span class="comment">// can't wait</span></span><br><span class="line">                <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.isCancelled())</span><br><span class="line">                    casHead(h, h.next);     <span class="comment">// pop cancelled node</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;  <span class="comment">// 如果栈为空，offer操作直接返回null</span></span><br><span class="line">            <span class="comment">// 1.2 没有设置超时或超时未到，则构建SNode，压入栈顶</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (casHead(h, s = snode(s, e, h, mode))) &#123;</span><br><span class="line">                <span class="comment">// 1.2.1 自旋等待或启用LockSupport.park阻塞调用线程</span></span><br><span class="line">                SNode m = awaitFulfill(s, timed, nanos);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 1.2.2 被唤醒之后判断是否被取消</span></span><br><span class="line">                <span class="keyword">if</span> (m == s) &#123;               <span class="comment">// wait was cancelled</span></span><br><span class="line">                    clean(s);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 1.2.3 将栈顶元素出栈</span></span><br><span class="line">                <span class="keyword">if</span> ((h = head) != <span class="keyword">null</span> &amp;&amp; h.next == s)</span><br><span class="line">                    casHead(h, s.next);     <span class="comment">// help s's fulfiller</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 1.2.4 返回结果</span></span><br><span class="line">                <span class="keyword">return</span> (E) ((mode == REQUEST) ? m.item : s.item);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 2. 请求结点与栈顶结点是互补模式，则进行匹配操作</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isFulfilling(h.mode)) &#123; <span class="comment">// try to fulfill</span></span><br><span class="line">            <span class="comment">// 2.1 如果栈顶结点已经被取消，则将栈顶结点出栈</span></span><br><span class="line">            <span class="keyword">if</span> (h.isCancelled())            <span class="comment">// already cancelled</span></span><br><span class="line">                casHead(h, h.next);         <span class="comment">// pop and retry</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 2.2 构建新结点，模式设置为FULFILLING，并压入栈顶</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (casHead(h, s=snode(s, e, h, FULFILLING|mode))) &#123;</span><br><span class="line">                <span class="keyword">for</span> (;;) &#123; <span class="comment">// loop until matched or waiters disappear</span></span><br><span class="line">                    SNode m = s.next;       <span class="comment">// m is s's match</span></span><br><span class="line">                    <span class="comment">// 2.2.1 如果匹配的结点的为空，则将栈置空，然后重试</span></span><br><span class="line">                    <span class="keyword">if</span> (m == <span class="keyword">null</span>) &#123;        <span class="comment">// all waiters are gone</span></span><br><span class="line">                        casHead(s, <span class="keyword">null</span>);   <span class="comment">// pop fulfill node</span></span><br><span class="line">                        s = <span class="keyword">null</span>;           <span class="comment">// use new node next time</span></span><br><span class="line">                        <span class="keyword">break</span>;              <span class="comment">// restart main loop</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    SNode mn = m.next;</span><br><span class="line">                    <span class="comment">// 2.2.2 两个结点尝试匹配，如果匹配成功，</span></span><br><span class="line">                    <span class="comment">// 则唤醒被匹配结点对应的线程</span></span><br><span class="line">                    <span class="keyword">if</span> (m.tryMatch(s)) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 2.2.2.1 匹配成功之后，将栈顶两个节点出栈，并返回结果</span></span><br><span class="line">                        casHead(s, mn);     <span class="comment">// pop both s and m</span></span><br><span class="line">                        <span class="keyword">return</span> (E) ((mode == REQUEST) ? m.item : s.item);</span><br><span class="line">                    &#125; <span class="keyword">else</span>                  <span class="comment">// lost match</span></span><br><span class="line">                        s.casNext(m, mn);   <span class="comment">// help unlink</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 3. 栈顶已经存在一个FULFILLING模式的结点，则帮助该结点完成匹配，</span></span><br><span class="line">        <span class="comment">//    然后自己再进行匹配</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                            <span class="comment">// help a fulfiller</span></span><br><span class="line">            SNode m = h.next;               <span class="comment">// m is h's match</span></span><br><span class="line">            <span class="comment">// 3.1 跟2.1一样</span></span><br><span class="line">            <span class="keyword">if</span> (m == <span class="keyword">null</span>)                  <span class="comment">// waiter is gone</span></span><br><span class="line">                casHead(h, <span class="keyword">null</span>);           <span class="comment">// pop fulfilling node</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                SNode mn = m.next;</span><br><span class="line">                <span class="comment">// 3.2 尝试将栈顶两个元素进行匹配，</span></span><br><span class="line">                <span class="keyword">if</span> (m.tryMatch(h))          <span class="comment">// help match</span></span><br><span class="line">                    casHead(h, mn);         <span class="comment">// pop both h and m</span></span><br><span class="line">                <span class="keyword">else</span>                        <span class="comment">// lost match</span></span><br><span class="line">                    h.casNext(m, mn);       <span class="comment">// help unlink</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码主要分为三种情况：</p>
<ol>
<li><p>如果当前的栈是空的，或者包含与请求节点模式相同的节点，那么就将这个请求的节点作为新的栈顶节点，等待被下一个请求的节点匹配，最后会返回匹配节点的数据或者null，如果被取消则会返回null。</p>
</li>
<li><p>如果当前栈不为空，并且请求的节点和当前栈顶节点模式互补，那么将这个请求的节点的模式变为FULFILLING，然后将其压入栈中，和互补的节点进行匹配，完成匹配之后将两个节点一起弹出，并且返回交易的数据。</p>
</li>
<li><p>如果栈顶已经存在一个模式为FULFILLING的节点，说明栈顶的节点正在进行匹配，那么就帮助这个栈顶节点快速完成匹配，然后继续匹配。</p>
</li>
</ol>
<p>主要方法说明：</p>
<ol>
<li><p>casHead : 通过CAS操作将nh设置为新的栈顶结点；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">casHead</span><span class="params">(SNode h, SNode nh)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h == head &amp;&amp;</span><br><span class="line">        UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, headOffset, h, nh);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>awaitFulfill : 自旋或阻塞一个节点，直到找到一个匹配的结点；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SNode <span class="title">awaitFulfill</span><span class="params">(SNode s, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 计算超时时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">    Thread w = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> spins = (shouldSpin(s) ?</span><br><span class="line">                 (timed ? maxTimedSpins : maxUntimedSpins) : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (w.isInterrupted())</span><br><span class="line">            s.tryCancel();</span><br><span class="line">        SNode m = s.match;</span><br><span class="line">        <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                s.tryCancel();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 自旋</span></span><br><span class="line">        <span class="keyword">if</span> (spins &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 如果是cpu是多核，则进行自旋</span></span><br><span class="line">            spins = shouldSpin(s) ? (spins-<span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s.waiter == <span class="keyword">null</span>)</span><br><span class="line">            s.waiter = w; <span class="comment">// establish waiter so can park next iter</span></span><br><span class="line">        <span class="comment">// 如果没有设置超时，则直接阻塞调用者线程</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!timed)</span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 如果设置超时时间，则设置阻塞时间</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; spinForTimeoutThreshold)</span><br><span class="line">            LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>tryMatch : 尝试匹配结点，如果匹配成功则唤醒结点对应的线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryMatch</span><span class="params">(SNode s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (match == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, matchOffset, <span class="keyword">null</span>, s)) &#123;</span><br><span class="line">        Thread w = waiter;</span><br><span class="line">        <span class="keyword">if</span> (w != <span class="keyword">null</span>) &#123;    <span class="comment">// waiters need at most one unpark</span></span><br><span class="line">            waiter = <span class="keyword">null</span>;</span><br><span class="line">            LockSupport.unpark(w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> match == s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="5-线程池应用"><a href="#5-线程池应用" class="headerlink" title="5. 线程池应用"></a>5. 线程池应用</h2><p>SynchronousQueue的一个使用场景是线程池，使用它的目的就是保证“对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务”。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心线程数为0，空闲时间为60S，最大线程数为整数的最大值。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先看下线程池的任务提交流程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 第1步</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 第2步</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 第3步</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>提交任务有在三个步骤：</p>
<ol>
<li>如果当前工作线程数小于“核心线程数”，则创建一个工作线程来执行task，在这里，由于“核心线程数”等于0，会跳过这个步骤，执行第2步；</li>
<li>将任务加入到工作队列（SynchronousQueue）中，如果添加成功表示将任务交付给工作线程了，如果没有成功则执行第3步；</li>
<li>如果加入到工作队列失败，会尝试创建一个工作线程来执行任务，如果工作线程数小于最大线程数（Integer.MAX_VALUE）,正常情况下，工作线程会创建成功，如果创建失败则会执行“拒绝策略”。</li>
</ol>
<p>结合SynchronousQueue，我们来分析下线程池的执行流程：</p>
<ol>
<li>由于“核心线程数”等于0，会跳过第1个步骤；</li>
<li>在第2步中，提交任务采用的是offer操作，在上面的内容我们提到，offer尝试将数据（任务）交给匹配的线程：</li>
</ol>
<ul>
<li>如果有匹配的工作者线程，交付成功；</li>
<li>如果匹配不成功，返回false，不会阻塞调用者线程；<br>在这里分为两种情况，1）刚开始，没有工作线程，SynchronousQueue队列为空，offer操作失败，继续执行第3步；2）执行一段时间后，SynchronousQueue中有工作线程，数据交付成功，直接返回；</li>
</ul>
<ol start="3">
<li>交付失败后，会尝试新建一个工作线程来执行任务，由于最大线程数设置为Integer.MAX_VALUE，线程都会创建成功，而不会被拒绝。在这里，线程数没有做限制，存在线程创建过多导致内存溢出的风险。</li>
</ol>
<p>分析了提交任务（offer）,再来看获取任务的流程，获取任务的流程在工作线程的执行代码中，工作线程一直会从SynchronousQueue中获取任务，如果空闲时间超过60S则会回收该工作线程。我们来看下工作线程中获取任务的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>获取任务的关键代码主要是这行语句：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS)</span><br></pre></td></tr></table></figure></p>
<p>这行语句有如下功能：获取任务，如果没有匹配的操作，则会阻塞60S，这里的60S就是线程空闲时间；如果有匹配的操作，则直接获取交付的数据。在这里，如果是超时返回的话，该工作线程会退出，且工作线程的数量会减1。</p>
<p>通过上面的分析，我们可以看出，提交任务使用不阻塞的offer方法，获取任务使用带超时的阻塞方法poll。不管offer成功与否，总能保证有工作线程去马上去执行任务，如果没有可复用的工作线程，则会创建一个新的工作线程来执行，另外SynchronousQueue只会阻塞工作线程，即队列中只会有工作线程，不会有提交任务的线程。</p>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>这篇文章分析了SynchronousQueue的底层数据结构及在线程池中的运用，并对相关代码进行了分析，希望能够对想了解SynchronousQueue的同学有所帮助。</p>
<p><strong>参考：</strong></p>
<hr>
<p><a href="https://www.jianshu.com/p/376d368cb44f" target="_blank" rel="noopener">1. Java阻塞队列SynchronousQueue详解</a></p>
<p><a href="http://cmsblogs.com/?p=2418" target="_blank" rel="noopener">2. 【死磕Java并发】—–J.U.C之阻塞队列：SynchronousQueue</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/17/synchronized-principles/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/17/synchronized-principles/" class="post-title-link" itemprop="http://yoursite.com/page/3/index.html">Synchronized 原理</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-08-17 18:11:20" itemprop="dateCreated datePublished" datetime="2019-08-17T18:11:20+08:00">2019-08-17</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-07-31 17:17:10" itemprop="dateModified" datetime="2021-07-31T17:17:10+08:00">2021-07-31</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/并发编程/" itemprop="url" rel="index"><span itemprop="name">并发编程</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>之前在讲ReentrantLock时，在Java中实现线程的同步与互斥，除了JUC中提供的各种锁，还可以使用snchronized关键字，它被用于方法及方法块中，在JDK1.6之前，synchronized是基于monitor锁对象来实现的，而moniter对象是基于操作系统的futex来实现的，相对比较重量级，这种锁也被称为“重量级锁”。所以，在JDK1.6之后，JDK对synchronized进行了种种优化，为了减少获得锁和释放锁所带来的性能消耗，提高性能，引入了“轻量级锁”和“偏向锁”。<br>引入“轻量级锁”和“偏向锁”之后，synchronized锁有四种状态，即之前的“无锁”和“重量级锁”，再加上现在这两种，这四种状态有不同的使用场景，如下图所示：<br><img src="/images/Synchronized-lock-classify.jpeg" alt="Synchronized-lock-classify" title="Synchronized-lock-classify"></p>
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>synchronized锁一共有4种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁和重量级锁。锁状态只能升级不能降级，转换升级的整体流程如下所示：<br><img src="/images/synchronized-overview.jpg" alt="synchronized-overview" title="synchronized-overview"></p>
<p><strong>重要的概念：</strong></p>
<ul>
<li>对象头：在Java中，每一个对象都可以作为锁，锁的相关信息存储在每一个对象头的Mark Word（标记字段）中；</li>
<li>偏向锁：在无锁状态下，如果系统支持偏向锁（默认支持），线程使用CAS修改Mark Word的thread id字段，如果修改成功则获得偏向锁。</li>
<li>轻量级锁：如果获取偏向锁失败，当前线程会向VM线程提交撤销偏向锁的任务，提交任务后，当前线程会被阻塞，直到任务结束后才会被VM线程唤醒。VM线程执行撤销任务，这时候JVM会进入安全点，所有运行的java线程都会被阻塞（包括获取偏向锁的线程）。在VM线程中，会检查获取锁的线程的状态，如果线程已经不活动或不在同步块中，则将锁状态改为无锁状态；如果线程还在同步块中，则将锁状态升级为轻量级锁，之前获取偏向锁的线程持有轻量级锁。执行完操作之后唤醒被阻塞的当前线程，且退出安全点，所有阻塞在安全点上的线程也会被唤醒；</li>
<li>重量级锁：当前线程被唤醒之后，如果锁是无锁状态，则直接获取锁，否则膨胀为重量级锁。在膨胀过程中，会执行以下操作：1）分配monitor对象；2）锁的_owner设置为之前获取锁的线程；3）将当前线程加入到monitor等待队列中，并阻塞当前线程。</li>
</ul>
<h2 id="2-相关概念"><a href="#2-相关概念" class="headerlink" title="2.相关概念"></a>2.相关概念</h2><h3 id="2-1-Java对象头"><a href="#2-1-Java对象头" class="headerlink" title="2.1 Java对象头"></a>2.1 Java对象头</h3><p>在上面的内容讲到，在Java中任何对象都可以作为锁，锁的相关信息都保存在Java的对象头中，我们以Hotspot虚拟机为例，Hotspot的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。<br><strong>Mark Word：</strong> 默认存储对象的HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。在32位系统上Mark Word长度为32bit，64位系统上长度为64bit，在32位系统上各状态的格式如下所示：<br><img src="/images/methord-header.jpg" alt="methord-header" title="methord-header"><br>锁信息存于对象的Mark Word中，当对象状态为偏向锁（biasable）时，Mark Word存储的是偏向的线程ID；当状态为轻量级锁（lightweight locked）时，Mark Word存储的是指向线程栈中Lock Record的指针；当状态为重量级锁（inflated）时，为指向堆中的monitor对象的指针。</p>
<p><strong>Klass Point：</strong> 对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p>
<h3 id="2-2-Monitor对象"><a href="#2-2-Monitor对象" class="headerlink" title="2.2 Monitor对象"></a>2.2 Monitor对象</h3><p>在“重量级”锁中，每一个锁都持有一个monitor对象，等同于ReentrantLock中AQS对象，实现等待队列的管理、线程的等待及唤醒等功能，同样地，线程的等待及唤醒借助于操作系统的futex来实现。在上面一节中，如果是重量级锁状态下，Mark Word中存储了Monitor对象的引用，从而建立起了对象锁与monitor对象的映射关系，其关系如下所示：<br><img src="/images/monitor-object.jpg" alt="monitor-object" title="monitor-object"><br>一个monitor对象包括这么几个关键字段：_cxq，_EntryList ，_WaitSet，_owner。其中_cxq ，_EntryList ，_WaitSet都是由ObjectWaiter的链表结构，_owner指向持有锁的线程。<br>当一个线程尝试获得锁时(lock)，如果该锁已经被占用，则会将该线程封装成一个ObjectWaiter对象插入到_cxq的队列头部，然后阻塞当前线程。当持有锁的线程释放锁(unlock)时，会根据不同的策略取_cxq或_EntryList的中的对象来进行唤醒。<br>如果一个线程在同步块中调用了Object#wait方法，会创建对应的ObjectWaiter并加入到WaitSet中，然后释放锁。当wait的线程被notify之后，会将对应的ObjectWaiter从_WaitSet移动到_EntryList中。</p>
<h3 id="2-3-安全点（safepoint）"><a href="#2-3-安全点（safepoint）" class="headerlink" title="2.3 安全点（safepoint）"></a>2.3 安全点（safepoint）</h3><p>在第一章中讲到偏向锁的撤销是在VM线程中执行，所有的Java线程都进入安全点，即所有线程都被阻塞（stop the world），从而保证对持有锁的线程的更改是原子的。那么安全点是什么？怎么保证所有的线程都暂停？</p>
<p>safepoint安全点顾名思义是指一些特定的位置，当线程运行到这些位置时，线程的一些状态可以被确定(the thread’s representation of it’s Java machine state is well described)，比如记录OopMap的状态，从而确定GC Root的信息，使JVM可以安全的进行一些操作，比如开始GC。<br>safepoint指的特定位置主要有:</p>
<ol>
<li>循环的末尾 (防止大循环的时候一直不进入safepoint，而其他线程在等待它进入safepoint)</li>
<li>方法返回前</li>
<li>调用方法的call之后</li>
<li>抛出异常的位置</li>
</ol>
<p>safepoint使用场景主要有：</p>
<ol>
<li>Garbage collection pauses</li>
<li>Code deoptimization</li>
<li>Flushing code cache</li>
<li>Class redefinition (e.g. hot swap or instrumentation)</li>
<li><strong>Biased lock revocation</strong></li>
<li>Various debug operation (e.g. deadlock check or stacktrace dump</li>
</ol>
<p>JVM有两种执行方式：解释型和编译型(JIT)，JVM要保证这两种执行方式下safepoint都能工作。</p>
<p>在JIT执行方式下，JIT编译的时候直接把safepoint的检查代码加入了生成的本地代码，当JVM需要让Java线程进入safepoint的时候，只需要设置一个标志位，让Java线程运行到safepoint的时候主动检查这个标志位，如果标志被设置，那么线程被阻塞，如果没有被设置，那么继续执行。</p>
<p>例如hotspot在x86中为轮询safepoint会生成一条类似于“test %eax,0x160100”的指令，JVM需要进入gc前，先把0x160100设置为不可读，那所有线程执行到检查0x160100的test指令后都会被阻塞。</p>
<p>在解释器执行方式下，JVM会设置一个2字节的dispatch tables,解释器执行的时候会经常去检查这个dispatch tables，当有safepoint请求的时候，就会让线程去进行safepoint检查。</p>
<h2 id="3-锁实现"><a href="#3-锁实现" class="headerlink" title="3. 锁实现"></a>3. 锁实现</h2><h3 id="3-1-无锁"><a href="#3-1-无锁" class="headerlink" title="3.1 无锁"></a>3.1 无锁</h3><p>无锁没有对资源进行锁定，所有的线程通过CAS操作来获取锁，同时只有一个线程获取成功。</p>
<h3 id="3-2-偏向锁"><a href="#3-2-偏向锁" class="headerlink" title="3.2 偏向锁"></a>3.2 偏向锁</h3><p>在JDK1.6中为了<strong>提高一个对象在一段很长的时间内都只被一个线程用做锁对象场景下的性能</strong>，引入了偏向锁，在第一次获得锁时，会有一个CAS操作，之后该线程再获取锁，只需要判断线程id与Mark Word中的thread id一致即可。</p>
<p><strong>对象创建</strong></p>
<p>当JVM启用了偏向锁模式（1.6以上默认开启），当新创建一个对象的时候，如果该对象所属的class没有关闭偏向锁模式（什么时候会关闭一个class的偏向模式下文会说，默认所有class的偏向模式都是是开启的），那新创建对象的Mark Word将是可偏向状态，此时Mark Word中的thread id为0，表示未偏向任何线程，也叫做匿名偏向(anonymously biased)。</p>
<p><strong>加锁过程</strong></p>
<p>case 1：当该对象第一次被线程获得锁的时候，发现是匿名偏向状态，则会用CAS指令，将Mark Word中的thread id由0改成当前线程Id。如果成功，则代表获得了偏向锁，继续执行同步块中的代码。否则，将偏向锁撤销，升级为轻量级锁。如下代码所示：<a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/9ce27f0a4683/src/share/vm/interpreter/bytecodeInterpreter.cpp#l1881" target="_blank" rel="noopener">bytecodeInterpreter.cpp#l1881</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// try to bias towards thread in case object is anonymously biased</span></span><br><span class="line">markOop header = (markOop) ((<span class="keyword">uintptr_t</span>) mark </span><br><span class="line">        &amp; ((<span class="keyword">uintptr_t</span>)markOopDesc::biased_lock_mask_in_place</span><br><span class="line">        | <span class="keyword">uintptr_t</span>)markOopDesc::age_mask_in_place</span><br><span class="line">        | epoch_mask_in_place));</span><br><span class="line"><span class="keyword">if</span> (hash != markOopDesc::no_hash) &#123;</span><br><span class="line">    header = header-&gt;copy_set_hash(hash);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将线程id设置为当前线程id</span></span><br><span class="line">markOop new_header = (markOop) ((<span class="keyword">uintptr_t</span>) header | thread_ident);</span><br><span class="line"><span class="comment">// debugging hint</span></span><br><span class="line">DEBUG_ONLY(entry-&gt;lock()-&gt;set_displaced_header((markOop) (<span class="keyword">uintptr_t</span>) <span class="number">0xdeaddead</span>);)</span><br><span class="line"><span class="comment">// 执行CAS操作，操作成功即可获得偏向锁</span></span><br><span class="line"><span class="keyword">if</span> (Atomic::cmpxchg_ptr((<span class="keyword">void</span>*)new_header, lockee-&gt;mark_addr(), header) == header) &#123;</span><br><span class="line">    <span class="keyword">if</span> (PrintBiasedLockingStatistics)</span><br><span class="line">		(* BiasedLocking::anonymously_biased_lock_entry_count_addr())++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 失败则升级到轻量级锁</span></span><br><span class="line">     CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);</span><br><span class="line">&#125;</span><br><span class="line">success = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></p>
<p>case 2：当被偏向的线程再次进入同步块时，发现锁对象偏向的就是当前线程，在通过一些额外的检查后，会往当前线程的栈中添加一条Displaced Mark Word为空的Lock Record中，然后继续执行同步块的代码，因为操纵的是线程私有的栈，因此不需要用到CAS指令；由此可见偏向锁模式下，当被偏向的线程再次尝试获得锁时，仅仅进行几个简单的操作就可以了，在这种情况下，synchronized关键字带来的性能开销基本可以忽略。</p>
<p>case 3：当其他线程进入同步块时，发现已经有偏向的线程了，则会进入到撤销偏向锁的逻辑里，一般来说，会在safepoint中去查看偏向的线程是否还存活，如果存活且还在同步块中则将锁升级为轻量级锁，原偏向的线程继续拥有锁，当前线程则走入到锁升级的逻辑里；如果偏向的线程已经不存活或者不在同步块中，则将对象头的Mark Word改为无锁状态（unlocked），之后再升级为轻量级锁。</p>
<p>由此可见，偏向锁升级的时机为：当锁已经发生偏向后，只要有另一个线程尝试获得偏向锁，则该偏向锁就会升级成轻量级锁。</p>
<p><strong>解锁过程</strong></p>
<p>当有其他线程尝试获得锁时，是根据遍历偏向线程的Lock Record来确定该线程是否还在执行同步块中的代码。因此偏向锁的解锁很简单，仅仅将栈中的最近一条Lock Record的obj字段设置为null。需要注意的是，偏向锁的解锁步骤中并不会修改对象头中的thread id。</p>
<p>偏向锁在JDK 6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态。</p>
<p><strong>Lock Record</strong></p>
<p>当前线程每一次进入同步块时都会分配一个Lock Record对象，并将该对象的obj字段指向锁对象，并在解锁的时候将该字段设置为null。在VM线程中执行撤销操作时判断该字段即可知道是否还在同步块中，代码：<a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/9ce27f0a4683/src/share/vm/interpreter/bytecodeInterpreter.cpp#l1816" target="_blank" rel="noopener">bytecodeInterpreter.cpp#l1816</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置Lock Record对象</span></span><br><span class="line">CASE(_monitorenter): &#123;</span><br><span class="line">    <span class="comment">// lockee为锁对象</span></span><br><span class="line">    oop lockee = STACK_OBJECT(<span class="number">-1</span>);</span><br><span class="line">    <span class="comment">// derefing's lockee ought to provoke implicit null check</span></span><br><span class="line">    CHECK_NULL(lockee);</span><br><span class="line">    <span class="comment">// find a free monitor or one already allocated for this object</span></span><br><span class="line">    <span class="comment">// if we find a matching object then we need a new monitor</span></span><br><span class="line">    <span class="comment">// since this is recursive enter</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 找到一个空闲的Lock Record对象</span></span><br><span class="line">    BasicObjectLock* limit = istate-&gt;monitor_base();</span><br><span class="line">    BasicObjectLock* most_recent = (BasicObjectLock*) istate-&gt;stack_base();</span><br><span class="line">    BasicObjectLock* entry = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (most_recent != limit ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (most_recent-&gt;obj() == <span class="literal">NULL</span>) entry = most_recent;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (most_recent-&gt;obj() == lockee) <span class="keyword">break</span>;</span><br><span class="line">        most_recent++;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span> (entry != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 将obj字段指向lockee</span></span><br><span class="line">        entry-&gt;set_obj(lockee);</span><br><span class="line">		... <span class="comment">// 略</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	... <span class="comment">// 略</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解锁清空Lock Record对象</span></span><br><span class="line">CASE(_monitorexit): &#123;</span><br><span class="line">    oop lockee = STACK_OBJECT(<span class="number">-1</span>);</span><br><span class="line">    CHECK_NULL(lockee);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// derefing's lockee ought to provoke implicit null check</span></span><br><span class="line">    <span class="comment">// find our monitor slot</span></span><br><span class="line">    BasicObjectLock* limit = istate-&gt;monitor_base();</span><br><span class="line">    BasicObjectLock* most_recent = (BasicObjectLock*) istate-&gt;stack_base();</span><br><span class="line">    <span class="keyword">while</span> (most_recent != limit ) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((most_recent)-&gt;obj() == lockee) &#123;</span><br><span class="line">            BasicLock* lock = most_recent-&gt;lock();</span><br><span class="line">            markOop header = lock-&gt;displaced_header();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置Lock Record对象obj为空，退出同步块</span></span><br><span class="line">            most_recent-&gt;set_obj(<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span> (!lockee-&gt;mark()-&gt;has_bias_pattern()) &#123;</span><br><span class="line">              <span class="keyword">bool</span> call_vm = UseHeavyMonitors;</span><br><span class="line">              <span class="comment">// If it isn't recursive we either must swap old header or call the runtime</span></span><br><span class="line">              <span class="keyword">if</span> (header != <span class="literal">NULL</span> || call_vm) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 轻量级锁逻辑：lockee不指向Lock Record对象，说明锁升级为重量级锁，否则将锁设置为无锁状态</span></span><br><span class="line">                <span class="keyword">if</span> (call_vm || Atomic::cmpxchg_ptr(header, lockee-&gt;mark_addr(), lock) != lock) &#123;</span><br><span class="line">                  <span class="comment">// restore object for the slow case</span></span><br><span class="line">                  most_recent-&gt;set_obj(lockee);</span><br><span class="line">                  <span class="comment">// 膨胀为重量级锁</span></span><br><span class="line">                  CALL_VM(InterpreterRuntime::monitorexit(THREAD, most_recent), handle_exception);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            UPDATE_PC_AND_TOS_AND_CONTINUE(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          most_recent++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-轻量级锁"><a href="#3-3-轻量级锁" class="headerlink" title="3.3 轻量级锁"></a>3.3 轻量级锁</h3><p>JVM的开发者发现在很多情况下，在Java程序运行时，同步块中的代码都是不存在竞争的，不同的线程交替的执行同步块中的代码。这种情况下，用重量级锁是没必要的。因此JVM引入了轻量级锁的概念。</p>
<p>线程在执行同步块之前，JVM会先在当前的线程的栈帧中创建一个Lock Record，其包括一个用于存储对象头中的 mark word（官方称之为Displaced Mark Word）以及一个指向对象的指针。下图右边的部分就是一个Lock Record。<br><img src="/images/Lock-Record.png" alt="Lock-Record" title="Lock-Record"></p>
<p><strong>加锁过程：</strong></p>
<ol>
<li>在线程栈中创建一个Lock Record，将其obj（即上图的Object reference）字段指向锁对象；</li>
<li>直接通过CAS指令将Lock Record的地址存储在对象头的Mark Word中，如果对象处于无锁状态则修改成功，代表该线程获得了轻量级锁。如果失败，进入到步骤3；</li>
<li>如果是当前线程已经持有该锁了，代表这是一次锁重入。设置Lock Record第一部分（Displaced Mark Word）为null，起到了一个重入计数器的作用。然后结束；</li>
<li>走到这一步说明发生了竞争，需要膨胀为重量级锁。</li>
</ol>
<p><strong>释放锁过程：</strong></p>
<ol>
<li>遍历线程栈,找到所有obj字段等于当前锁对象的Lock Record；</li>
<li>如果Lock Record的Displaced Mark Word为null，代表这是一次重入，将obj设置为null后continue；</li>
<li>如果Lock Record的Displaced Mark Word不为null，则利用CAS指令将对象头的Mark Word恢复成为Displaced Mark Word。如果成功，则continue，否则膨胀为重量级锁。</li>
</ol>
<h3 id="3-4-重量级锁"><a href="#3-4-重量级锁" class="headerlink" title="3.4 重量级锁"></a>3.4 重量级锁</h3><p>重量级锁是我们常说的传统意义上的锁，其利用操作系统底层的同步机制去实现Java中的线程同步。重量级锁的状态下，对象的Mark Word为指向一个堆中monitor对象的指针，在上面的内容已经讲过。<br>monitor对象包括三个链表：_cxq，_EntryList及_WaitSet，被阻塞的线程封装为ObjectWaiter对象，而<strong>ObjectWaiter对象存在于WaitSet、EntryList、cxq等集合中，或者正在这些集合中移动</strong>，那么ObjectWaiter是怎么移动的？下面的内容将进行分析。</p>
<p><strong>wait方法</strong></p>
<ol>
<li>当前线程封装成ObjectWaiter对象，状态为TS_WAIT；</li>
<li>ObjectWaiter对象被放入_WaitSet中；</li>
<li>释放锁；</li>
<li>当前线程挂起；</li>
</ol>
<p><strong>monitorenter竞争锁</strong></p>
<ol>
<li>偏向锁逻辑：判断是否偏向锁，不是则执行轻量级锁逻辑；</li>
<li>轻量级锁逻辑：如果是无锁状态，就通过CAS去竞争锁，否则判断重入，如果不是当前线程持有锁，执行锁膨胀；</li>
<li>重量级锁逻辑：构造OjectMonitor对象，通过CAS去设置owner，如果失败就将线程加入_cxq队列的首位；</li>
<li>执行无限循环，竞争锁成功就退出循环，竞争失败线程挂起，等待被唤醒后继续竞争；</li>
</ol>
<p>代码如下：</p>
<p><a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/9ce27f0a4683/src/share/vm/runtime/objectMonitor.cpp#l502" target="_blank" rel="noopener">objectMonitor.cpp#l502</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> ATTR <span class="title">ObjectMonitor::EnterI</span> <span class="params">(TRAPS)</span> </span>&#123;</span><br><span class="line">    Thread * Self = THREAD ;</span><br><span class="line">    ... <span class="comment">// 略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 封装ObjectWaiter对象</span></span><br><span class="line">    <span class="function">ObjectWaiter <span class="title">node</span><span class="params">(Self)</span> </span>;</span><br><span class="line">    Self-&gt;_ParkEvent-&gt;reset() ;</span><br><span class="line">    node._prev   = (ObjectWaiter *) <span class="number">0xBAD</span> ;</span><br><span class="line">    node.TState  = ObjectWaiter::TS_CXQ ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加入到_cxq队首</span></span><br><span class="line">    ObjectWaiter * nxt ;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        node._next = nxt = _cxq ;</span><br><span class="line">        <span class="keyword">if</span> (Atomic::cmpxchg_ptr (&amp;node, &amp;_cxq, nxt) == nxt) <span class="keyword">break</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Interference - the CAS failed because _cxq changed.  Just retry.</span></span><br><span class="line">        <span class="comment">// As an optional optimization we retry the lock.</span></span><br><span class="line">        <span class="keyword">if</span> (TryLock (Self) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            assert (_succ != Self         , <span class="string">"invariant"</span>) ;</span><br><span class="line">            assert (_owner == Self        , <span class="string">"invariant"</span>) ;</span><br><span class="line">            assert (_Responsible != Self  , <span class="string">"invariant"</span>) ;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TEVENT (Inflated enter - Contention) ;</span><br><span class="line">    <span class="keyword">int</span> nWakeups = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">int</span> RecheckInterval = <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (TryLock (Self) &gt; <span class="number">0</span>) <span class="keyword">break</span> ;</span><br><span class="line">        assert (_owner != Self, <span class="string">"invariant"</span>) ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((SyncFlags &amp; <span class="number">2</span>) &amp;&amp; _Responsible == <span class="literal">NULL</span>) &#123;</span><br><span class="line">           Atomic::cmpxchg_ptr (Self, &amp;_Responsible, <span class="literal">NULL</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// park self</span></span><br><span class="line">        <span class="keyword">if</span> (_Responsible == Self || (SyncFlags &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">            TEVENT (Inflated enter - park TIMED) ;</span><br><span class="line">            Self-&gt;_ParkEvent-&gt;park ((jlong) RecheckInterval) ;</span><br><span class="line">            <span class="comment">// Increase the RecheckInterval, but clamp the value.</span></span><br><span class="line">            RecheckInterval *= <span class="number">8</span> ;</span><br><span class="line">            <span class="keyword">if</span> (RecheckInterval &gt; <span class="number">1000</span>) RecheckInterval = <span class="number">1000</span> ;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            TEVENT (Inflated enter - park UNTIMED) ;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 阻塞当前线程</span></span><br><span class="line">            Self-&gt;_ParkEvent-&gt;park() ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (TryLock(Self) &gt; <span class="number">0</span>) <span class="keyword">break</span> ;</span><br><span class="line"></span><br><span class="line">       ... <span class="comment">// 略</span></span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	... <span class="comment">// 略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>notify方法</strong></p>
<ol>
<li>执行过wait方法的线程都在队列_WaitSet中，此处从_WaitSet中取出第一个；</li>
<li>根据Policy的不同，将这个线程放入_EntryList或者_cxq队列中的起始或末尾位置。</li>
</ol>
<p>Policy逻辑如下：</p>
<ol>
<li>Policy == 0：放入_EntryList队列的排头位置；</li>
<li>Policy == 1：放入_EntryList队列的末尾位置；</li>
<li>Policy == 2：_EntryList队列为空就放入_EntryList，否则放入_cxq队列的排头位置；</li>
<li>Policy == 3：放入_cxq队列中，末尾位置；</li>
<li>Policy等于其他值，立即唤醒ObjectWaiter对应的线程。</li>
</ol>
<p><strong>monitorexit释放锁</strong></p>
<ol>
<li>偏向锁逻辑，此处不是；</li>
<li>轻量级锁逻辑，此处不是，执行锁膨胀；</li>
<li>重量级锁逻辑，根据QMode的不同，将ObjectWaiter从_cxq或者_EntryList中取出后唤醒；</li>
<li>唤醒的线程会继续执行挂起前的代码。</li>
</ol>
<p>QMode逻辑如下：</p>
<ol>
<li>QMode = 2，并且_cxq非空：取_cxq队列排头位置的ObjectWaiter对象，调用ExitEpilog方法，该方法会唤醒ObjectWaiter对象的线程，此处会立即返回，后面的代码不会执行了；</li>
<li>QMode = 3，并且_cxq非空，把_cxq队列首元素放入_EntryList的尾部，执行第5步；</li>
<li>QMode = 4，并且_cxq非空，把_cxq队列首元素放入_EntryList的头部，执行第5步；</li>
<li>QMode = 0，执行第5步；</li>
<li>如果_EntryList的首元素非空，就取出来调用ExitEpilog方法，该方法会唤醒ObjectWaiter对象的线程，然后立即返回；如果_EntryList的首元素为空，就取_cxq的首元素，放入_EntryList，然后再从_EntryList中取出来执行ExitEpilog方法，然后立即返回，以上操作，均是执行过ExitEpilog方法然后立即返回，如果取出的元素为空，就执行循环继续取。</li>
</ol>
<p><strong>总结：</strong> 通过设置Policy及QMode，可以实现不同的调度逻辑。</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>总的来说synchronized的重量级锁和ReentrantLock的实现上还是有很多相似的，包括其数据结构、挂起线程方式等等，底层都是基于操作系统的futex实现。如果没有什么特殊要求使用synchronized即可。</p>
<p><strong>参考：</strong></p>
<hr>
<p><a href="https://github.com/farmerjohngit/myblog/issues/12" target="_blank" rel="noopener">1. 死磕Synchronized底层实现–概论</a></p>
<p><a href="https://blog.csdn.net/boling_cavalry/article/details/77793224" target="_blank" rel="noopener">2. Java的wait()、notify()学习三部曲之一：JVM源码分析</a></p>
<p><a href="https://tech.meituan.com/2018/11/15/java-lock.html" target="_blank" rel="noopener">3. 不可不说的Java“锁”事</a></p>
<p><a href="https://blog.csdn.net/iter_zc/article/details/41847887" target="_blank" rel="noopener">4. 聊聊JVM（六）理解JVM的safepoint</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/29/principles-of-java-lock/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/29/principles-of-java-lock/" class="post-title-link" itemprop="http://yoursite.com/page/3/index.html">Java ReentrantLock实现原理</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-29 16:32:27" itemprop="dateCreated datePublished" datetime="2019-07-29T16:32:27+08:00">2019-07-29</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-07-31 17:17:10" itemprop="dateModified" datetime="2021-07-31T17:17:10+08:00">2021-07-31</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/并发编程/" itemprop="url" rel="index"><span itemprop="name">并发编程</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在Java中要实现资源的互斥访问及线程间的同步，一般有两种方式，一种是通过synchronized（同步块或同步方法）结合Oject.wait()及Object.signal()来实现，另外一种是通过ReentrantLock和Condition来实现。为了解决不同条件下的并发问题，Java还引入了一些高级锁和同步机制，如Semaphore,ReentrantReadWriteLock,CountDownLatch和CyclicBarrier等等。</p>
<p>在项目开发中，用ReentrantLock相对较多，但对其的理解程序仅限于Java语言层面，对于JVM及操作系统的底层实现并没有了解，没有一个全局的概念，相关知识点存在断层，如ReentrantLock在JVM和操作系统中到底对应什么实体？等待队列存储在什么地方？线程的等待及唤醒对应什么样的操作？JVM及操作系统在ReentrantLock中提供了什么样的功能？正好在学习操作系统的知识，把这些知识重新梳理下，打通认知上的盲点。</p>
<h2 id="1-整体结构"><a href="#1-整体结构" class="headerlink" title="1. 整体结构"></a>1. 整体结构</h2><p><img src="/images/reentrantlock.jpg" alt="reentrantlock" title="reentrantlock"></p>
<ol>
<li>在Java层，维护了锁的state状态及等待队列（包括条件队列），对JVM的依赖只是线程的阻塞和唤醒。给state赋予不同的含义及控制获取锁的方式，Java在语言层面实现丰富的锁结构。</li>
<li>在JVM层，线程的阻塞和唤醒是通过互斥（pthread_mutex_t）和条件变量(pthread_cond_t)来实现的。_counter用来表示一个许可，通过_counter的值来判断是否在该条件变量上进行等待和唤醒，_counter默认值是0，表示许可未被使用，调用park之后，线程将被阻塞；执行unpark之后，_counter赋值为1，将会唤醒被等待的线程，唤醒的操作是将等待的线程从条件变量（cond）的等待队列移到互斥（mutex）的等待队列上，互斥（mutex）释放之后才将该线程进行调度。</li>
<li>futex由一个用户空间int类型的地址uaddr及相关联的等待队列组成，uaddr由mutex或cond中定义。在内核中维护一个哈希表的数据结构，以uaddr为key,通过hash操作，添加到对应的列表中，从而可以快速搜索到uaddr对应的等待线程。</li>
</ol>
<h2 id="2-ReentrantLock"><a href="#2-ReentrantLock" class="headerlink" title="2. ReentrantLock"></a>2. ReentrantLock</h2><p>在Java中有一个非常重要的并发数据结构AbstractQueuedSynchronizer(AQS),它主要的功能有三个：1）维护状态值（state）;2）线程同步队列的管理；3）封装流程。AQS对锁的实现进行了高度抽象，提供了一套模板方法，对申请锁和释放锁的流程进行了封装，将差异的部分由子类来实现，如state字段含义的解析，同时子类通过扩展tryAcquire,tryRelease,tryAcquireShared,tryReleaseSharede及isHeldExclusivelys方法来实现不同语义的锁。</p>
<h3 id="2-1-state状态"><a href="#2-1-state状态" class="headerlink" title="2.1 state状态"></a>2.1 state状态</h3><p>ReentrantLock中有两个实现，分别是公平锁和不公平锁（NonfairSync和FairSync），它们都是继承自AQS，差别主要在于tryAcquire的实现，后面会进到，不过对于state的定义是一致的。在ReentrantLock中，state有如下的含义:</p>
<ul>
<li>0：表示锁未被占用，可以获取锁，获取锁之后变为1；</li>
<li>大于0：表示锁被占用，其它线程获取锁会被阻塞，拥有锁的线程可以重复获取锁（可重入的概念），重复获取锁要对state加1。</li>
</ul>
<h3 id="2-2-等待队列"><a href="#2-2-等待队列" class="headerlink" title="2.2 等待队列"></a>2.2 等待队列</h3><p>除了状态的管理，ReetrantLock还会维护一个同步队列，线程获取ReentrantLock锁失败后，会将该线程加入到队列的尾部，同时调用LockSupport.park方法让线程阻塞，等待队列是一个双向队列，其结点如下图所示：<br><img src="/images/aqs-node.jpg" alt="aqs-node" title="aqs-node"></p>
<ul>
<li>prev:指向前一个结点；</li>
<li>next:指向后一个结点；</li>
<li>nextWaiter:1）用在条件队列（在条件变量上挂起的线程列表）中，指向条件队列的下一个结点；2）用来表示锁的模式，是排他还是共享模式；</li>
<li>thread:对应的线程；</li>
<li>waitStatus:结点的等待状态，它有五个状态：1)SIGNAL;2)CANCELLED;3)CONDITION(用于条件变量中);4)PROPAGATE;5)0(初始状态)。</li>
</ul>
<p>一个包含两个结点的等待队列如下所示：<br><img src="/images/sync-queue.jpg" alt="sync-queue" title="sync-queue"></p>
<ul>
<li>在队列中有一个空的head结点，这样可以简化插入到队首的操作；</li>
<li>SINGAL状态表示其后续结点需要unpark操作。</li>
</ul>
<h3 id="2-3-条件队列"><a href="#2-3-条件队列" class="headerlink" title="2.3 条件队列"></a>2.3 条件队列</h3><p><strong>说明：</strong> 条件队列是指阻塞在条件变量上线程等待队列，这里为了与Lock变量上等待队列区分，所以叫做条件队列。</p>
<p>ReentrantLock可以单独使用，也可以配合条件变量一起使用，使用方式如下所示:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量声明</span></span><br><span class="line"><span class="keyword">private</span> ReentrantLock lock;</span><br><span class="line"><span class="keyword">private</span> Condition full;</span><br><span class="line"><span class="keyword">private</span> Condition empty;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">full = lock.newCondition();</span><br><span class="line">empty = lock.newCondition();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">// 使用方式</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">while</span> (index &gt;= DATA_SIZE) &#123;</span><br><span class="line">        empty.await();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> value = random.nextInt();</span><br><span class="line">    data[index] = value;</span><br><span class="line">    ++index;</span><br><span class="line"></span><br><span class="line">    full.signalAll();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    ex.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ++loop;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>条件变量(Codition)通常需要与Lock配合使用，为什么需要配合使用，后面章节会有描述。每一个条件变量都会维护一个条件队列，通过await方法之后，会释放Lock锁，同时将当前线程加入到条件队列中，最后阻塞当前线程。signal/signalAll则会将条件队列中一个或所有线程移到Lock对应的等待队列中，并等待唤醒。拥有两个结点的条件队列如下所示：<br><img src="/images/con-queue.jpg" alt="con-queue" title="con-queue"></p>
<h3 id="2-4-tryAcquire"><a href="#2-4-tryAcquire" class="headerlink" title="2.4 tryAcquire"></a>2.4 tryAcquire</h3><p>在AQS中定义了一套获取锁的模板方法，如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>流程如下：</p>
<ul>
<li>尝试获取锁，失败之后将线程加入到队列；</li>
<li>加入队列失败，则执行中断。</li>
</ul>
<p>在ReentrantLock中有两个实现，分别是公平锁和不公平锁，差别在于tryAcquire的实现，不公平锁的tryAcquire如下所示：<br>ReentrantLock#NonfairSync.tryAcquire.nonfairTryAcquire:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123; <span class="comment">// #1</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires; <span class="comment">// #2</span></span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ReentrantLock#FairSync.tryAcquire<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; <span class="comment">// #3</span></span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            etExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires; <span class="comment">// #4</span></span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>公平性</strong></p>
<p>公平锁与不公平锁的区别主要体现在代码#1和#3处，重要的区别在于获取锁时是否允许抢占，在公平锁中（#3）要判断队列中是否有结点，如果有则插入到队尾进行排队；不公平锁（#1）先尝试获取锁，获取失败再进行排队。</p>
<p><strong>可重入性</strong></p>
<p>可重入性体现在代码#2和#4处，如果当前线程等于持有锁的线程，则允许获取锁，state字段加1。</p>
<h3 id="2-5-LockSupport"><a href="#2-5-LockSupport" class="headerlink" title="2.5 LockSupport"></a>2.5 LockSupport</h3><p>如果获取锁失败，会调用LockSupport.park方法阻塞当前线程。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>LockSupport代码如下所示，它最终会调用UNSAFE.park方法，该方法是一个本地方法，由JVM虚拟机来实现。</p>
<p>LockSupport.Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(Object blocker)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    setBlocker(t, blocker);</span><br><span class="line">    UNSAFE.park(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    setBlocker(t, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在ReentrantLock中，线程的唤醒同样依赖于LockSupport中的方法，最终也是调用UNSAFE的本地方法。在UNSAFE中提供给LockSupport使用的就是如下两个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Thread jthread)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个参数代表第二个参数是否是绝对时间，第二个参数代表最长阻塞时间</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(<span class="keyword">boolean</span> isAbsolute, <span class="keyword">long</span> time)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>仅仅两个简单的接口，就为上层提供了强大的同步原语。</p>
<h2 id="3-JVM同步原语"><a href="#3-JVM同步原语" class="headerlink" title="3. JVM同步原语"></a>3. JVM同步原语</h2><p>在HotSpot虚拟机(Oracle JDK和Openjdk)中，park和unpark方法由底层的Parker类来实现，虚拟机中每一个线程都会关联一个Park对象，在这里三个层面的线程，分别是Java线程、jvm线程和操作系统线程，先分析下它们之间的关系。</p>
<h3 id="3-1-Thread"><a href="#3-1-Thread" class="headerlink" title="3.1 Thread"></a>3.1 Thread</h3><p>HotSpot虚拟机里的Thread类对应着一个OS的Thread, JavaThread类继承自Thread, JavaThread实例持有Java层的Thread实例。所以, 在Java层的Thread, 在操作系统上对应一个thread, linux上就是一个轻量级task。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// thread.hpp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span>:</span> <span class="keyword">public</span> ThreadShadow &#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">VMStructs</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// OS data associated with the thread</span></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        OSThread* _osthread;  <span class="comment">// Platform-specific thread information</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ParkEvent * _ParkEvent ;        <span class="comment">// for synchronized()</span></span><br><span class="line">        ParkEvent * _SleepEvent ;       <span class="comment">// for Thread.sleep</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// JSR166 per-thread parker</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Parker*    _parker;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JavaThread</span>:</span> <span class="keyword">public</span> Thread &#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">VMStructs</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        JavaThread*    _next;          <span class="comment">// The next thread in the Threads list</span></span><br><span class="line">        oop            _threadObj;     <span class="comment">// The Java level thread object</span></span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>线程的创建是最后是通过线程库pthread_create来实现的。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// thread.cpp</span></span><br><span class="line">os::create_thread(<span class="keyword">this</span>, thr_type, stack_sz);</span><br><span class="line"><span class="comment">// linux_os.cpp</span></span><br><span class="line"><span class="keyword">pthread_t</span> tid;</span><br><span class="line"><span class="keyword">int</span> ret = pthread_create(&amp;tid, &amp;attr, (<span class="keyword">void</span>* (*)(<span class="keyword">void</span>*)) thread_native_entry, thread);</span><br></pre></td></tr></table></figure></p>
<p>另外，Thread类里有两个ParkEvent和一个Parker, 其中_ParkEvent实现synchronized同步功能, _SleepEvent是用来实现Thread.sleep/wait，而parker则是用来实现的park/unpark(阻塞/唤醒)。</p>
<p><strong>注意：</strong> synchronized的重量级锁和ReentrantLock底层都是基于互斥和条件变量来实现的，从这个角度来看的话，这两者在性能上差别不大。</p>
<h3 id="3-2-Parker"><a href="#3-2-Parker" class="headerlink" title="3.2 Parker"></a>3.2 Parker</h3><p>Parker对象是实现线程阻塞/唤醒的关键，现在分析下它的结构。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// park.hpp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parker</span> :</span> <span class="keyword">public</span> os::PlatformParker &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> _counter ;</span><br><span class="line">         Parker * FreeNext ;</span><br><span class="line">        JavaThread * AssociatedWith ; <span class="comment">// Current association</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Parker() : PlatformParker() &#123;</span><br><span class="line">            _counter       = <span class="number">0</span> ;    <span class="comment">// 初始化为0</span></span><br><span class="line">            FreeNext       = <span class="literal">NULL</span> ;</span><br><span class="line">            AssociatedWith = <span class="literal">NULL</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// os_linux.cpp </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlatformParker</span> :</span> <span class="keyword">public</span> CHeapObj&lt;mtInternal&gt; &#123;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        <span class="keyword">enum</span> &#123;</span><br><span class="line">            REL_INDEX = <span class="number">0</span>,</span><br><span class="line">            ABS_INDEX = <span class="number">1</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> _cur_index;  <span class="comment">// which cond is in use: -1, 0, 1</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> _mutex [<span class="number">1</span>] ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个是给park用, 另一个是给parkUntil用</span></span><br><span class="line">    <span class="keyword">pthread_cond_t</span>  _cond  [<span class="number">2</span>] ; <span class="comment">// one for relative times and one for abs.</span></span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Parker对象中有三个比较重要的变量:</p>
<ul>
<li>_counter:用来表示获取凭证；</li>
<li>_mutex,_cond:互斥、条件变量，实现阻塞及唤醒的关键就在这里。</li>
</ul>
<h3 id="3-3-阻塞-唤醒"><a href="#3-3-阻塞-唤醒" class="headerlink" title="3.3 阻塞/唤醒"></a>3.3 阻塞/唤醒</h3><p>LockSuport.park/unpark调用UNSAFE.park/unpark，而UNSAFE再调用Parker的park及unpark方法，下面分析Parker对象中的park/unpark流程。</p>
<h4 id="3-3-1-Parker-park"><a href="#3-3-1-Parker-park" class="headerlink" title="3.3.1 Parker::park"></a>3.3.1 Parker::park</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os_linux.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Parker::park</span><span class="params">(<span class="keyword">bool</span> isAbsolute, jlong time)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果_counter大于0，表示凭证有效(park之前执行了unpark操作)，则直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (Atomic::xchg(<span class="number">0</span>, &amp;_counter) &gt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    Thread* thread = Thread::current();</span><br><span class="line">    assert(thread-&gt;is_Java_thread(), <span class="string">"Must be JavaThread"</span>);</span><br><span class="line">    JavaThread *jt = (JavaThread *)thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前线程有中断信息，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (Thread::is_interrupted(thread, <span class="literal">false</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Next, demultiplex/decode time arguments</span></span><br><span class="line">    timespec absTime;</span><br><span class="line">    <span class="keyword">if</span> (time &lt; <span class="number">0</span> || (isAbsolute &amp;&amp; time == <span class="number">0</span>) ) &#123; <span class="comment">// don't wait at all</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        unpackTime(&amp;absTime, isAbsolute, time);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Don't wait if cannot get lock since interference arises from</span></span><br><span class="line">    <span class="comment">// unblocking.  Also. check interrupt before trying wait</span></span><br><span class="line">    <span class="comment">// 中断或获取锁失败则返回</span></span><br><span class="line">    <span class="keyword">if</span> (Thread::is_interrupted(thread, <span class="literal">false</span>) || pthread_mutex_trylock(_mutex) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> status ;</span><br><span class="line">    f (_counter &gt; <span class="number">0</span>)  &#123; <span class="comment">// no wait needed</span></span><br><span class="line">        _counter = <span class="number">0</span>;</span><br><span class="line">        status = pthread_mutex_unlock(_mutex);</span><br><span class="line">        assert (status == <span class="number">0</span>, <span class="string">"invariant"</span>) ;</span><br><span class="line">        <span class="comment">// Paranoia to ensure our locked and lock-free paths interact</span></span><br><span class="line">        <span class="comment">// correctly with each other and Java-level accesses.</span></span><br><span class="line">        OrderAccess::fence();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(_cur_index == <span class="number">-1</span>, <span class="string">"invariant"</span>);</span><br><span class="line">     <span class="comment">// 传入的time参数为0，走这个分支。</span></span><br><span class="line">     <span class="keyword">if</span> (time == <span class="number">0</span>) &#123;</span><br><span class="line">        _cur_index = REL_INDEX; <span class="comment">// arbitrary choice when not timed</span></span><br><span class="line">        status = pthread_cond_wait (&amp;_cond[_cur_index], _mutex) ;  <span class="comment">// 调用条件变量，进行阻塞</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _cur_index = isAbsolute ? ABS_INDEX : REL_INDEX;</span><br><span class="line">        status = os::Linux::safe_cond_timedwait (&amp;_cond[_cur_index], _mutex, &amp;absTime) ;</span><br><span class="line">        <span class="keyword">if</span> (status != <span class="number">0</span> &amp;&amp; WorkAroundNPTLTimedWaitHang) &#123;</span><br><span class="line">            pthread_cond_destroy (&amp;_cond[_cur_index]) ;</span><br><span class="line">            pthread_cond_init    (&amp;_cond[_cur_index], isAbsolute ? <span class="literal">NULL</span> : os::Linux::condAttr());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _cur_index = <span class="number">-1</span>;</span><br><span class="line">    assert_status(status == <span class="number">0</span> || status == EINTR ||</span><br><span class="line">                status == ETIME || status == ETIMEDOUT,</span><br><span class="line">                status, <span class="string">"cond_timedwait"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程被唤醒，_counter设置为0，并释放锁。</span></span><br><span class="line">    _counter = <span class="number">0</span> ;</span><br><span class="line">    status = pthread_mutex_unlock(_mutex) ;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要流程：</p>
<ol>
<li>首先对_counter进行CAS原子操作，将_counter设置为0，并判断旧值是否大于0，若大于0表示凭证有效，直接返回；</li>
<li>_counter等于0，则尝试获取锁（pthread_mutex_trylock），有中断或获取锁失败直接返回；</li>
<li>获取锁成功之后，尝试对_counter进行一次判断，如果在这期间，_counter被修改了（大于0），则将_counter设置为0，释放锁，并返回；</li>
<li>如果_counter未被修改，则调用pthread_cond_wait，阻塞该线程；</li>
<li>线程被唤醒，_counter设置为0，并释放锁。</li>
</ol>
<p><strong>注意：</strong> 在pthread_cond_wait中传入mutex，是为了保证_counter状态的变更和执行条件变量的操作是一个原子操作，避免在对条件变量进行操作的时候，_counter发生了变更。</p>
<h4 id="3-3-2-Parker-unpark"><a href="#3-3-2-Parker-unpark" class="headerlink" title="3.3.2 Parker::unpark"></a>3.3.2 Parker::unpark</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os_linux.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Parker::unpark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s, status ;</span><br><span class="line">    status = pthread_mutex_lock(_mutex);</span><br><span class="line">    assert (status == <span class="number">0</span>, <span class="string">"invariant"</span>) ;</span><br><span class="line">     s = _counter;</span><br><span class="line">     _counter = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s &lt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// thread might be parked</span></span><br><span class="line">    <span class="keyword">if</span> (_cur_index != <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="comment">// thread is definitely parked</span></span><br><span class="line">      <span class="keyword">if</span> (WorkAroundNPTLTimedWaitHang) &#123;</span><br><span class="line">        status = pthread_cond_signal (&amp;_cond[_cur_index]);</span><br><span class="line">        assert (status == <span class="number">0</span>, <span class="string">"invariant"</span>);</span><br><span class="line">        status = pthread_mutex_unlock(_mutex);</span><br><span class="line">        assert (status == <span class="number">0</span>, <span class="string">"invariant"</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        status = pthread_mutex_unlock(_mutex);</span><br><span class="line">        assert (status == <span class="number">0</span>, <span class="string">"invariant"</span>);</span><br><span class="line">        status = pthread_cond_signal (&amp;_cond[_cur_index]);</span><br><span class="line">        assert (status == <span class="number">0</span>, <span class="string">"invariant"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      pthread_mutex_unlock(_mutex);</span><br><span class="line">      assert (status == <span class="number">0</span>, <span class="string">"invariant"</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    pthread_mutex_unlock(_mutex);</span><br><span class="line">    assert (status == <span class="number">0</span>, <span class="string">"invariant"</span>) ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>主要流程：</strong></p>
<ol>
<li>获取锁；</li>
<li>将_counter值修改为1；</li>
<li>对_counter的旧值进行判断，如果小于1，则表示有线程阻塞在条件变量，执行pthread_cond_signal唤醒操作。</li>
<li>释放锁。</li>
</ol>
<p>Parker::unpark操作相对比较简单，1）修改_counter赋值为1；2）唤醒进程。同时也可以看到，_counter执行的是赋值操作，执行一次unpark和执行多次unpark效果一样。</p>
<p><strong>源代码：</strong></p>
<p><a href="http://hg.openjdk.Java.net/jdk8/jdk8/hotspot/file/87ee5ee27509/src/share/vm/runtime/thread.hpp" target="_blank" rel="noopener">thread.hpp</a><br><a href="http://hg.openjdk.Java.net/jdk8/jdk8/hotspot/file/87ee5ee27509/src/share/vm/runtime/thread.cpp" target="_blank" rel="noopener">thread.cpp</a><br><a href="http://hg.openjdk.Java.net/jdk8/jdk8/hotspot/file/87ee5ee27509/src/os/linux/vm/os_linux.cpp" target="_blank" rel="noopener">linux_os.cpp</a></p>
<h3 id="3-4-mutex-cond"><a href="#3-4-mutex-cond" class="headerlink" title="3.4. mutex/cond"></a>3.4. mutex/cond</h3><p>通过上面的分析，LockSupport.park最终调用的是pthread_cond_wait，LockSupport.unpark调用的是pthread_cond_signal，阻塞/唤醒操作是通过条件变量来实现的，另外，这两个方法调用需要互斥（mutex）来协助（pthread_mutex_lock,pthread_mutex_unlock和pthread_mutex_trylock），现在我们进一步分析mutex和cond的实现。</p>
<h4 id="3-4-1-pthread-mutex-t"><a href="#3-4-1-pthread-mutex-t" class="headerlink" title="3.4.1 pthread_mutex_t"></a>3.4.1 pthread_mutex_t</h4><p><strong>1. pthread_mutex_t结构</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">pthread_mutex_s</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> __lock;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> __count;</span><br><span class="line">        <span class="keyword">int</span> __owner;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __WORDSIZE == 64</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> __nusers;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="comment">/* KIND must stay at this position in the structure to maintain</span></span><br><span class="line"><span class="comment">           binary compatibility.  */</span></span><br><span class="line">        <span class="keyword">int</span> __kind;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __WORDSIZE == 64</span></span><br><span class="line">        <span class="keyword">int</span> __spins;</span><br><span class="line">        <span class="keyword">__pthread_list_t</span> __list;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __PTHREAD_MUTEX_HAVE_PREV  1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> __nusers;</span><br><span class="line">        __extension__ <span class="keyword">union</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> __spins;</span><br><span class="line">            <span class="keyword">__pthread_slist_t</span> __list;</span><br><span class="line">        &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125; __data;</span><br><span class="line">    <span class="keyword">char</span> __size[__SIZEOF_PTHREAD_MUTEX_T];</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> __align;</span><br><span class="line">&#125; <span class="keyword">pthread_mutex_t</span>;</span><br></pre></td></tr></table></figure></p>
<p><strong>主要变量：</strong></p>
<ul>
<li>__lock:锁状态；</li>
<li>__owner:锁的拥有者。</li>
</ul>
<p>初始化时这些值都为0。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> PTHREAD_MUTEX_INITIALIZER \</span></span><br><span class="line">  &#123; &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, __PTHREAD_SPINS, &#123; <span class="number">0</span>, <span class="number">0</span> &#125; &#125; &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>2. pthread_mutex_lock</strong></p>
<p>省掉了部分流程，只保留了主要流程：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __pthread_mutex_lock</span></span><br><span class="line">strong_alias (__pthread_mutex_lock, pthread_mutex_lock)</span><br><span class="line">hidden_def (__pthread_mutex_lock)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// pthread_mutex_lock是__pthread_mutex_lock的别名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">__pthread_mutex_lock (<span class="keyword">pthread_mutex_t</span> *mutex)</span><br><span class="line">&#123;</span><br><span class="line">    assert (<span class="keyword">sizeof</span> (mutex-&gt;__size) &gt;= <span class="keyword">sizeof</span> (mutex-&gt;__data));</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> type = PTHREAD_MUTEX_TYPE_ELISION (mutex);</span><br><span class="line"> </span><br><span class="line">    LIBC_PROBE (mutex_entry, <span class="number">1</span>, mutex);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (type &amp; ~(PTHREAD_MUTEX_KIND_MASK_NP</span><br><span class="line">                 | PTHREAD_MUTEX_ELISION_FLAGS_NP), <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> __pthread_mutex_lock_full (mutex);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (__glibc_likely (type == PTHREAD_MUTEX_TIMED_NP))</span><br><span class="line">    &#123;</span><br><span class="line">        FORCE_ELISION (mutex, <span class="keyword">goto</span> elision);</span><br><span class="line">        simple:</span><br><span class="line">        <span class="comment">/* Normal mutex.  */</span></span><br><span class="line">        LLL_MUTEX_LOCK (mutex);</span><br><span class="line">        assert (mutex-&gt;__data.__owner == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    elseif (...) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">pid_t</span> id = THREAD_GETMEM (THREAD_SELF, tid);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Record the ownership.  */</span></span><br><span class="line">    mutex-&gt;__data.__owner = id;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> NO_INCR</span></span><br><span class="line">    ++mutex-&gt;__data.__nusers;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">    LIBC_PROBE (mutex_acquired, <span class="number">1</span>, mutex);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>主要流程：</strong></p>
<ul>
<li>判断锁的类型，普通锁会走LLL_MUTEX_LOCK (mutex)分支；</li>
<li>获取锁之后会将当前线程线程设置成为锁的拥有者，同时自增mutex变量__nusers的值，表示锁使用人数加1。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> LLL_MUTEX_LOCK(mutex) \</span></span><br><span class="line">    lll_lock ((mutex) -&gt;__data.__lock, PTHREAD_MUTEX_PSHARED (mutex))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将_data中的__lock作为参数填入lll_lock</span></span><br></pre></td></tr></table></figure>
<p>对mutex的操作主要是对mutex.__data.__lock的操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lll_lock(futex, private)    \</span></span><br><span class="line">    __lll_lock (&amp;(futex), <span class="keyword">private</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __lll_lock(futex, private)                                      \</span></span><br><span class="line">  ((<span class="keyword">void</span>)                                                               \</span><br><span class="line">   (&#123;                                                                   \</span><br><span class="line">     <span class="keyword">int</span> *__futex = (futex);                                            \</span><br><span class="line">     <span class="keyword">if</span> (__glibc_unlikely                                               \</span><br><span class="line">         (atomic_compare_and_exchange_bool_acq (__futex, <span class="number">1</span>, <span class="number">0</span>)))        \</span><br><span class="line">       &#123;                                                                \</span><br><span class="line">         <span class="keyword">if</span> (__builtin_constant_p (<span class="keyword">private</span>) &amp;&amp; (<span class="keyword">private</span>) == LLL_PRIVATE) \</span><br><span class="line">           __lll_lock_wait_private (__futex);                           \</span><br><span class="line">         <span class="keyword">else</span>                                                           \</span><br><span class="line">           __lll_lock_wait (__futex, <span class="keyword">private</span>);                          \</span><br><span class="line">       &#125;                                                                \</span><br><span class="line">   &#125;))</span><br></pre></td></tr></table></figure>
<p><strong>主要流程：</strong></p>
<ul>
<li>对__futex进行CAS操作，如果旧值为0，则将__futex修改为1，atomic_compare_and_exchange_bool_acq就是完成这个功能。</li>
<li>如果修改成功获取锁返回，且__futex值为1；</li>
<li>如果修改失败，说明__futex不为0，说明其它线程获取到锁，则执行下面的分支。</li>
</ul>
<p>atomic_compare_and_exchange_bool_acq(mem, newval, oldval)的定义如下：如果oldval等于*mem，那么设置*mem=newval，并且返回0； 如果*mem的值没有改变，那么就返回非0。 直白一点就是*mem等于oldval就返回0，不等于就返回非0。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Atomically store NEWVAL in *MEM if *MEM is equal to OLDVAL.</span></span><br><span class="line"><span class="comment">   Return zero if *MEM was changed or non-zero if no exchange happened. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> atomic_compare_and_exchange_bool_acq</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __arch_compare_and_exchange_bool_32_acq</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> atomic_compare_and_exchange_bool_acq(mem, newval, oldval) \</span></span><br><span class="line">  __atomic_bool_bysize (__arch_compare_and_exchange_bool,acq, \</span><br><span class="line">                mem, newval, oldval)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> atomic_compare_and_exchange_bool_acq(mem, newval, oldval) \</span></span><br><span class="line">  (&#123; <span class="comment">/* Cannot use __oldval here, because macros later in this file might \</span></span><br><span class="line"><span class="comment">    call this macro with __oldval argument. */</span> \</span><br><span class="line">     __typeof (oldval) __atg3_old = (oldval); \</span><br><span class="line">     atomic_compare_and_exchange_val_acq (mem, newval, __atg3_old) \</span><br><span class="line">       != __atg3_old; \</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This function doesn't get included in libc.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> IS_IN (libpthread)</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">__lll_lock_wait (<span class="keyword">int</span> *futex, <span class="keyword">int</span> <span class="keyword">private</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (*futex == <span class="number">2</span>)</span><br><span class="line">    lll_futex_wait (futex, <span class="number">2</span>, <span class="keyword">private</span>); <span class="comment">/* Wait if *futex == 2.  */</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">while</span> (atomic_exchange_acq (futex, <span class="number">2</span>) != <span class="number">0</span>)</span><br><span class="line">    lll_futex_wait (futex, <span class="number">2</span>, <span class="keyword">private</span>); <span class="comment">/* Wait if *futex == 2.  */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>阻塞的关键操作就在这里：</p>
<ul>
<li>如果futex为2，则调用lll_futex_wait进行阻塞；</li>
<li>如果futex不为2，则将futex修改为2，一般是从1修改为2，再调用lll_futex_wait阻塞线程。</li>
<li>这里有两种情况：1）当前锁被占用，futex为1，但没有线程被阻塞，这是需要将futex修改为2；2）如果已经有线程被阻塞，说明futex为2，则直接阻塞当前线程。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Wait while *FUTEXP == VAL for an lll_futex_wake call on FUTEXP.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lll_futex_wait(futexp, val, private) \</span></span><br><span class="line">lll_futex_timed_wait (futexp, val, <span class="literal">NULL</span>, <span class="keyword">private</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lll_futex_timed_wait(futexp, val, timeout, private)     \</span></span><br><span class="line">    lll_futex_syscall (<span class="number">4</span>, futexp,                                 \</span><br><span class="line">            __lll_private_flag (FUTEX_WAIT, <span class="keyword">private</span>),  \</span><br><span class="line">            val, timeout)</span><br></pre></td></tr></table></figure>
<p>lll_futex_wait的操作最终会调用FUTEX_WAIT，在FUTEX_WAIT中，会传入整数的地址futexp，还有当前值val，如果在系统调用期间val改变了则直接返回，保证了数据的原子性。在lll_futex_timed_wait调用中，futexp表示mutex.__data.__lock，而val为2。</p>
<p><strong>3. pthread_mutex_unlock</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">__pthread_mutex_unlock (<span class="keyword">pthread_mutex_t</span> *mutex)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> __pthread_mutex_unlock_usercnt (mutex, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">internal_function attribute_hidden</span><br><span class="line">__pthread_mutex_unlock_usercnt (<span class="keyword">pthread_mutex_t</span> *mutex, <span class="keyword">int</span> decr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> type = PTHREAD_MUTEX_TYPE_ELISION (mutex);</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (type &amp;</span><br><span class="line">		~(PTHREAD_MUTEX_KIND_MASK_NP|PTHREAD_MUTEX_ELISION_FLAGS_NP), <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> __pthread_mutex_unlock_full (mutex, decr);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (type, PTHREAD_MUTEX_TIMED_NP)</span><br><span class="line">        == PTHREAD_MUTEX_TIMED_NP)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">/* Always reset the owner field.  */</span></span><br><span class="line">    normal:</span><br><span class="line">        mutex-&gt;__data.__owner = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (decr)</span><br><span class="line">	    <span class="comment">/* One less user.  */</span></span><br><span class="line">	    --mutex-&gt;__data.__nusers;</span><br><span class="line"> </span><br><span class="line">         <span class="comment">/* Unlock.  */</span></span><br><span class="line">        lll_unlock (mutex-&gt;__data.__lock, PTHREAD_MUTEX_PSHARED (mutex));</span><br><span class="line"> </span><br><span class="line">        LIBC_PROBE (mutex_release, <span class="number">1</span>, mutex);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (__glibc_likely (type == PTHREAD_MUTEX_TIMED_ELISION_NP))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (__builtin_expect (PTHREAD_MUTEX_TYPE (mutex)</span><br><span class="line">			      == PTHREAD_MUTEX_RECURSIVE_NP, <span class="number">1</span>))</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (__builtin_expect (PTHREAD_MUTEX_TYPE (mutex)</span><br><span class="line">			      == PTHREAD_MUTEX_ADAPTIVE_NP, <span class="number">1</span>))</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>释放锁的主要操作是：1）线程的拥有者清0；2）线程的使用人数减一；2）lll_unlock唤醒线程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __lll_unlock(futex, private)                    \</span></span><br><span class="line">  ((<span class="keyword">void</span>)                                               \</span><br><span class="line">   (&#123;                                                   \</span><br><span class="line">     <span class="keyword">int</span> *__futex = (futex);                            \</span><br><span class="line">     <span class="keyword">int</span> __private = (<span class="keyword">private</span>);                         \</span><br><span class="line">     <span class="keyword">int</span> __oldval = atomic_exchange_rel (__futex, <span class="number">0</span>);   \</span><br><span class="line">     <span class="keyword">if</span> (__glibc_unlikely (__oldval &gt; <span class="number">1</span>))               \</span><br><span class="line">       lll_futex_wake (__futex, <span class="number">1</span>, __private);          \</span><br><span class="line">   &#125;))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lll_unlock(futex, private)	\</span></span><br><span class="line">  __lll_unlock (&amp;(futex), <span class="keyword">private</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lll_futex_wake(futexp, nr, private)                             \</span></span><br><span class="line">  lll_futex_syscall (<span class="number">4</span>, futexp,                                         \</span><br><span class="line">		     __lll_private_flag (FUTEX_WAKE, <span class="keyword">private</span>), nr, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p><strong>主要流程：</strong></p>
<ul>
<li>将futex（mutex.__data.__lock）设置为0并拿到设置之前的值（用户态操作）；</li>
<li>如果futex之前的值大于1，说明有线程阻塞在mutex上，则调用lll_futex_wake唤醒一个线程；</li>
</ul>
<p>lll_futex_wake调用内核FUTEX_WAKE来唤醒线程。</p>
<p><strong>总结：</strong></p>
<ul>
<li>mutex锁有三种状态（mutex.__data.__lock的值），0：锁未被占用；1：锁被占用；2：有一个或多个线程阻塞；</li>
<li>在内核中通过mutex.__data.__lock地址来确定一个mutex；</li>
</ul>
<h4 id="3-4-2-pthread-cond-t"><a href="#3-4-2-pthread-cond-t" class="headerlink" title="3.4.2 pthread_cond_t"></a>3.4.2 pthread_cond_t</h4><ol>
<li>pthread_cond_t定义<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Data structure for conditional variable handling.  Thestructure of</span></span><br><span class="line"><span class="comment">   the attribute type is not exposed on purpose.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> __lock; </span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> __futex;</span><br><span class="line">        __extension__ <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> __total_seq;</span><br><span class="line">        __extension__ <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> __wakeup_seq;</span><br><span class="line">        __extension__ <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> __woken_seq;</span><br><span class="line">        <span class="keyword">void</span> *__mutex;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> __nwaiters;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> __broadcast_seq; </span><br><span class="line">     &#125; __data;</span><br><span class="line">    <span class="keyword">char</span> __size[__SIZEOF_PTHREAD_COND_T];</span><br><span class="line">     __extension__ <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> __align;</span><br><span class="line">&#125; <span class="keyword">pthread_cond_t</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>主要成员：</strong></p>
<ul>
<li>__lock: 锁变量，用于条件变量内部状态的互斥访问；</li>
<li>__futex: 用来执行futex_wait的变量；</li>
<li>__total_seq：表示执行了多少次wait操作；</li>
<li>__wakeup_seq：表示执行了多少次唤醒操作；</li>
<li>__woken_seq：表示已经被真正唤醒的线程数目；</li>
<li>__mutex：保存pthread_cond_wait传入的互斥锁；</li>
<li>__nwaiters：表示条件变量现在还有多少个线程在使用；</li>
<li>__broadcast_seq：表示执行了多少次broadcast。</li>
</ul>
<ol start="2">
<li>pthread_cond_wait</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">__pthread_cond_wait (cond, mutex)</span><br><span class="line">     <span class="keyword">pthread_cond_t</span> *cond;</span><br><span class="line">     <span class="keyword">pthread_mutex_t</span> *mutex;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">pthread_cleanup_buffer</span> <span class="title">buffer</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">condvar_cleanup_buffer</span> <span class="title">cbuffer</span>;</span></span><br><span class="line">     <span class="keyword">int</span> err;</span><br><span class="line">    <span class="keyword">int</span> pshared = (cond-&gt;__data.__mutex == (<span class="keyword">void</span> *) ~<span class="number">0l</span>)</span><br><span class="line">        ? LLL_SHARED : LLL_PRIVATE;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* Make sure we are along.  */</span></span><br><span class="line">     <span class="comment">// 1.获得cond锁，对cond内状态进行互斥访问。</span></span><br><span class="line">    lll_lock (cond-&gt;__data.__lock, pshared);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Now we can release the mutex.  */</span></span><br><span class="line">    <span class="comment">// 2.释放mutex锁，即函数传入的互斥锁。</span></span><br><span class="line">    err = __pthread_mutex_unlock_usercnt (mutex, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (err, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        lll_unlock (cond-&gt;__data.__lock, pshared);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We have one new user of the condvar.  */</span></span><br><span class="line">  <span class="comment">// 3.修改cond状态</span></span><br><span class="line">  <span class="comment">// 每执行一次wait，__total_seq就会+1</span></span><br><span class="line">  ++cond-&gt;__data.__total_seq;</span><br><span class="line">  <span class="comment">// 用来执行futex_wait的变量</span></span><br><span class="line">  ++cond-&gt;__data.__futex;</span><br><span class="line">  <span class="comment">// 标识该cond还有多少线程在使用。</span></span><br><span class="line">  cond-&gt;__data.__nwaiters += <span class="number">1</span> &lt;&lt; COND_NWAITERS_SHIFT;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Remember the mutex we are using here.  If thereis already a</span></span><br><span class="line"><span class="comment">     different address store this is a bad user bug. Do not store</span></span><br><span class="line"><span class="comment">     anything for pshared condvars.  */</span></span><br><span class="line">  <span class="keyword">if</span> (cond-&gt;__data.__mutex != (<span class="keyword">void</span> *) ~<span class="number">0l</span>)</span><br><span class="line">    cond-&gt;__data.__mutex = mutex;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Prepare structure passed to cancellationhandler.  */</span></span><br><span class="line">  cbuffer.cond = cond;</span><br><span class="line">  cbuffer.mutex = mutex;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Before we block we enable cancellation. Therefore we have to</span></span><br><span class="line"><span class="comment">     install a cancellation handler.  */</span></span><br><span class="line">  __pthread_cleanup_push (&amp;buffer, __condvar_cleanup, &amp;cbuffer);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The current values of the wakeup counter.  The"woken" counter</span></span><br><span class="line"><span class="comment">     must exceed this value.  */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> val;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> seq;</span><br><span class="line">  val = seq = cond-&gt;__data.__wakeup_seq;</span><br><span class="line">  <span class="comment">/* Remember the broadcast counter.  */</span></span><br><span class="line">  cbuffer.bc_seq = cond-&gt;__data.__broadcast_seq;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> futex_val =cond-&gt;__data.__futex;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Prepare to wait.  Releasethe condvar futex.  */</span></span><br><span class="line">        <span class="comment">// 4. 释放cond锁</span></span><br><span class="line">        lll_unlock (cond-&gt;__data.__lock, pshared);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Enable asynchronouscancellation.  Required by the standard.  */</span></span><br><span class="line">        cbuffer.oldtype = __pthread_enable_asynccancel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Wait until woken by signal orbroadcast.  */</span></span><br><span class="line">        <span class="comment">// 5. 在__futex上阻塞线程</span></span><br><span class="line">        lll_futex_wait (&amp;cond-&gt;__data.__futex,futex_val, pshared);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Disable asynchronouscancellation.  */</span></span><br><span class="line">        <span class="comment">// 如果执行到这里，说明我们已经被signal唤醒。</span></span><br><span class="line">        __pthread_disable_asynccancel (cbuffer.oldtype);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We are going to look at shareddata again, so get the lock.  */</span></span><br><span class="line">        <span class="comment">// 6. 获取cond锁。</span></span><br><span class="line">        lll_lock (cond-&gt;__data.__lock, pshared);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If a broadcast happened, weare done.  */</span></span><br><span class="line">        <span class="keyword">if</span> (cbuffer.bc_seq !=cond-&gt;__data.__broadcast_seq)</span><br><span class="line">            <span class="keyword">goto</span> bc_out;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Check whether we are eligiblefor wakeup.  */</span></span><br><span class="line">        val = cond-&gt;__data.__wakeup_seq;</span><br><span class="line">    &#125;<span class="keyword">while</span> (val == seq || cond-&gt;__data.__woken_seq == val); </span><br><span class="line">    <span class="comment">// 如果醒了, 但是woken_seq里并没有变化, 那么继续futex_wait的逻辑</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Another thread woken up.  */</span></span><br><span class="line">    <span class="comment">// 7. 修改cond状态</span></span><br><span class="line">    ++cond-&gt;__data.__woken_seq;</span><br><span class="line"></span><br><span class="line">    bc_out: </span><br><span class="line">    cond-&gt;__data.__nwaiters -= <span class="number">1</span> &lt;&lt;COND_NWAITERS_SHIFT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If pthread_cond_destroy was called on this varaiblealready,</span></span><br><span class="line"><span class="comment">        notify the pthread_cond_destroy caller all waitershave left</span></span><br><span class="line"><span class="comment">        and it can be successfully destroyed.  */</span></span><br><span class="line">    <span class="keyword">if</span> (cond-&gt;__data.__total_seq == <span class="number">-1U</span>LL</span><br><span class="line">        &amp;&amp; cond-&gt;__data.__nwaiters &lt; (<span class="number">1</span>&lt;&lt; COND_NWAITERS_SHIFT))</span><br><span class="line">        lll_futex_wake (&amp;cond-&gt;__data.__nwaiters, <span class="number">1</span>,pshared);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We are done with the condvar.  */</span></span><br><span class="line">    <span class="comment">// 8. 释放cond锁</span></span><br><span class="line">    lll_unlock (cond-&gt;__data.__lock, pshared);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The cancellation handling is back to normal, removethe handler.  */</span></span><br><span class="line">    __pthread_cleanup_pop (&amp;buffer, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get the mutex before returning.  */</span></span><br><span class="line">    <span class="comment">// 9. 获取mutex锁</span></span><br><span class="line">    <span class="keyword">return</span> __pthread_mutex_cond_lock (mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>主要流程：</strong></p>
<ul>
<li>获取cond锁，对cond内状态进行互斥访问;</li>
<li>释放mutex锁，即函数传入的互斥锁;</li>
<li>修改cond状态;</li>
<li>释放cond锁;</li>
<li>在__futex上阻塞线程;</li>
<li>获取cond锁;</li>
<li>修改cond状态;</li>
<li>释放cond锁;</li>
<li>获取mutex锁。</li>
</ul>
<p>在这个流程中有几个关键的地方：</p>
<p><strong>mutex锁：</strong> 主要是实现外面的条件判断和__pthread_cond_wait是一个原子操作，所以阻塞前要释放mutex锁，唤醒之后要重新获取mutex锁；</p>
<p><strong>cond锁：</strong> 主要解决cond锁内状态的互斥访问。</p>
<p><strong>mutex锁的释放：</strong> mutex锁的释放是在获取cond锁之后再释放，这样做的是为了避免在释放cond锁之后获取mutex锁之前有其它线程修改了数据；</p>
<p><strong>系统调用：</strong> 阻塞的操作是调用lll_futex_wait方法，而该方法最终是调用FUTEX_WAIT；</p>
<p><strong>等待队列：</strong> 线程有可能阻塞在两个锁变量上，一个是mutex.__data.__lock上，另外一个是cond.__data.__futex上。</p>
<ol start="2">
<li>pthread_cond_signal<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">__pthread_cond_signal (cond)</span><br><span class="line">     <span class="keyword">pthread_cond_t</span> *cond;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> pshared = (cond-&gt;__data.__mutex == (<span class="keyword">void</span> *) ~<span class="number">0l</span>)</span><br><span class="line">        ? LLL_SHARED : LLL_PRIVATE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure we are alone.  */</span></span><br><span class="line">    <span class="comment">// 1. 获取cond锁</span></span><br><span class="line">    lll_lock (cond-&gt;__data.__lock, pshared);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Are there any waiters to be woken?  */</span></span><br><span class="line">    <span class="comment">// 如果wait次数比唤醒的次数多，那么就进行一个唤醒操作。</span></span><br><span class="line">    <span class="keyword">if</span> (cond-&gt;__data.__total_seq &gt; cond-&gt;__data.__wakeup_seq)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Yes.  Mark one of them as woken. */</span></span><br><span class="line">        <span class="comment">// 2. 修改cond状态</span></span><br><span class="line">        ++cond-&gt;__data.__wakeup_seq;</span><br><span class="line">        ++cond-&gt;__data.__futex;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Wake one.  */</span></span><br><span class="line">        <span class="keyword">if</span> (! __builtin_expect (lll_futex_wake_unlock(&amp;cond-&gt;__data.__futex, <span class="number">1</span>,</span><br><span class="line">           <span class="number">1</span>,&amp;cond-&gt;__data.__lock,</span><br><span class="line">           pshared), <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 唤醒一个线程</span></span><br><span class="line">        lll_futex_wake(&amp;cond-&gt;__data.__futex, <span class="number">1</span>, pshared);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We are done.  */</span></span><br><span class="line">    <span class="comment">// 4. 释放cond锁</span></span><br><span class="line">    lll_unlock (cond-&gt;__data.__lock, pshared);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>主要流程：</strong></p>
<ul>
<li>获取cond锁；</li>
<li>修改cond状态；</li>
<li>如果wait次数大于wakeup次数，则唤醒一个线程；</li>
<li>释放cond锁。</li>
</ul>
<ol start="3">
<li>pthread_cond_broadcast<br>与pthread_cond_signal类似，区别在于一次性唤醒所有线程。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lll_futex_wake (&amp;cond-&gt;__data.__futex, INT_MAX, pshared);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="3-4-3-总结"><a href="#3-4-3-总结" class="headerlink" title="3.4.3 总结"></a>3.4.3 总结</h4><ol>
<li>条件变量(cond)与互斥(mutex)配合一起使用，以保证条件判断和阻塞操作是一个原子操作；</li>
<li>条件变量(cond)内部有一个cond锁，实现对cond内部状态进行互斥访问；</li>
<li>条件变量(cond)和互斥(mutex)阻塞/唤醒线程都是通过FUTEX_WAIT和FUTEX_WAKE系统调用来实现。</li>
</ol>
<h2 id="4-线程中断"><a href="#4-线程中断" class="headerlink" title="4. 线程中断"></a>4. 线程中断</h2><p>唤醒阻塞的线程，除了使用SupportLock.park，也可以调用Thread.interrupt()。调用interrupt，可以设置线程的中断状态，同时唤醒因为调用Object.wait(), Thread.join()，Thread.sleep()及AQS而被阻塞的线程。现在我们来看下interrupt的流程。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Thread.Java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread())</span><br><span class="line">        checkAccess();</span><br><span class="line">    <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">        Interruptible b = blocker;   <span class="comment">//中断触发器</span></span><br><span class="line">        <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">            interrupt0();           </span><br><span class="line">            b.interrupt(<span class="keyword">this</span>);   <span class="comment">//触发回调接口</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interrupt0();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这里，有两个关键的点，1）我们可以对中断调用设置回调接口，以满足某些特殊场景，如InterruptibleChannel；2）中断功能最终通过本地方法interrupt0()来实现。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> native <span class="keyword">void</span> <span class="title">interrupt0</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>在Hotspot虚拟机中，该方法会调用Thread对象中的interrupt方法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//os_linux.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">os::interrupt</span><span class="params">(Thread* thread)</span> </span>&#123;</span><br><span class="line">    assert(Thread::current() == thread || Threads_lock-&gt;owned_by_self(),</span><br><span class="line">        <span class="string">"possibility of dangling Thread pointer"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//     </span></span><br><span class="line">    OSThread* osthread = thread-&gt;osthread();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!osthread-&gt;interrupted()) &#123;</span><br><span class="line">        osthread-&gt;set_interrupted(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// More than one thread can get here with the same value of osthread,</span></span><br><span class="line">        <span class="comment">// resulting in multiple notifications.  We do, however, want the store</span></span><br><span class="line">        <span class="comment">// to interrupted() to be visible to other threads before we execute unpark().</span></span><br><span class="line">        OrderAccess::fence();</span><br><span class="line">        ParkEvent * <span class="keyword">const</span> slp = thread-&gt;_SleepEvent ;</span><br><span class="line">        <span class="keyword">if</span> (slp != <span class="literal">NULL</span>) slp-&gt;unpark() ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For JSR166. Unpark even if interrupt status already was set</span></span><br><span class="line">    <span class="keyword">if</span> (thread-&gt;is_Java_thread())</span><br><span class="line">        ((JavaThread*)thread)-&gt;parker()-&gt;unpark();</span><br><span class="line"></span><br><span class="line">    ParkEvent * ev = thread-&gt;_ParkEvent ;</span><br><span class="line">    <span class="keyword">if</span> (ev != <span class="literal">NULL</span>) ev-&gt;unpark() ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每一个Java线程都与一个osthread一一对应，如果相应的os线程没有被中断，则会设置osthread的interrupt标志位为true（对应一个volatile int），并唤醒线程的SleepEvent。随后唤醒线程的parker和ParkEvent。简而言之，interrupt操作会对三种事件进行unpark唤醒，分别是thread-&gt;_SleepEvent、thread-&gt;parker()和thread-&gt;_ParkEvent。在3.1节可以看到这些变量的具体声明。Parker对象我们在上面的内容中已经讲过，现在来看下ParkEvent。</p>
<h3 id="4-1-ParkEvent"><a href="#4-1-ParkEvent" class="headerlink" title="4.1 ParkEvent"></a>4.1 ParkEvent</h3><p>Thread类中包含了两种作用不同的ParkEvent，_ParkEvent变量用于synchronized同步块和Object.wait()，_SleepEvent变量用于Thread.sleep()，ParkEvent类的声明如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParkEvent</span> :</span> <span class="keyword">public</span> os::PlatformEvent &#123;</span><br><span class="line">    ... <span class="comment">// 略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// os_linux.cpp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlatformEvent</span> :</span> <span class="keyword">public</span> CHeapObj &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">pthread_mutex_t</span> _mutex  [<span class="number">1</span>] ;</span><br><span class="line">        <span class="keyword">pthread_cond_t</span>  _cond   [<span class="number">1</span>] ;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        PlatformEvent() &#123;</span><br><span class="line">            <span class="keyword">int</span> status;</span><br><span class="line">            status = pthread_cond_init (_cond, <span class="literal">NULL</span>);</span><br><span class="line">            assert_status(status == <span class="number">0</span>, status, <span class="string">"cond_init"</span>);</span><br><span class="line">            status = pthread_mutex_init (_mutex, <span class="literal">NULL</span>);</span><br><span class="line">            assert_status(status == <span class="number">0</span>, status, <span class="string">"mutex_init"</span>);</span><br><span class="line">            _Event   = <span class="number">0</span> ;</span><br><span class="line">            _nParked = <span class="number">0</span> ;</span><br><span class="line">            _Assoc   = <span class="literal">NULL</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">park</span> <span class="params">()</span> </span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unpark</span> <span class="params">()</span> </span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span>  <span class="title">park</span> <span class="params">(jlong millis)</span> </span>;</span><br><span class="line">    ...</span><br><span class="line">&#125; ;</span><br></pre></td></tr></table></figure></p>
<p>在这里可以看到，PlatformEvent跟Parker一样，也是基于pthread_mutex_t和pthread_cond_t实现的。_ParkEvent和_SleepEvent都会在Thread.interrupt()时触发unpark()动作，而PlatformEvent::unpark()方法会调用库函数pthread_cond_signal(_cond)唤醒被阻塞的线程，pthread_cond_signal方法已经在上面讲过，总之一句话，PlatformEvent阻塞和唤醒线程的逻辑跟Parker是一致的，这里不在描述。</p>
<h3 id="4-2-InterruptedException"><a href="#4-2-InterruptedException" class="headerlink" title="4.2 InterruptedException"></a>4.2 InterruptedException</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread.Java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread.Java </span></span><br><span class="line"><span class="comment">// join方法是通过object.wait来实现的。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    join(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ojbect.Java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure>
<p>调用中断，从Object.wait(), Thread.join()及Thread.sleep()返回时，一般都会抛出InterruptedException，通常以下三种处理办法：</p>
<ol>
<li>如果自己很清楚当前线程被中断后的处理方式，则按自己的方式处理，通常是做好善后工作，主动退出线程；</li>
<li>直接在方法声明中throws InterruptedException，丢给上层处理；</li>
<li>重新设置中断标记位，Thread.currentThread().interrupt()，交给后续方法处理，原因是底层抛出InterruptedException时会清除中断标记位，捕获到异常后如果不想处理，可以重新设置中断标记位。</li>
</ol>
<p><strong>注意：</strong> 请不要吞掉InterruptedException，可能会导致上层的调用方出现不可预料的结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unsafe.Java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(<span class="keyword">boolean</span> var1, <span class="keyword">long</span> var2)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在AQS相关类中线程阻塞在UNSAFE.park方法上，调用中断之后，不会抛出InterruptedException。线程被唤醒后，会根据中断标记位来判断是否从中断中退出，一般有两种做法，1）检测到中断，构造InterruptedException向上抛出，带InterruptedException声明的方法就是这种处理办法；2）重新设置中断标记位,由上层业务处理，以AQS的acquire方法为例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer.Java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 抛出InterruptedException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="comment">// 抛出InterruptedException</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 重置中断标记位</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// selfInterrupt,重置中断标记位</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="4-3-总结"><a href="#4-3-总结" class="headerlink" title="4.3 总结"></a>4.3 总结</h3><p>Java提供了Thread.interrupt()方法，该方法设置线程中的中断标记位，并唤醒可中断的阻塞方法，包括Thread.sleep()，Object.wait()，nio通道的IO等待，以及LockSupport.park()。识别一个方法是否会被中断，只需要看其声明中是否会throws InterruptedException或ClosedByInterruptException。<br>每个Java线程都会对应一个osthread，它持有了三种条件变量，分别用于Thread.sleep()，Object.wait()和unsafe.park()。Thread.interrupt()会依次唤醒三个条件变量，以达到中断的目的。线程的同步与唤醒最终都使用了pthread_cond_wait和pthread_cond_signal这些pthread库函数</p>
<h2 id="5-Futex"><a href="#5-Futex" class="headerlink" title="5.Futex"></a>5.Futex</h2><p>Futex，Fast Userspace muTEXes，按英文翻译过来就是快速用户空间互斥体。在Futex之前，Linux内核中锁主要针对一个内核对象来操作，并在这个基础上实现了进程的睡眠与唤醒。使用这样的机制，能很好的支持进程阻塞等待。但是最大的缺点是每次lock与unlock都是一次系统调用，即使没有锁冲突，也必须要通过系统调用进入内核之后才能识别。为了解决这个问题，Futex就应运而生。Futex是一种用户态和内核态混合的同步机制，锁变量位于用户空间，对锁冲突的检测是在用户空间完成，如果有竞争才会进行系统调用，进行阻塞和唤醒操作。</p>
<h3 id="5-1-Futex结构"><a href="#5-1-Futex结构" class="headerlink" title="5.1 Futex结构"></a>5.1 Futex结构</h3><p>Futex满足了两个需求：1）支持一种锁粒度的睡眠与唤醒操作；2）管理进程/线程挂起时的等待队列。Futex主要有futex_wait和futex_wake两个操作:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在uaddr指向的这个锁变量上挂起等待（仅当*uaddr==val时）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">futex_wait</span><span class="params">(<span class="keyword">int</span> *uaddr, <span class="keyword">int</span> val)</span></span>;</span><br><span class="line"><span class="comment">// 唤醒n个在uaddr指向的锁变量上挂起等待的进程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">futex_wake</span><span class="params">(<span class="keyword">int</span> *uaddr, <span class="keyword">int</span> n)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>futex_wait传入一个用户空间的地址uaddr,第二个参数表示当前uaddr的值，只有*uaddr==val时，当前线程才会被阻塞加入到等待队列中，作这样的判断主要是为了保证在系统调用前该值没有被改变，如果有其它线程修改了val值，则直接返回，尝试重新获取锁。futex_wake唤醒绑定在uaddr变量上的n个线程。</p>
<p>Futex实现了锁粒度的等待队列，而这个锁却并不需要事先向内核申明。任何时候，用户态调用futex_wait传入一个uaddr，内核就会维护起与之配对的等待队列。Futex维护的这个等待队列由若干个带spinlock的链表构成。调用futex_wait挂起的进程，通过其uaddr hash到某一个具体的链表上去。这样一方面能分散对等待队列的竞争、另一方面减小单个队列的长度，便于futex_wake时的查找。每个链表各自持有一把spinlock，将“*uaddr和val的比较操作”与“把进程加入队列的操作”保护在一个临界区中。下图可以做一个形象的说明：<br><img src="/images/futex.png" alt="futex" title="futex"></p>
<h3 id="5-2-相关优化"><a href="#5-2-相关优化" class="headerlink" title="5.2 相关优化"></a>5.2 相关优化</h3><p>pthread_cond_broadcast会唤醒所有等待者，这些等待者被唤醒之后第一件事情便是重新获取与条件变量配合使用的互斥锁（pthread_mutex_t），所有等待者同时争抢mutex，但实际只会有一个抢到锁，其它等待者又被阻塞在互斥锁上，造成资源的浪费，这就是“惊群”现象，作为一种优化，Futex提供了Requeue接口，定义如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">futex_requeue</span><span class="params">(<span class="keyword">int</span> *uaddr, <span class="keyword">int</span> n, <span class="keyword">int</span> *uaddr2, <span class="keyword">int</span> n2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">futex_cmp_requeue</span><span class="params">(<span class="keyword">int</span> *uaddr, <span class="keyword">int</span> n, <span class="keyword">int</span> *uaddr2, <span class="keyword">int</span> n2, <span class="keyword">int</span> val)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>功能跟futex_wake有点相似，但不仅仅是唤醒n个等待uaddr的进程/线程，而更进一步，将n2个等待uaddr的进程移到uaddr2的等待队列中（相当于也futex_wake它们，然后强制让它们futex_wait在uaddr2上面）。<br>在futex_requeue的基础上，futex_cmp_requeue多了一个判断，仅当*uaddr与val相等时才执行操作，否则直接返回，让用户态去重试。<br>对于pthread_cond_broadcast而言，不应该用futex_wake去唤醒所有等待者，而应该用futex_requeue唤醒一个等待者，然后将其他进程都转移到mutex的等待队列上去（随后再由mutex的unlock来逐个唤醒）。这与Java条件变量ContdtionObject中的实现是一样的。</p>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>从上面的分析中，要通过Java语言、JVM虚拟机及linux内核各个层级的配合，实现了ReentrantLock的功能：1）AQS（Java层面）实现锁状态及等待队列的管理，对JVM虚拟机的依赖仅仅是线程的阻塞及唤醒；2）在JVM中，每一个线程绑定一个Parker对象，Parker对象包含一个互斥锁和一个条件变量，线程的阻塞及唤醒就是通过互斥锁或条件变量来实现；3）在内核中，互斥锁和条件变量依赖Futex提供等待队列、阻塞及唤醒的功能，而在内核中要实现原子操作的功能，依赖cpu的CAS指令xchg。可见，基于硬件的CAS指令，操作系统构造了锁级别的等待队列Futex；基于Futex，glibc实现了锁、条件变量及信号量等同步机制；基于gblic中的同步机制，JVM封装了线程阻塞及唤醒的基本操作（UNSAFE.park及unpark）,Java语言实现了如ReentrantLock、Semaphore、ReentrantReadWriteLock、CountDownLatch及CyclicBarrier等高级锁结构，简化了上层业务编写同步及互斥的代码，极大提高了编程效率。</p>
<p><strong>参考：</strong></p>
<hr>
<p><a href="https://github.com/farmerjohngit/myblog/issues/7" target="_blank" rel="noopener">1. 关于同步的一点思考-下</a></p>
<p><a href="http://kexianda.info/2017/08/16/%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97-4-%E4%BB%8EAQS%E5%88%B0futex-%E4%BA%8C-JVM%E7%9A%84Thread%E5%92%8CParker/" target="_blank" rel="noopener">2. HotSpot的JavaThread和Parker</a></p>
<p><a href="https://yq.aliyun.com/articles/6043" target="_blank" rel="noopener">3. linux futex浅析</a></p>
<p><a href="http://fanyilun.me/2016/11/19/Thread.interrupt()%E7%9B%B8%E5%85%B3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">4. Thread.interrupt()相关源码分析</a></p>
<p><a href="https://blog.csdn.net/luoyuyou/article/details/73498640" target="_blank" rel="noopener">5. pthread_mutex_lock实现</a></p>
<p><a href="https://blog.51cto.com/1038741/1939661" target="_blank" rel="noopener">6. pthread_cond_wait</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/20/memcached-memory-model/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/20/memcached-memory-model/" class="post-title-link" itemprop="http://yoursite.com/page/3/index.html">Memcached 内存模型</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-20 09:57:07" itemprop="dateCreated datePublished" datetime="2019-07-20T09:57:07+08:00">2019-07-20</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-07-31 17:17:10" itemprop="dateModified" datetime="2021-07-31T17:17:10+08:00">2021-07-31</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/memcached/" itemprop="url" rel="index"><span itemprop="name">memcached</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Memcached是一个基于内存的缓存系统，存储的是key/value的键值对，与Redis类似。不过相对于Redis，值是无类型的字节数组（类比于Reidis中的String类型）。在Reidis中构建了一个对象系统来存储键值对，Memcached内部是如何处理的？抱着这份好奇心来分析下Memcached的内存模型。</p>
<h2 id="1-整体结构"><a href="#1-整体结构" class="headerlink" title="1. 整体结构"></a>1. 整体结构</h2><p>在开始之前，先说明一些概念：</p>
<ol>
<li>item：存储key/value的数据结构，同时维护了hashtable、LRU链表的指针的信息，是数据的载体；</li>
<li>chunk：存放item，具有固定大小的内存块;</li>
<li>slab：是Memcached一次申请内存的最小单位，默认为1M，然后切分为chunk大小的内存块，是chunk的容器；</li>
<li>slabclass：是管理slab及chunk的数据结构，一个slabclass可分配多个slab，一个slab可分配多个chunk，同时一个slabclass中的chunk具有相同的大小；</li>
<li>slabclass []：管理多个slabclass，不同的slabclass成员管理不同大小的chunk（同一个slabclass中的chunk大小一样）；</li>
<li>LRU list: 管理各个slabclass的最近访问过的item, 以便进行item的清理，list头部是最近访问过的item，每一个slabclass都有一个LRU list；</li>
<li>hashtable: 用于item寻址，对key计算hash值，定位到item所在数组下标，再从item链表中找到对应的item。</li>
<li>slots list: slabclass中用于管理当前slabclass中空闲的item list。</li>
</ol>
<p>下面是Memcached内存模型的整体结构：<br><img src="/images/memcached-memory-model.jpg" alt="memory-model" title="memory-model"></p>
<ol>
<li>slabclass中的slots字段指向空闲链表的头指点，通过item中的next及prev指针形成一个双向链表，新创建且未使用的item或过期释放的item会加入到该链表中；</li>
<li>每一个slabclass都有个LRU list，可以从链表头部和尾部访问LRU链表，一旦item被分配出去，就将该item从空闲链表移到LRU链表中；</li>
<li>一个item指针数组加上item链表构成了一个hashtable，item中的h_next字段指向冲突的下一个结点；</li>
<li>item是非常关键的数据结构，不仅存储了key/value数据，同时也作为hashtable，空闲链表及LRU链表中的元素，存放相关的指针信息。</li>
</ol>
<h2 id="2-数据结构"><a href="#2-数据结构" class="headerlink" title="2. 数据结构"></a>2. 数据结构</h2><h3 id="2-1-slabclass"><a href="#2-1-slabclass" class="headerlink" title="2.1 slabclass"></a>2.1 slabclass</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size;      <span class="comment">/* item的大小*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> perslab;   <span class="comment">/* 单个slab可存放的item的个数*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *slots;            <span class="comment">/* item空闲链表 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sl_curr;   <span class="comment">/* 当前位置*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> slabs;     <span class="comment">/* 表示已经使用的slab_list的大小*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> **slab_list;       <span class="comment">/* 分配的slab数组 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> list_size; <span class="comment">/* 表示分配的slab_list的大小*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> killing;   <span class="comment">/* 在进行slab reassign时使用*/</span></span><br><span class="line">    <span class="keyword">size_t</span> requested;       <span class="comment">/* 此slabclass所占用的实际空间的大小*/</span></span><br><span class="line">&#125; <span class="keyword">slabclass_t</span>;</span><br></pre></td></tr></table></figure>
<p><strong>重点说明的字段：</strong></p>
<ol>
<li>size&amp;perslab：表示item的大小及一个slab包含item的数量；</li>
<li>slots：指向第一个空闲的item；</li>
<li>slab_list：分配的slab数组；</li>
</ol>
<p>slabclass管理了一系列的slab，每一个slab又被切分为相同大小的chunk，而chunk存储最终的item，其关系如下图所示：<br><img src="/images/memcached-slabclass.jpg" alt="slabclass" title="slabclass"></p>
<p>Memcached把slab分为40类（class1～class40），每一个类的slab在内部由一个slabclass数据结构来维护，在slabclass 1中，chunk的大小为96字节，一个slab的大小是固定的1M（1048576字节），因此在slabclass 1中最多可以有perslab = 10922个chunk：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10922</span> × <span class="number">80</span> + <span class="number">64</span> = <span class="number">1048576</span></span><br></pre></td></tr></table></figure></p>
<p>在slabclass 1中，剩余的64字节因为不够一个chunk的大小（96byte），因此会被浪费掉。</p>
<p>每类chunk的大小有一定的计算公式，假定i代表分类，class i的计算公式如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">chunk <span class="title">size</span><span class="params">(class i)</span> </span>= (default_size + item_size) * f^(i<span class="number">-1</span>) + CHUNK_ALIGN_BYTES</span><br></pre></td></tr></table></figure></p>
<ol>
<li>default_size：默认大小为48字节,也就是Memcached默认的key+value的大小为48字节，启动时可以使用-n参数来调节其大小；</li>
<li>item_size：item结构体的长度，固定为48字节。default_size大小为48字节,item_size为48字节，因此slabclass 1的chunk大小为48+48=96字节；</li>
<li>f：f为factor，是chunk变化大小的因素，默认值为1.25，调节f可以影响chunk的步进大小，启动时可以使用-f参数来指定;</li>
<li>CHUNK_ALIGN_BYTES：CHUNK_ALIGN_BYTES是一个修正值，用来保证chunk的大小是某个值的整数倍（在32位机器上要求chunk的大小是4的整数倍）。</li>
</ol>
<p>Memcached分配内存的时候, 根据请求内存块的大小, 找到大小最合适的chunk所在的 slabclass, 然后从这个slabclass找空闲的chunk分配出去. 所谓最合适就是指chunk 的大小能够满足要求, 而且碎片最小。</p>
<h3 id="2-2-item"><a href="#2-2-item" class="headerlink" title="2.2 item"></a>2.2 item</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">stritem</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">stritem</span> *<span class="title">next</span>;</span>      <span class="comment">/* 指向LRU list或空闲列表中的下一个item */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">stritem</span> *<span class="title">prev</span>;</span>      <span class="comment">/* 指向在LRU list或空闲列表中的上一个item*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">stritem</span> *<span class="title">h_next</span>;</span>    <span class="comment">/* 指向此Hashtable中的下一个item*/</span></span><br><span class="line">    <span class="keyword">rel_time_t</span>      time;       <span class="comment">/* 最近的访问时间*/</span></span><br><span class="line">    <span class="keyword">rel_time_t</span>      exptime;    <span class="comment">/* 过期时间*/</span></span><br><span class="line">    <span class="keyword">int</span>             nbytes;     <span class="comment">/* 数据的长度*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> short  refcount;   <span class="comment">/* 引用次数*/</span></span><br><span class="line">    <span class="keyword">uint8_t</span>         nsuffix;    <span class="comment">/* 标志及长度的后辍串的长度*/</span></span><br><span class="line">    <span class="keyword">uint8_t</span>         it_flags;   <span class="comment">/* ITEM的状态 */</span></span><br><span class="line">    <span class="keyword">uint8_t</span>         slabs_clsid;<span class="comment">/* 位于的slabclass的id */</span></span><br><span class="line">    <span class="keyword">uint8_t</span>         nkey;       <span class="comment">/* key的长度*/</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">uint64_t</span> cas;</span><br><span class="line">        <span class="keyword">char</span> end;</span><br><span class="line">    &#125; data[];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果启用cas则在结构尾部接8byte的cas数，即uint64_t*/</span></span><br><span class="line">    <span class="comment">/* 然后是1byte的终止符\0 */</span></span><br><span class="line">    <span class="comment">/* then " flags length\r\n" (no terminating null) */</span></span><br><span class="line">    <span class="comment">/* then data with terminating \r\n (no terminating null; it's binary!) */</span></span><br><span class="line">&#125; item;</span><br></pre></td></tr></table></figure>
<p><strong>重点说明的字段：</strong></p>
<ol>
<li>指针：next,prev用于LRU list及空闲列表，而h_next指向相同哈希值的下一个item；</li>
<li>时间：time,exptime记录了最近访问的时间及过期的时间；</li>
<li>数据长度：nbytes,nkey分别记录了数据的长度及key的长度，nkey的数据类型为uint8_t,决定了key的最大长度为256(8位无符号整数的最大值)；而数据的最大长度由一个slab的值决定，即1M。</li>
<li>data：存储的数据，包括四个部分：cas(可行) + key + suffix + value，整体的结构如下图所示：<br><img src="/images/memcached-item.jpg" alt="item" title="item"></li>
</ol>
<h3 id="2-3-hashtable"><a href="#2-3-hashtable" class="headerlink" title="2.3 hashtable"></a>2.3 hashtable</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> item** primary_hashtable = <span class="number">0</span>;        <span class="comment">//main hashtable</span></span><br></pre></td></tr></table></figure>
<p>hashtable由两部分组成：item哈希数组+item链表，其中primary_hashtable便是哈希数组，根据key计算哈希值，从而快速定位到key所在数组中的index；为了解决key冲突的问题，引入了链表，将冲突的key用链表连接起来，如在整体结构图中所示：item4与item5具有相同的index，用h_next串连起来。</p>
<h3 id="2-4-LRU-list"><a href="#2-4-LRU-list" class="headerlink" title="2.4 LRU list"></a>2.4 LRU list</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LRU list</span></span><br><span class="line"><span class="keyword">static</span> item *heads[LARGEST_ID];   <span class="comment">//指向各slabclass的LRU链表的head结点</span></span><br><span class="line"><span class="keyword">static</span> item *tails[LARGEST_ID];   <span class="comment">//指向各slabclass的LRU链表的tail结点</span></span><br></pre></td></tr></table></figure>
<p> 当Memcached没有足够的内存使用时,根据LRU算法回收item, 这就需要维护一个按照最近访问时间排序的LRU 队列。 在Memcached 中,每个slabclass 维护一个链表, 比如 slabclass[i]的链表头指针为heads[i], 尾指针为tails[i],已分配出去的item都存储在链表中。而且链表中item按照最近访问时间排序, 这相当于一个LRU 队列。</p>
<h2 id="3-内存分配"><a href="#3-内存分配" class="headerlink" title="3. 内存分配"></a>3. 内存分配</h2><p>结合数据模型，对slab及item的使用做一下总结：</p>
<ol>
<li>初始化slabclass数组，每个元素slabclass[i]都是不同size的slabclass；</li>
<li>每分配一个新的slab，都会根据所在的slabclass的size来切分chunk，切分完chunk之后，把chunk空间初始化成一个个free item，并插入到slot链表中；</li>
<li>每使用一个free item都会从slot链表中删除掉并插入到LRU链表相应的位置；</li>
<li>每当一个used item被访问的时候都会更新它在LRU链表中的位置，以保证LRU链表从尾到头淘汰的权重是由高到低的；</li>
<li>会有另一个叫“item爬虫”的线程慢慢地从LRU链表中去爬，把过期的item淘汰掉然后重新插入到slot链表中；</li>
<li>当进行内存分配时，例如一个SET命令，它的一般步骤是：<ol>
<li>计算出要保存的数据的大小，选择相应的slabclass；</li>
<li>从相应的slabclass LRU链表的尾部开始，尝试找几次（默认是5次），看看有没有过期的item，如果有就利用这个过期的item空间；</li>
<li>如果没找到过期的，则尝试去slot链表中拿空闲的free item；</li>
<li>如果slot链表中没有空闲的free item了，尝试申请内存，分配一块新的slab，分配成功后，slot链表就有可用的free item了，返回可用的free item.</li>
<li>如果分配不了新的slab那说明内存都已经满了，用完了，只能淘汰，所以用LRU链表尾部找出一个item并将其淘汰，返回该item。</li>
</ol>
</li>
</ol>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>在Memcached的内存模型中，没有为hashtable及LRU list定义单独的数据结构，而是和slabclass共用了item，分配和释放item的时候只需要修改相应的指针，整体结构比较紧凑，有效利用了内存空间。</p>
<p><strong>参考：</strong></p>
<hr>
<p><a href="http://yaowhat.com/2014/10/02/memcached-memory-manage.html" target="_blank" rel="noopener">1.memcached系列二——内存模型</a></p>
<p><a href="https://www.zybuluo.com/phper/note/443547" target="_blank" rel="noopener">2.彻底弄清楚memcached</a></p>
<p><a href="http://calixwu.com/2014/11/memcached-yuanmafenxi-neicunguanli.html" target="_blank" rel="noopener">3.Memcached源码分析之内存管理</a></p>
<p><a href="https://kenby.iteye.com/blog/1423989" target="_blank" rel="noopener">4.Memcached源码分析之内存管理篇</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Noahsark</p>
              <p class="site-description motion-element" itemprop="description">不畏将来，不念过往</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">34</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">18</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">120</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Noahsark</span>

  

  
</div>

<div class="BbeiAn-info">
    <a target="_blank" href="https://beian.miit.gov.cn/" rel="nofollow">粤ICP备 2021097726号-1 </a>
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v6.5.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.5.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.5.0"></script>



  



  










  





  

  

  

  

  

  
  

  

  

  

  

  

  

</body>
</html>
