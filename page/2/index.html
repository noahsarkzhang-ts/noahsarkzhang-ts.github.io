<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.5.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.5.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.5.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.5.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="不畏将来，不念过往">
<meta name="keywords" content="Java">
<meta property="og:type" content="website">
<meta property="og:title" content="以太格">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="以太格">
<meta property="og:description" content="不畏将来，不念过往">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="以太格">
<meta name="twitter:description" content="不畏将来，不念过往">






  <link rel="canonical" href="http://yoursite.com/page/2/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>以太格</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">以太格</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-commonweal">

    
    
    
      
    

    

    <a href="/404/" rel="section"><i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>公益 404</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于我</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/10/08/select-and-epoll/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/10/08/select-and-epoll/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">Select 和 Epoll实现</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-10-08 18:17:33" itemprop="dateCreated datePublished" datetime="2020-10-08T18:17:33+08:00">2020-10-08</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-07-31 17:17:10" itemprop="dateModified" datetime="2021-07-31T17:17:10+08:00">2021-07-31</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/网络协议/" itemprop="url" rel="index"><span itemprop="name">网络协议</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">41k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">37 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇文章主要讲述 select 和 epoll 的实现原理，包括底层的数据结构、与设备的回调处理机制及两种实现之间的差异。</p>
<h2 id="1-知识储备"><a href="#1-知识储备" class="headerlink" title="1. 知识储备"></a>1. 知识储备</h2><p>在介绍 select 和 epoll 的实现原理前，先介绍两个知识点，分别是 1）文件的 poll 函数；2）linux 的wakeup callback机制。select 和 epoll 很大程度上就是基于这两点构建的。</p>
<h3 id="1-1-poll-函数"><a href="#1-1-poll-函数" class="headerlink" title="1.1 poll 函数"></a>1.1 poll 函数</h3><p>在 linux 中，设备的操作抽象为文件的操作，对网络设备的操作同样也是文件操作。为了实现非阻塞的数据读取，文件提供了 poll 操作，该操作为上层应用提供了探测设备文件是否有数据可读的接口，同时结合文件的等待队列，上层应用可以对感兴趣的事件添加处理函数，这个处理函数通常是向等待队列中添加一个等待结点，这个等待结点会关联一个 callback 函数，当相关事件满足时触发 callback 函数，最后 poll 函数返回当前设备文件的状态，上层应用根据返回状态决定是否阻塞该线程，poll 函数不阻塞线程。通过这种方式，设备文件提供了基于事件处理的回调机制，select/poll/epoll 就是基于这种方式来实现的。 </p>
<p><img src="/images/tcp/poll.jpg" alt="poll" title="poll"></p>
<p>poll 函数分为三个步骤：</p>
<ol>
<li>获取事件对应的等待队列；</li>
<li>初始化一个等待结点，设置 callback 函数，并将等待结点加入到等待队列中，此时并不阻塞调用线程；</li>
<li>获取设备当前的状态并返回。</li>
</ol>
<p>在 poll 函数中，上层应用可以根据业务的不同可以自定义 poll_queue_proc 和 唤醒 callback 函数，从而实现不同的功能，select/poll/epoll 分别实现了这两个函数，它们之间的差异从这两个函数中也可以看出。下面是一个 poll 函数实例。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">scull_p_poll</span><span class="params">(struct file *filp, poll_table *wait)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Scull_Pipe *dev = filp-&gt;private_data;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* The buffer is circular; it is considered full</span></span><br><span class="line"><span class="comment">	* if "wp" is right behind "rp". "left" is 0 if the</span></span><br><span class="line"><span class="comment">	* buffer is empty, and it is "1" if it is completely full.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="comment">// 处理私有业务</span></span><br><span class="line">	<span class="keyword">int</span> left = (dev-&gt;rp + dev-&gt;buffersize - dev-&gt;wp) % dev-&gt;buffersize;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 在不同的等待队列上调用 poll_wait 函数</span></span><br><span class="line">	poll_wait(filp, &amp;dev-&gt;inq, wait);</span><br><span class="line">	poll_wait(filp, &amp;dev-&gt;outq, wait);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* readable */</span></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;rp != dev-&gt;wp) mask |= POLLIN | POLLRDNORM;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* writable */</span></span><br><span class="line">	<span class="keyword">if</span> (left != <span class="number">1</span>) mask |= POLLOUT | POLLWRNORM;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>poll 函数的定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 文件操作  </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供给 poll/select/epoll 使用，获取文件当前状态, 以及就绪通知接口函数</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*poll)</span> <span class="params">(struct file *, struct poll_table_struct *)</span></span>; </span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向文件注册事件及处理函数  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_struct</span> &#123;</span></span><br><span class="line">    <span class="comment">// 处理函数</span></span><br><span class="line">    poll_queue_proc _qproc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事件</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>  _key;  </span><br><span class="line">&#125; poll_table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// poll_queue_proc 函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*poll_queue_proc)</span><span class="params">(struct file *, <span class="keyword">wait_queue_head_t</span> *, struct poll_table_struct *)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="1-2-wakeup-callback机制"><a href="#1-2-wakeup-callback机制" class="headerlink" title="1.2 wakeup callback机制"></a>1.2 wakeup callback机制</h3><p>在上节的 poll 函数中，会检查文件的状态（可读/可写/可连接），同时在事件的等待队列添加一个等待结点，待续结点中注册一个 callback 回调函数，事件触发时，再调用 callback 回调函数，唤醒结点中的 task 来处理事件。这种机制正时使用了 linux 内核 wakeup callback机制。<br>Linux 内核通过睡眠队列来组织所有等待某个事件的 task，而 wakeup 机制则可以异步唤醒整个睡眠队列上的 task，每一个睡眠队列上的节点都拥有一个 callback，wakeup 逻辑在唤醒睡眠队列时，会遍历该队列链表上的每一个节点，调用每一个节点的 callback，如果遍历过程中遇到某个节点是排他节点，则终止遍历，不再继续遍历后面的节点。总体上的逻辑可以用下面的伪代码表示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">define sleep_list;</span><br><span class="line">define wait_entry;</span><br><span class="line">wait_entry.task = current_task;</span><br><span class="line">wait_entry.callback = func1;</span><br><span class="line"><span class="keyword">if</span> (something_not_ready); then</span><br><span class="line">    <span class="comment"># 将任务加入等待队列</span></span><br><span class="line">    add_entry_to_list(wait_entry, sleep_list);</span><br><span class="line">go_on:</span><br><span class="line">    <span class="comment"># 根据情况进行睡眠或唤醒</span></span><br><span class="line">    schedule();</span><br><span class="line">    <span class="keyword">if</span> (something_not_ready); then</span><br><span class="line">        goto go_on;</span><br><span class="line">    endif</span><br><span class="line">    del_entry_from_list(wait_entry, sleep_list);</span><br><span class="line">endif</span><br></pre></td></tr></table></figure></p>
<p>唤醒的流程：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">something_ready;</span><br><span class="line">for_each(sleep_list) <span class="keyword">as</span> wait_entry; do</span><br><span class="line">    wait_entry.callback(...);</span><br><span class="line">    <span class="keyword">if</span>(wait_entry.exclusion); then</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    endif</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<p>callback 函数包含于唤醒的主要逻辑，伪代码如下所示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">common_callback_func(...)</span><br><span class="line">&#123;</span><br><span class="line">    do_something_private;</span><br><span class="line">    wakeup_common;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 poll/select/epoll 中都会定义各自的 callback 函数，该函数一般包括两部分：1）私有逻辑；2）唤醒 task。callback 函数由驱动来调用（在 NIC 中由软件中断调用）。</p>
<h3 id="1-3-I-O-多路复用"><a href="#1-3-I-O-多路复用" class="headerlink" title="1.3 I/O 多路复用"></a>1.3 I/O 多路复用</h3><p>I/O 多路复用是一种优化技术，它是为了避免一个线程处理一个 I/O 设备文件，转而由一个线程来监听多个 I/O 文件，来提供系统的效率。poll/select/epoll 底层使用了这种 I/O 模式。<br><img src="/images/tcp/io-multiplexing.jpg" alt="io-multiplexing" title="io-multiplexing"></p>
<h2 id="2-select"><a href="#2-select" class="headerlink" title="2. select"></a>2. select</h2><h3 id="2-1-整体流程"><a href="#2-1-整体流程" class="headerlink" title="2.1 整体流程"></a>2.1 整体流程</h3><p>select 方法调用：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FD_SETSIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFDBITS (8 * sizeof(unsigned long))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __FDSET_LONGS (FD_SETSIZE/NFDBITS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据结构 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> fds_bits[__FDSET_LONGS];</span><br><span class="line">&#125; fd_set;</span><br><span class="line"></span><br><span class="line"><span class="comment">// select 文件调用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> max_fd,  <span class="comment">/* 最大文件数 */</span></span></span></span><br><span class="line"><span class="function"><span class="params">    fd_set *readset, <span class="comment">/* 读事件文件集合 */</span></span></span></span><br><span class="line"><span class="function"><span class="params">    fd_set *writeset, <span class="comment">/* 写事件文件集合 */</span></span></span></span><br><span class="line"><span class="function"><span class="params">    fd_set *exceptset, </span></span></span><br><span class="line"><span class="function"><span class="params">    struct timeval *timeout</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>; <span class="comment">// 返回值就绪描述符的数目</span></span><br></pre></td></tr></table></figure></p>
<p>从 select 方法定义来看，每次调用都需要将文件集合在用户空间及内核空间进行复制，并且文件最大的数量限制在 1024 个。组合上面的内容，可以知道 select 会定义两个函数 poll_queue_proc 和 唤醒 callback 函数，注册到 poll 函数中，在这里，这两个函数分别对应：__pollwait() 和 pollwake。其整体的流程如下所示：</p>
<p><img src="/images/tcp/select.jpg" alt="select" title="select"></p>
<p>select 调用主要做了三件事情：</p>
<ol>
<li>初始化poll_wqueues结构，包括几个关键函数指针的初始化，用于驱动中进行回调处理；</li>
<li>循环遍历监测的文件描述符，并且调用 f_op-&gt;poll() 函数，如果有监测条件满足，则会跳出循环；</li>
<li>在监测的文件描述符都不满足条件时，会让当前进程进行睡眠，超时唤醒，或者被所属的等待队列唤醒。</li>
</ol>
<p>select 函数的循环退出条件有三个：</p>
<ol>
<li>检测的文件描述符满足条件；</li>
<li>超时；</li>
<li>由等待事件触发。</li>
</ol>
<h3 id="2-2-数据结构"><a href="#2-2-数据结构" class="headerlink" title="2.2 数据结构"></a>2.2 数据结构</h3><p>接下来再看下 select 内部的数据结构：<br><img src="/images/tcp/select_data_struct.jpg" alt="select_data_struct" title="select_data_struct"><br>在 select 方法中，会维护一个 struct poll_wqueues 结构，其中两个关键字段：</p>
<ol>
<li>poll_table：该结构体中的函数指针_qproc指向__pollwait函数；</li>
<li>struct poll_table_entry[]：存放不同文件的 poll_table_entry，这些条目的增加是在驱动调用 __pollwait() 时进行初始化并完成添加的，每一个文件都会添加一个条目。</li>
</ol>
<p>在这个数据结构可以看出，调用 poll 函数之后，会在所有文件的等待队列中加入一个结点，这个结点会持有当前 task 的信息，当事件触发之后，从而可以知道唤醒那一个进程；</p>
<p>从上面的分析可以看出，select 有以下的缺点：</p>
<ol>
<li>每次 select 方法调用都会传入文件集合参数，涉及到用户空间及内核空间的两次复制；</li>
<li>每一次调用都需要遍历所有的文件调用 poll 函数，效率较低（在用户空间中，也需要遍历所有文件查看那些文件有事件触发）；</li>
<li>监听的文件数量有限，最大 1024 个。</li>
</ol>
<h2 id="3-epoll"><a href="#3-epoll" class="headerlink" title="3. epoll"></a>3. epoll</h2><h3 id="3-1-整体流程"><a href="#3-1-整体流程" class="headerlink" title="3.1 整体流程"></a>3.1 整体流程</h3><p>epoll 解决了 select 的缺点，在大并发场景下，epoll 得到了广泛的应用，它从以下几个方面解决了 select 的缺点：</p>
<ol>
<li>生成一个 epoll 文件，将监听的文件描述符加入到这个文件的数据结构（红黑树）中，只用添加一次，避免了数据的来回复制；</li>
<li>epoll 文件中维护了一个可读文件队列，每次只遍历该队列，避免所有文件的遍历；</li>
<li>监听的文件不受限制。</li>
</ol>
<p>下面我们来看下 epoll的实现原理，首先看下调用方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成一个 ep 文件，把所有需要监听的文件都放到 ep 文件中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> <span class="built_in">size</span>)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// epoll_ctl 添加一个监听的文件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">int</span> epfd,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">int</span> op, </span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">int</span> fd, </span></span></span><br><span class="line"><span class="function"><span class="params">	struct epoll_event *event</span></span></span><br><span class="line"><span class="function"><span class="params">	)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// epoll_wait 负责检测可读队列，没有可读的文件则阻塞进程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">int</span> epfd, </span></span></span><br><span class="line"><span class="function"><span class="params">	struct epoll_event * events, </span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">int</span> maxevents, </span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">int</span> timeout</span></span></span><br><span class="line"><span class="function"><span class="params">	)</span></span>;</span><br></pre></td></tr></table></figure>
<p>epoll_create 生成一个 ep 文件，通过 epoll_ctl 方法添加/删除文件，epoll_wait 方法只遍历满足条件的可读队列，提高了效率。这三个方法大概的逻辑如下描述。<br><strong>epoll_ctl 主要逻辑：</strong></p>
<ol>
<li>定义一个 epitem 结构，代表一个监听的文件，并加入到红黑树中；</li>
<li>生成一个等待结点，加入到这文件 （socket 文件）的等待队列中；</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">define epitem</span><br><span class="line">add_epitem_to_rbtree(epitem) </span><br><span class="line"></span><br><span class="line">define wait_entry</span><br><span class="line">wait_entry.socket = this_socket;</span><br><span class="line">wait_entry.callback = epoll_wakecallback;</span><br><span class="line">add_entry_to_list(wait_entry, this_socket.sleep_list);</span><br></pre></td></tr></table></figure>
<p><strong>epoll_wait 主要逻辑：</strong></p>
<ol>
<li>定义一个等待结点，将结点的 task （实际为 private 字段，为了简要描述，定义为 task） 设置为当前 task （调用 epoll_wait的进程），并设置回调函数；</li>
<li>判断当前可读队列是否为空，如果为空则将等待结点加入到 ep 文件的等待队列上，并阻塞该进程；</li>
<li>如果当前可读队列不为空，则遍历准备好的可读队列，返回数据给用户进程；</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">define single_wait_list</span><br><span class="line">define single_wait_entry</span><br><span class="line">single_wait_entry.callback = wakeup_common;</span><br><span class="line">single_wait_entry.task = current_task;</span><br><span class="line"><span class="keyword">if</span> (ready_list_is_empty); then</span><br><span class="line">    <span class="comment"># 等待结点加入到 ep 文件的等待队列中</span></span><br><span class="line">    add_entry_to_list(single_wait_entry, single_wait_list);</span><br><span class="line">go_on:  </span><br><span class="line">    <span class="comment"># 阻塞进程</span></span><br><span class="line">    schedule();</span><br><span class="line">    <span class="keyword">if</span> (sready_list_is_empty); then</span><br><span class="line">        goto go_on;</span><br><span class="line">    endif</span><br><span class="line">    del_entry_from_list(single_wait_entry, single_wait_list);</span><br><span class="line">endif</span><br><span class="line"><span class="comment"># 遍历准备好的可读队列</span></span><br><span class="line">for_each_ready_list <span class="keyword">as</span> sk; do</span><br><span class="line">    event.evt = sk.poll(...);</span><br><span class="line">    event.sk = sk;</span><br><span class="line">    put_event_to_user;</span><br><span class="line">done;</span><br></pre></td></tr></table></figure>
<p>在这里需要注意的是，当前进程不像 select 方法，进程是阻塞在监听文件（socket 文件）的等待队列上，而是阻塞在 ep 文件自己的阻塞队列上，如上面的流程所述。这里有问题，如何唤醒阻塞的进程？答案在注册到监听文件的回调函数上，在 epoll_ctl 中，我们同样在监听文件的等待队列上加入了一个等待结点，当文件可读时，调用该回调函数，借助该函数，再唤醒阻塞在 ep 文件等待队列上的进程，其流程如下所述：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">epoll_wakecallback(...)</span><br><span class="line">&#123;</span><br><span class="line">    add_this_socket_to_ready_list;</span><br><span class="line">    wakeup_single_epoll_waitlist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在唤醒进程之前，会将该文件加入到可读队列中。</p>
<p>epoll_wait 流程如下图所示：<br><img src="/images/tcp/epoll.jpg" alt="epoll" title="epoll"></p>
<h3 id="3-2-数据结构"><a href="#3-2-数据结构" class="headerlink" title="3.2 数据结构"></a>3.2 数据结构</h3><p>数据结构如下所示：<br><img src="/images/tcp/epoll_data_struct.jpg" alt="epoll_data_struct" title="epoll_data_struct"><br>关键点说明：</p>
<ol>
<li>进程阻塞在 epoll 文件的等待队列上，不是监听文件的等待队列上；</li>
<li>epoll 会将满足条件的文件提前放在可读文件队列 rdllist 中，减少文件遍历的数量；</li>
<li>epoll 将监听的文件使用红黑树管理，可有效地进行文件的添加及删除；</li>
<li>唤醒操作由监听文件等待队列中的回调函数触发，然后再唤醒阻塞在 epoll 文件上的进程。</li>
</ol>
<p>对应的数据结构定义为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 每创建一个epoll 文件, 内核就会分配一个eventpoll与之对应 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Protect the this structure access */</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> lock;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This mutex is used to ensure that files are not removed</span></span><br><span class="line"><span class="comment">     * while epoll is using them. This is held during the event</span></span><br><span class="line"><span class="comment">     * collection loop, the file cleanup path, the epoll file exit</span></span><br><span class="line"><span class="comment">     * code and the ctl operations.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mtx</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wait queue used by sys_epoll_wait() */</span></span><br><span class="line">    <span class="comment">/* epoll 文件等待队列，进程就是阻塞在该队列上 */</span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> wq;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wait queue used by file-&gt;poll() */</span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> poll_wait;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* List of ready file descriptors */</span></span><br><span class="line">    <span class="comment">/* 所有已经准备好的可读文件队列 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdllist</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* RB tree root used to store monitored fd structs */</span></span><br><span class="line">    <span class="comment">/* 红黑树，存储所有监听的文件 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">rbr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This is a single linked list that chains all the "struct epitem" that</span></span><br><span class="line"><span class="comment">     * happened while transfering ready events to userspace w/out</span></span><br><span class="line"><span class="comment">     * holding -&gt;lock.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">ovflist</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The user that created the eventpoll descriptor */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Each file descriptor added to the eventpoll interface will</span></span><br><span class="line"><span class="comment"> * have an entry of this type linked to the "rbr" RB tree.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* epitem 表示一个被监听的文件 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> &#123;</span></span><br><span class="line">    <span class="comment">/* RB tree node used to link this structure to the eventpoll RB tree */</span></span><br><span class="line">    <span class="comment">/* 代表在红黑树中的结点 */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="comment">/* RB tree node links this structure to the eventpoll RB tree */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rbn</span>;</span></span><br><span class="line">		<span class="comment">/* Used to free the struct epitem */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* List header used to link this structure to the eventpoll ready list */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdllink</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Works together "struct eventpoll"-&gt;ovflist in keeping the</span></span><br><span class="line"><span class="comment">     * single linked chain of items.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The file descriptor information this item refers to */</span></span><br><span class="line">    <span class="comment">/* epitem对应的文件和 struct file */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_filefd</span> <span class="title">ffd</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Number of active wait queue attached to poll operations */</span></span><br><span class="line">    <span class="keyword">int</span> nwait;</span><br><span class="line">    <span class="comment">/* List containing poll wait queues */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">pwqlist</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The "container" of this item */</span></span><br><span class="line">    <span class="comment">/* 关联的eventpoll结构 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* List header used to link this item to the "struct file" items list */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">fllink</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The structure that describe the interested events and the source fd */</span></span><br><span class="line">    <span class="comment">/* 当前文件关心的事件 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 红黑树结点 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>  __rb_parent_color;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rb_right</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rb_left</span>;</span></span><br><span class="line">&#125; __attribute__((aligned(<span class="keyword">sizeof</span>(<span class="keyword">long</span>))));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 红黑树根结点 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rb_node</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_filefd</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Wait structure used by the poll hooks */</span></span><br><span class="line"><span class="comment">/* 用于构造回调函数的数据结构，在 ep_ptable_queue_proc 中使用 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eppoll_entry</span> &#123;</span></span><br><span class="line">    <span class="comment">/* List header used to link this structure to the "struct epitem" */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">llink</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The "base" pointer is set to the container "struct epitem" */</span></span><br><span class="line">    <span class="comment">/* 关联的 epitem */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">base</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Wait queue item that will be linked to the target file wait</span></span><br><span class="line"><span class="comment">     * queue head.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* 添加到监听文件等待队列中的等待结点 */</span></span><br><span class="line">    <span class="keyword">wait_queue_t</span> wait;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The wait queue head that linked the "wait" wait queue item */</span></span><br><span class="line">    <span class="comment">/* 监听文件等待队列队首结点 */</span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> *whead;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Wrapper struct used by poll queueing */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ep_pqueue</span> &#123;</span></span><br><span class="line">    poll_table pt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Used by the ep_send_events() function as callback private data */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ep_send_events_data</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> maxevents;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> __<span class="title">user</span> *<span class="title">events</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>通过对 select 及 epoll 方法的分析，可以知道，epoll 从各个方面进行了优化，相对 select, 在大部分场景下，性能有了质的飞跃，这也是网络中间件中大部分选用 epoll 的原因。</p>
<p><strong>参考：</strong></p>
<hr>
<p><a href="https://coderbee.net/index.php/linux/20190919/1942" target="_blank" rel="noopener">1. Linux select/poll/epoll 原理（一）实现基础</a><br><a href="https://blog.csdn.net/eZiMu/article/details/54896708" target="_blank" rel="noopener">2. inux驱动—file_operations之poll</a><br><a href="https://mp.weixin.qq.com/s/bjM3uEDg61vhNN8Y661L7w" target="_blank" rel="noopener">3. Linux select/poll机制原理分析</a><br><a href="https://blog.csdn.net/dog250/article/details/50528373" target="_blank" rel="noopener">4. Linux内核中网络数据包的接收-第二部分 select/poll/epoll</a><br><a href="https://my.oschina.net/alchemystar/blog/3008840" target="_blank" rel="noopener">5. 从linux源码看epoll</a><br><a href="https://blog.csdn.net/russell_tao/article/details/17119729" target="_blank" rel="noopener">6. 高性能网络编程5–IO复用与并发编程</a><br><a href="https://blog.nowcoder.net/n/dade4d8c53d144dfa78157887e2cb33e" target="_blank" rel="noopener">7. epoll源码分析</a><br><a href="https://zhuanlan.zhihu.com/p/60713292" target="_blank" rel="noopener">8. 带您进入内核开发的大门 | 内核中的等待队列</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/20/illustrated-TCP-protocol/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/09/20/illustrated-TCP-protocol/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">图解TCP协议</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-09-20 16:58:48" itemprop="dateCreated datePublished" datetime="2020-09-20T16:58:48+08:00">2020-09-20</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-07-31 17:17:10" itemprop="dateModified" datetime="2021-07-31T17:17:10+08:00">2021-07-31</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/网络协议/" itemprop="url" rel="index"><span itemprop="name">网络协议</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">17k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">15 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇文章讲述网络报文从网卡 NIC （network interface controller）接收，再到操作系统网络协议栈处理，最后到用户程序接收报文处理报文的简化过程，希望能对TCP协议进行一个整体、概括性的总结。</p>
<h2 id="1-网络子系统"><a href="#1-网络子系统" class="headerlink" title="1. 网络子系统"></a>1. 网络子系统</h2><p>从网络中发送过来的网络报文首先到达网卡 NIC，使用 DMA 技术将报文拷贝到内存中，再发起中断请求 CPU 进行中断处理，CPU 调用驱动中的方法处理网络报文，处理完毕之后传给网络协议栈处理，如流程如下图所示：</p>
<p><img src="/images/tcp/data-received.jpg" alt="data-received" title="data-received"></p>
<ol>
<li>网卡 NIC 从外部网络收到报文；</li>
<li>网卡 NIC 通过 DMA 技术直接将报文拷贝到 RAM 中，以 SKB(Socket Buffer)结构存储。NIC 一般都会在 RAM 中申请一个环形的接收队列，代表了接收的能力（同时也会发送环形队列，用于报文的发送）；</li>
<li>网卡 NIC 向 CPU 触发一次硬件中断，通知有报文需要处理，如果只有一个 CPU，没有其它选择；如果是多 CPU 的情况，会涉及到 CPU 的选择，后面我们会进行讲述；</li>
<li>CPU 处理中断，调用 NIC 驱动注册到内核中的的中断处理函数，在这里我们以 NAPI 为例（NAPI 合并 IRQ(Interrupt ReQuest),减少中断次数）；</li>
<li>中断处理函数会关闭中断，后续报文直接由拷贝到内存中，避免后续报文重复触发中断；</li>
<li>触发软中断，进行报文处理，中断处理包含两个阶段：1）硬件中断，响应 NIC 中断信号，触发软件中断；2）软件中断，由专门的内核线程来执行，网络报文的处理是由软件中断来执行。</li>
</ol>
<p>上面的流程是简要的一个流程，有些知识链条是断裂的，下面将补充三个知识点：1）软件中断；2） NIC 与环形队列的关系；3） CPU 的选择问题。</p>
<h3 id="1-1-软件中断"><a href="#1-1-软件中断" class="headerlink" title="1.1 软件中断"></a>1.1 软件中断</h3><p>在设备驱动中，一般通过中断的方式告诉 CPU 数据已经准备好，可以来取数据了。在内核中，中断处理函数优先级非常高，同时会阻塞其它中断处理。所以要求硬件中断处理函数必须尽可能快、效率尽可能高。为了减少中断处理时间，引入了软件中断，将复杂的处理延迟到软件中断中处理，如网络报文的处理，而在硬件中断中触发软件中断。</p>
<p>系统在启动时，会为每一个 CPU 分配一个内核线程 ksoftirqd 线程，专门处理软件中断，目前能够处理的软件中断有6个，其中网络处理的有两个，分别是接收中断 NET_RX_SOFTIRQ 和 发送中断 NET_TX_SOFTIRQ。这两个中断在net_dev_init方法中注册到内核。初始化的流程如下所示：<br><img src="/images/tcp/softirq.jpg" alt="softirq" title="softirq"></p>
<ol>
<li>系统启动时，创建 ksoftirad 内核线程，处理软件中断，每一个 CPU 对应一个线程；</li>
<li>ksoftirqd 内部是一个事件处理处理函数 run_ksoftirqd，不断接收中断处理事件；</li>
<li>驱动为每一个 CPU 生成 poll_list 链表，主要是存放触发中断事件的 NIC设备；</li>
<li>注册软件中断处理函数 net_rx_action, 中断号为 NET_RX_SOFTIRQ(同时也会注册NET_TX_SOFTIRQ)，负责报文接收工作；</li>
<li>收到报文时，驱动为将触发中断的 NIC 加入到 CPU 的 poll_list中；</li>
<li>驱动设置 softirq_pending 中的 NET_RX_SOFTIRQ 标志位，表明需要处理 NET_RX_SOFTIRQ 中断；</li>
<li>run_ksoftirqd 检查到 softirq_pending 标志位，如果有设置标志位，执行 __do_softirq 函数；</li>
<li>__do_softirq 查找到 NET_RX_SOFTIRQ 对应的中断处理函数 net_rx_action，并执行该函数，处理报文的接收。</li>
</ol>
<h3 id="1-2-RSS"><a href="#1-2-RSS" class="headerlink" title="1.2 RSS"></a>1.2 RSS</h3><p>在多核的系统中，为了充分利用多核处理的优势，提高网络处理的吞吐量，NIC 引入了 RSS(Receive Side Scaling) 或 multiqueue 的技术。这种技术将 NIC 接收队列抽象为多个队列，每一个队列分配一个唯一的中断号，再将队列与某个 CPU 建立映射关系。输入的报文根据 NIC中的 hash 函数（根据Src ip, Src port, Dest ip, Dest port, Protocol）负载到指定的接收队列中，再根据对应的中断号触发硬件中断，后续的报文者将由指定的 CPU 来处理，整体的流程如下图所示：<br><img src="/images/tcp/RSS.jpg" alt="RSS" title="RSS"></p>
<ol>
<li>NIC 接收到外部报文；</li>
<li>使用 DMA 技术将报文拷贝到 SKB 双向链表中；</li>
<li>使用 hash 函数，将该报文负载到指定的队列中，将触发中断，每一个接收队列都对应一个环形队列，有大小的限制，超过容量之后，报文会丢弃；</li>
<li>在硬件中断中处理软件中断，与上面的内容一致。</li>
</ol>
<p>如果支持 RSS 的话，NIC 为每个队列分配一个 IRQ，通过 /proc/interrupts 进行查看，如下所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/interrupts</span><br><span class="line">           CPU0       CPU1       CPU2       CPU3</span><br><span class="line"> 56:   20209820    4671909   34469139    1896297   PCI-MSI-edge      ens160-rxtx-0</span><br><span class="line"> 57:    3259205    5165620    2125138    4534929   PCI-MSI-edge      ens160-rxtx-1</span><br><span class="line"> 58:    5883233   10958192    2339523   22326712   PCI-MSI-edge      ens160-rxtx-2</span><br><span class="line"> 59:    4307729    2329793    9003652   25191926   PCI-MSI-edge      ens160-rxtx-3</span><br></pre></td></tr></table></figure></p>
<p>可以看到，中断号 56~59 分别分配给了 4 个队列，通过 /proc/irq/IRQ_NUMBER/smp_affinity 设置某个中断由某个 CPU 触发，我们可以查看中断号 56 的配置情况。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/irq/56/smp_affinity</span><br><span class="line">4</span><br></pre></td></tr></table></figure></p>
<p>0 号 CPU 的掩码是 0x1 (0001)，1 号 CPU 掩码是 0x2 (0010)，2 号 CPU 掩码是 0x4 (0100)，3 号 CPU 掩码是 0x8 (1000) 依此类推。4 表示使用 CPU 2，另外可以查看或配置环形队列的长度。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ ethtool -g ens160</span><br><span class="line">Ring parameters <span class="keyword">for</span> ens160:</span><br><span class="line">Pre-set maximums:</span><br><span class="line">RX:             4096</span><br><span class="line">RX Mini:        0</span><br><span class="line">RX Jumbo:       4096</span><br><span class="line">TX:             4096</span><br><span class="line">Current hardware settings:</span><br><span class="line">RX:             256</span><br><span class="line">RX Mini:        0</span><br><span class="line">RX Jumbo:       128</span><br><span class="line">TX:             512</span><br></pre></td></tr></table></figure></p>
<p>在 NIC 中引入 RSS 技术，有效地提高了网络处理的吞吐量。如果硬件不支持 RSS 技术，内核提供了 RPS(Receive Packet Steering) 技术，通过软件的技术来实现多核处理网络报文。PRS 技术的原理是：硬件中断只由一个 CPU 处理，然后根据报文计算 hash 值并负载到特定的 CPU 上，通过 Inter-processor Interrupt(IPI) 通知特定的 CPU 来进行软件中断处理。 Receive Flow Steering(RFS) 一般和 RPS 配合一起工作。RPS 是将收到的报文分配到不同的 CPU 以实现负载均衡，保证同一个 Flow 的数据包都由一个 CPU 处理，类似会话绑定的技术。</p>
<p><img src="/images/tcp/RPS.jpg" alt="RPS" title="RPS"></p>
<p>可以通过 /proc/sys/net/core/netdev_max_backlog 查看 netdev_max_backlog 的默认值。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/sys/net/core/netdev_max_backlog</span><br><span class="line">1000</span><br></pre></td></tr></table></figure></p>
<h3 id="1-3-报文处理"><a href="#1-3-报文处理" class="headerlink" title="1.3 报文处理"></a>1.3 报文处理</h3><p>上面的内容讲述了硬件中断的相关内容，接下来进入软件中断的处理流程，其流程（以NAPI为例）如下所示：<br><img src="/images/tcp/net-rx-action.jpg" alt="net-rx-action" title="net-rx-action"><br>net_rx_action 函数处理当前 CPU 中设备列表中的设备( NAPI poll structure)，这些设备主要来自两个地方：1）驱动中调用 napi_schedule 方法加入；2）使用 Inter-processor Interrupt 方法加入（RPS），具体流程如下：</p>
<ol>
<li>遍历当前 CPU 的设备列表 poll_list，处理所有的 NAPI 设备；</li>
<li>检查 budget 及软件中断的运行时间，避免处理函数占用过多的 CPU 时间，控制 budget 可以影响执行的时间，它可以通过 net.core.netdev_budget 参数进行配置；</li>
<li>调用驱动中注册的 poll函数，在 igb 驱动中调用的是 igb_poll 函数；</li>
<li>poll 函数读取环形队列中的 packet ；</li>
<li>如果设备支持 GRO，则需要调用 napi_gro_receive 函数，Generic Receive Offloading(GRO) 是 Large receive offload 的一个实现，LRO 就是在收到多个数据包的时候将同一个 Flow 的多个数据包按照一定的规则合并起来交给上层处理，这样就能减少上层需要处理的数据包数量；</li>
<li>报文传给 net_receive_skb，进行下一步处理。</li>
</ol>
<p>在 netif_receive_skb 方法中，会根据是否开启 RPS 来进行不同处理，如果开启了 RPS，会使用 IRI (Inter-processor Interrupt )技术，将报文转给远程 CPU 进行处理，实现类似硬件 RSS 的技术；如果未开启，除了将报文分发给 taps(PCAP), 实现抓包功能，同时将报文传给 IP 协议层，由 IP 协议进行下一步处理，其流程如下所示：<br><img src="/images/tcp/netif-receive-skb.jpg" alt="netif-receive-skb" title="netif-receive-skb"><br>开启 RPS 功能：</p>
<ol>
<li>将报文传给 enqueue_to_backlog 方法；</li>
<li>报文加入到远程 CPU 的输入队列中；</li>
<li>将 NIC 加入到远程 CPU 的设备列表中，使用 IRI, 触发过程 CPU 的软件中断；</li>
<li>远程 CPU 读取输入队列中的报文；</li>
<li>将报文传给 __net_receive_skb_core 方法；</li>
<li>将报文分发给 taps(PCAP), 实现抓包功能；</li>
<li>将报文传给 IP 协议层，进行下一步处理。</li>
</ol>
<p>未开启 RPS 功能：</p>
<ol>
<li>将报文传给 __net_receive_skb_core 方法；</li>
<li>将报文分发给 taps(PCAP), 实现抓包功能；</li>
<li>将报文传给 IP 协议层，进行下一步处理。</li>
</ol>
<h2 id="2-IP-协议层"><a href="#2-IP-协议层" class="headerlink" title="2. IP 协议层"></a>2. IP 协议层</h2><p>IP 协议层主要是实现路由功能，结合 netfilter 定义的钩子函数，可以通过 iptables 配置 ip 路由功能，流程如下所示：<br><img src="/images/tcp/ip-rcv.jpg" alt="ip-rcv" title="ip-rcv"><br>在这里有三个 netfilter 钩子函数：</p>
<ol>
<li>NF_INET_PRE_ROUTING：可以在路由前对数据包进行修改或丢弃；</li>
<li>NF_INET_FORWARD：实现转发功能；</li>
<li>NF_INET_LOCAL_IN：本地 IP 的入口，触发相应的配置。</li>
</ol>
<h2 id="3-TCP-协议层"><a href="#3-TCP-协议层" class="headerlink" title="3. TCP 协议层"></a>3. TCP 协议层</h2><p>报文到了 TCP 协议层，会根据 socket 锁被占用的状态，将报文发送到不同的接收队列，在这里有 4 个队列，分别是：receive queue, out_of_order queue, prequeue queue, backlog queue。通过接收队列，内核软件中断线程与 socket 线程实现了数据的交换。<br><img src="/images/tcp/tcp-v4-rcv.jpg" alt="tcp-v4-rcv" title="tcp-v4-rcv"></p>
<p>4 个队列使用场景：</p>
<ol>
<li>receive queue ：当 socket 没有被线程占用的时候，报文会加入到该队列；</li>
<li>out_of_order queue ：临时存放乱序的报文；</li>
<li>prequeue queue ：当 socket 被占用且 tcp_low_latency 值为 0 时，报文加入该队列；</li>
<li>backlog queue ：当 socket 正在被读取时，新收到的所有报文加入到该队列（如果报文是乱序的，后续还要加入到out_of_order queue）。</li>
</ol>
<p>如果 tcp_low_latency 值为 1 时，报文不加入到 prequeue queue，内核软件中断线程直接将数据复制到用户态。</p>
<blockquote>
<p>接收缓存<br>对收消息过程来说，Socket 占用内存量就是 Receive Queue、Prequeue、Backlog、Out of order 队列内排队的 sk_buff(SKB) 占用内存总数。在内核中可以使用两个参数进行配置：net.core.rmem_max 和 net.core.rmem_default。</p>
</blockquote>
<p>最后数据拷贝到用户态之后，表示用户线程已经接到了数据，至此接收流程结束。</p>
<h2 id="4-报文发送"><a href="#4-报文发送" class="headerlink" title="4. 报文发送"></a>4. 报文发送</h2><p>报文接收流程已经讲述完毕，接下来我们再看下报文的接收流程。</p>
<h3 id="4-1-TCP-协议层"><a href="#4-1-TCP-协议层" class="headerlink" title="4.1 TCP 协议层"></a>4.1 TCP 协议层</h3><p>报文发送流程从 TCP 协议层开始，其主要流程如下所示：<br><img src="/images/tcp/tcp-sendmsg.jpg" alt="tcp-sendmsg" title="tcp-sendmsg"></p>
<ol>
<li>用户线程调用 send 方法发送用户态的数据；</li>
<li>sk_stream_wait_memory：判断发送队列是否有足够的空间发送数据，如果没有则等待一定时间，等待已经发送数据的 ACK 确认信息，如果收到则释放 SKB 数据，腾出空间以便后续数据的发送。TCP 连接分配的发送缓存是有限的，可以通过（ /proc/sys/net/core/wmem_default ）进行配置；</li>
<li>tcp_sendmsg ：将用户态的数据按照 MSS ( Maximum Segment Size ) 进行分片，并封装到 SKB 结构中。为了避免数据链路层进行分片，TCP 层传输的数据应小于该层的最大传输单元（MTU）,以太网 MTU 为 1500 字节，扣除 TCP, IP 头的 40 个字节，MSS 最大的值为 1460 字节；</li>
<li>tcp_push ：根据 Nagle 算法，将发送的队列发送到 IP 协议层，这里会受滑动窗口和拥塞窗口的影响。</li>
</ol>
<blockquote>
<p>滑动窗口<br>TCP 连接上的双方都会通知对方自己的接收窗口大小。而对方的接收窗口大小就是自己的发送窗口大小。tcp_push 在发送数据时需要与发送窗口打交道。发送窗口是一个时刻变化的值，随着 ACK 的到达会变大，随着发出新的数据包会变小。当然，最大也只能到三次握手时对方通告的窗口大小。</p>
</blockquote>
<blockquote>
<p>拥塞窗口<br>拥塞窗主要是根据网络的拥塞情况控制报文发送的数量，从而达到改善网络传输的目的。TCP 连接刚建立时，拥塞窗口的大小远小于发送窗口，它实际上是一个 MSS。每收到一个 ACK，拥塞窗口扩大一个 MSS 大小，当然，拥塞窗口最大只能到对方通告的接收窗口大小。当然，为了避免指数式增长，拥塞窗口大小的增长会更慢一些，是线性的平滑的增长过程。所以，在tcp_push发送消息时，还会检查拥塞窗口，飞行中的报文数要小于拥塞窗口个数，而发送数据的长度也要小于拥塞窗口的长度。</p>
</blockquote>
<h3 id="4-2-IP-协议层"><a href="#4-2-IP-协议层" class="headerlink" title="4.2 IP 协议层"></a>4.2 IP 协议层</h3><p>IP 协议层将 IP 转换为 MAC 地址，进行下一跳数据的发送。在发送前，可以对 IP 地址进行重写，重写进行路由，实现 SNAT 功能。<br><img src="/images/tcp/ip_send_skb.jpg" alt="ip_send_skb" title="ip_send_skb"></p>
<p>在发送阶段，同样涉及到 netfilter 钩子函数，包括：</p>
<ol>
<li>NF_INET_LOCAL_OUT ：从本机发出的数据包，在查询路由成功之后，会调用__ip_local_out_sk 函数,首先进行必要字段设置和校验和计算，然后经过 NF_INET_LOCAL_OUT 钩子点，之后会调用 dst_output_sk 继续完成数据包输出的其他工作；</li>
<li>NF_INET_POST_ROUTING ：转发的数据包或者是本地输出的数据包，最后都会经过 ip_output 进行输出，设置设备和协议之后，经过NF_INET_POST_ROUTING 钩子点，之后调用 ip_finish_output 进行后续输出操作，其中包括了分片等</li>
</ol>
<h3 id="4-3-网络子系统"><a href="#4-3-网络子系统" class="headerlink" title="4.3 网络子系统"></a>4.3 网络子系统</h3><p><img src="/images/tcp/dev_queue_xmit.jpg" alt="dev_queue_xmit" title="dev_queue_xmit"></p>
<ol>
<li>dev_queue_xmit：在该函数中，会先获取设备对应的qdisc，如果没有的话（如loopback或者IP tunnels），就直接调用dev_hard_start_xmit，否则数据包将经过 Traffic Control 模块进行处理；</li>
<li>Traffic Control: 进行一些过滤和优先级处理，在这里，如果队列满了的话，数据包会被丢掉；</li>
<li>dev_hard_start_xmit： 该函数中，首先是拷贝一份 SKB 给 “packet taps” ，tcpdump 就是从这里得到数据的，然后调用 ndo_start_xmit。如果 dev_hard_start_xmit 返回错误的话，则触发软件中断 NET_TX_SOFTIRQ，交给软件中断处理程序 net_tx_action 稍后重试。</li>
<li>ndo_start_xmit：会调用驱动中的函数进行数据的发送。</li>
</ol>
<h3 id="4-4-驱动"><a href="#4-4-驱动" class="headerlink" title="4.4 驱动"></a>4.4 驱动</h3><p>ndo_start_xmit 调用驱动中的函数，进行数据的发送，其大概的流程如下：</p>
<ol>
<li>将 SKB 放入网卡自己的发送队列 （环形队列）；</li>
<li>通知网卡发送数据包；</li>
<li>网卡发送完成后发送中断给CPU；</li>
<li>收到中断后进行 SKB 的清理工作。</li>
</ol>
<h2 id="5-其它"><a href="#5-其它" class="headerlink" title="5. 其它"></a>5. 其它</h2><p>在上面的内容中提到每一个 CPU 都会关联一个 softnet_data 类型的数据结构，这个数据结构存放了与网络相关的信息，其结构如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">softnet_data</span></span></span><br><span class="line"><span class="class">&#123;</span>           </span><br><span class="line">    <span class="comment">/*throttle用于拥塞控制,当拥塞时被设置,此后来的数据包都被丢弃*/</span></span><br><span class="line">    <span class="keyword">int</span> throttle;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*netif_rx返回的拥塞级别*/</span></span><br><span class="line">    <span class="keyword">int</span> cng_level;</span><br><span class="line">    <span class="keyword">int</span> avg_blog;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*input_pkt_queue是skb的队列,接收到的skb全都进入到此队列等待后续处理*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff_head</span> <span class="title">input_pkt_queue</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*poll_list是一个双向链表,链表的成员是有接收数据等待处理的device*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">poll_list</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*net_device链表,成员为有数据报要发送的device*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">output_queue</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*完成发送的数据包等待释放的队列*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">completion_queue</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*注意,backlog_dev不是一个指针,而是一个net_device实体,代表了调用net_rx_action时的device*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> <span class="title">backlog_dev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>这篇文章从整体的维度分析了 TCP 接收和发送报文的流程，这个流程只是一个大概且略显粗糙，如果读完这篇文章，能够对 TCP 有一个系统性的理解，目的也就达到了。</p>
<p><strong>参考：</strong></p>
<hr>
<p><a href="https://segmentfault.com/a/1190000008836467" target="_blank" rel="noopener">1. Linux网络 - 数据包的接收过程</a><br><a href="https://segmentfault.com/a/1190000008926093" target="_blank" rel="noopener">2. Linux网络 - 数据包的发送过程</a><br><a href="https://blog.packagecloud.io/eng/2017/02/06/monitoring-tuning-linux-networking-stack-sending-data/" target="_blank" rel="noopener">3. Monitoring and Tuning the Linux Networking Stack: Sending Data</a><br><a href="https://blog.packagecloud.io/eng/2016/10/11/monitoring-tuning-linux-networking-stack-receiving-data-illustrated/" target="_blank" rel="noopener">4. Illustrated Guide to Monitoring and Tuning the Linux Networking Stack: Receiving Data</a><br><a href="https://ylgrgyq.github.io/2017/08/01/linux-receive-packet-3/" target="_blank" rel="noopener">5. Linux 网络协议栈收消息过程-TCP Protocol Layer</a><br><a href="https://ylgrgyq.github.io/2017/07/23/linux-receive-packet-1/" target="_blank" rel="noopener">6. Linux 网络协议栈收消息过程-Ring Buffer</a><br><a href="https://ylgrgyq.github.io/2017/07/24/linux-receive-packet-2/" target="_blank" rel="noopener">7. Linux 网络协议栈收消息过程-Per CPU Backlog</a><br><a href="https://blog.csdn.net/russell_tao/article/details/9950615" target="_blank" rel="noopener">8. 高性能网络编程3—-TCP消息的接收</a><br><a href="https://blog.csdn.net/russell_tao/article/details/9370109" target="_blank" rel="noopener">9. 高性能网络编程2—-TCP消息的发送</a><br><a href="https://blog.csdn.net/cloudvtech/article/details/80182074" target="_blank" rel="noopener">10. 容器云负载均衡之三：RSS、RPS、RFS和XPS调整</a><br><a href="https://blog.51cto.com/enchen/191923" target="_blank" rel="noopener">11. 数据报的接收过程详解</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/09/pointer-determination-and-heap-traversal/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/08/09/pointer-determination-and-heap-traversal/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">垃圾回收之指针判定及堆的遍历</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-08-09 11:03:19" itemprop="dateCreated datePublished" datetime="2020-08-09T11:03:19+08:00">2020-08-09</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-07-31 17:17:10" itemprop="dateModified" datetime="2021-07-31T17:17:10+08:00">2021-07-31</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java基础/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">23k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">21 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p> 在 <a href="https://noahsarkzhang-ts.github.io/2020/07/19/garbage-collecton/" target="_blank" rel="noopener">垃圾回收之回收算法</a> 这篇文章中预设了两个前提：</p>
<ol>
<li>根集合及对象中的指针集合已经得到；</li>
<li>堆是可遍历的，即从一个对象可直接定位到下一个对象；</li>
</ol>
<p> 为了描述的方便，在上篇文章中直接得出了结论，而这篇文章的目的就是解释这两个问题。</p>
<h2 id="1-指针的判定"><a href="#1-指针的判定" class="headerlink" title="1. 指针的判定"></a>1. 指针的判定</h2><p>从位置上来说，可以初步将指针分为两类：1）根上指针，主要包括寄存器、线程栈及全局变量上的指针；2）堆内指针，主要是指堆中对象内指向其它对象的指针，正常来说，根上指针需要运行时才能确定，而堆内指针对于静态类型的语言来说在编译时就可以确定。两者的关系如下图所示：<br><img src="/images/gc/pointer.jpg" alt="pointer" title="pointer"></p>
<p>识别出堆上或根上的数据是否是指针，是垃圾回收的前提，根据识别的程度，可以将垃圾回收分为三类：</p>
<ol>
<li>准确式 GC (precise GC) ：能够识别根上指针和堆内指针，明确数据是否是指针类型；</li>
<li>半保守式 GC ：也叫根上保守，它能识别堆内指针，但不能识别根上指针；</li>
<li>保守式GC（conservative GC）: 不能完全识别指针类型，它根据一些规则来排除不是指针，这些规则包含上下边界检查（GC堆的上下界是已知的）、对齐检查（通常分配空间的时候会有对齐要求，假如说是4字节对齐，那么不能被4整除的数字就肯定不是指针）。</li>
</ol>
<h3 id="1-1-堆内指针的判定"><a href="#1-1-堆内指针的判定" class="headerlink" title="1.1 堆内指针的判定"></a>1.1 堆内指针的判定</h3><p>要识别出堆内的指针，一般要求对象上记录对象的类型信息，在扫描堆的时候，可以根据类型信息，来判断对象中的数据是否是指针类型。如果是JVM的话，这些数据可能在类加载器或者对象模型的模块里计算得到，不需要编译器的支持。</p>
<h3 id="1-2-根上指针的判定"><a href="#1-2-根上指针的判定" class="headerlink" title="1.2 根上指针的判定"></a>1.2 根上指针的判定</h3><p>根上的数据，如寄存器和线程栈，是运行时产生的数据，与堆内指针的判定方法不一样，以 JVM 为例，一般有以下几个方法：</p>
<ol>
<li>让数据自身带上标记（tag）；</li>
<li>让编译器为每个方法生成特别的扫描代码；</li>
<li>从外部记录下类型信息，存成映射表。现在三种主流的高性能 JVM 实现，HotSpot、JRockit 和 J9 都是这样做的。其中，HotSpot把这样的数据结构叫做OopMap，JRockit 里叫做livemap，J9 里叫做GC map。Apache Harmony的 DRLVM 也把它叫 GCMap。</li>
</ol>
<p>JVM 中指令的执行会影响寄存器和线程栈中的数据，要实现映射表，需要 JVM 的解释器和 JIT 编译器都有相应的支持，由它们来生成足够的元数据（类型）提供给垃圾回收器。在HotSpot中，如果 JVM 以解释的方式运行代码，映射表（OopMap）可以由解释器来收集；如果使用 JIT 编译器编译后的代码，则需要在一些关键点插入代码来记录映射表（OopMap）。这些关键点也叫做“安全点”（safepoint），之所以要选择一些特定的位置来记录OopMap，是因为如果对每条指令（的位置）都记录 OopMap 的话，这些记录就会比较大，那么空间开销会显得不值得。选用一些比较关键的点来记录就能有效的缩小记录的数据量，这些关键点包括：</p>
<ol>
<li>循环的末尾；</li>
<li>方法临返回前 / 调用方法的call指令后；</li>
<li>可能抛异常的位置。</li>
</ol>
<p>所以说，垃圾回收不是在任意位置都可以进入，只能在 safepoint 处进入。</p>
<p>平时这些 OopMap 都是压缩存在内存里，在垃圾回收的时候才按需解压出来使用，一般有两种使用方式：</p>
<ol>
<li>每次都遍历原始的OopMap，循环的一个个偏移量扫描过去；这种用法也叫“解释式”；</li>
<li>为每个 OopMap生成一块定制的扫描代码，以后每次要用 OopMap 就直接执行生成的扫描代码；这种用法也叫“编译式”。</li>
</ol>
<p>HotSpot 是用“解释式”的方式来使用 OopMap 的，每次都循环变量里面的项来扫描对应的偏移量。</p>
<h3 id="1-3-OopMap"><a href="#1-3-OopMap" class="headerlink" title="1.3 OopMap"></a>1.3 OopMap</h3><p>在 HotSpot 中，对象的类型信息里有记录自己的 OopMap，记录了在该类型的对象内什么偏移量上是什么类型的数据。所以从对象开始向外的扫描可以是准确的，这些数据是在类加载过程中计算得到的。另外，在“安全点”中记录了根上数据类型及偏移量，保证了根上的数据类型也是准确的，通过这两种方法，HotSpot 实现了准确式 GC 。现在我们来看下，在 JVM 中 OopMap 相关的信息。</p>
<blockquote>
<p>Oop maps are bit maps specifying which stack and register locations hold oops for a given pc. During GC, these locations need to be visited since they represent roots for GC. Also, if GC moves objects, pointers must be updated.</p>
</blockquote>
<h4 id="1-3-1-根集合上关联的OopMap"><a href="#1-3-1-根集合上关联的OopMap" class="headerlink" title="1.3.1 根集合上关联的OopMap"></a>1.3.1 根集合上关联的OopMap</h4><p>如果 JVM 使用翻译器，则在翻译器中收集 OopMap 中，如果使用 JIT 编译器，则在指定位置插入特定的代码收集 OopMap，我们以下面的代码为例，反汇编代码，分析 OopMap相关的结构。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DisAssemblyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String name = <span class="string">"test"</span>;</span><br><span class="line">        String newName = name.intern();</span><br><span class="line">        System.out.println(name == newName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> DisAssemblyTest().invoke();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用如下参数，运行代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -Xcomp </span><br><span class="line">-XX:CompileCommand=dontinline,*DisAssemblyTest.invoke </span><br><span class="line">-XX:CompileCommand=compileonly,*DisAssemblyTest.invoke</span><br></pre></td></tr></table></figure></p>
<p>反汇编的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">[Entry Point]</span><br><span class="line">[Constants]</span><br><span class="line">  # &#123;method&#125; &#123;0x0000000057252b68&#125; &apos;invoke&apos; &apos;()V&apos; in &apos;org/noahsrak/jvm/DisAssemblyTest&apos;</span><br><span class="line">  #           [sp+0x40]  (sp of caller)</span><br><span class="line">  0x000000000296baa0: mov    0x8(%rdx),%r10d</span><br><span class="line">  0x000000000296baa4: cmp    %rax,%r10</span><br><span class="line">  ...</span><br><span class="line">[Verified Entry Point]</span><br><span class="line">  0x000000000296bac0: mov    %eax,-0x6000(%rsp)</span><br><span class="line">  ...</span><br><span class="line">  0x000000000296bb9f: callq  0x00000000028a61a0  ; OopMap&#123;[32]=Oop off=260&#125;</span><br><span class="line">                                                ;*invokevirtual intern</span><br><span class="line">                                                ; - org.noahsrak.jvm.DisAssemblyTest::invoke@4 (line 12)</span><br><span class="line">                                                ;   &#123;optimized virtual_call&#125;</span><br><span class="line">  0x000000000296bba4: nopl   0x0(%rax)</span><br><span class="line">  0x000000000296bba8: jmpq   0x000000000296bd3c  ;   &#123;no_reloc&#125;</span><br><span class="line">  0x000000000296bbad: add    %al,(%rax)</span><br><span class="line">  0x000000000296bbaf: add    %al,(%rax)</span><br><span class="line">  0x000000000296bbb1: add    %ah,0xf(%rsi)</span><br><span class="line">  ...</span><br><span class="line">  0x000000000296bcb5: movabs $0xffffffffffffffff,%rax</span><br><span class="line">  0x000000000296bcbf: callq  0x00000000028a63e0  ; OopMap&#123;off=548&#125;</span><br><span class="line">                                                ;*invokevirtual println</span><br><span class="line">                                                ; - org.noahsrak.jvm.DisAssemblyTest::invoke@21 (line 13)</span><br><span class="line">                                                ;   &#123;virtual_call&#125;</span><br><span class="line">  0x000000000296bcc4: add    $0x30,%rsp</span><br><span class="line">  0x000000000296bcc8: pop    %rbp</span><br><span class="line">  0x000000000296bcc9: test   %eax,-0x253bbcf(%rip)        # 0x0000000000430100</span><br><span class="line">                                                ;   &#123;poll_return&#125;</span><br><span class="line">  0x000000000296bccf: retq   </span><br><span class="line">  0x000000000296bcd0: mov    %rsi,0x8(%rsp)</span><br><span class="line">  0x000000000296bcd5: movq   $0xffffffffffffffff,(%rsp)</span><br><span class="line">  0x000000000296bcdd: callq  0x000000000296a460  ; OopMap&#123;rdx=Oop off=578&#125;</span><br><span class="line">                                                ;*synchronization entry</span><br><span class="line">                                                ; - org.noahsrak.jvm.DisAssemblyTest::invoke@-1 (line 11)</span><br><span class="line">                                                ;   &#123;runtime_call&#125;</span><br><span class="line">  0x000000000296bce2: jmpq   0x000000000296bafb</span><br><span class="line">  0x000000000296bce7: movabs $0x0,%r8           ;   &#123;oop(NULL)&#125;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></p>
<p>这段输出含有一条callq指令，用来实现对intern()方法的调用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OopMap&#123;[<span class="number">32</span>]=Oop off=<span class="number">260</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>它的含义是：有一个OopMap与这条callq指令之后的一条指令（nopl）关联在一起，该指令位置上有一个活跃的引用，在离栈顶偏移量为32的位置上。</p>
<p>OopMap记录输出的日志的构成是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OopMap&#123;零到多个“数据位置=内容类型”的记录 off=该OopMap关联的指令的位置&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，[32]表示栈顶指针+偏移量0，这里就是[rsp + 32]，也就是栈顶偏移量为32的位置；右边的”=Oop”说明这个位置存着一个普通对象指针（ordinary object pointer，HotSpot 将指向GC堆中对象开头位置的指针称为Oop）</p>
<p>off=260 就是这个 OopMap 记录关联的指令在方法的指令流中的偏移量，这个数字是十进制的。可以看到，该方法的指令流是从地址0x000000000296baa0开始的；十进制的260就是十六进制的0x104；<code>0x000000000296baa0 + 0x104 = 0x000000000296bba4</code>，正好就是例子中callq指令后的<code>nopl   0x0(%rax)</code>所在的位置。</p>
<h4 id="1-3-2-对象上关联的OopMap"><a href="#1-3-2-对象上关联的OopMap" class="headerlink" title="1.3.2 对象上关联的OopMap"></a>1.3.2 对象上关联的OopMap</h4><p>除了在根集合上收集 OopMap，在对象上也会关联 OopMap，用来描述对象中字段的引用信息，对象中的 OopMap 存放在对象的类信息中，在类进行加载的时候进行初始化。分析 OopMap 之前，我们先了解下 java 中对象与类的关系。<br><img src="/images/gc/klass.png" alt="klass" title="klass"></p>
<p>HotSpot中采用了 OOP-Klass 模型来描述 Java 对象与类的关系：</p>
<ol>
<li>OOP 或 OOPS （Ordinary Object Pointer）指的是普通对象指针，主要职能是表示对象的实例数据，存储在堆里面；</li>
<li>Klass 用来描述对象实例的具体类型，实现语言层面的 Java 的 Class 对象，在 JVM 中用 Klass 表示，存储在元空间（方法区）。</li>
</ol>
<p>在 Java 中，每创建一个 Java 对象，在 JVM 内部也会相应创建一个 OOP 对象来表示 Java 对象。OOP类的共同基类型是oopDesc，它有多个子类，instanceOopDesc 表示对象，arrayOopDesc 表示数组。</p>
<p>其中，instanceOopDesc 和 arrayOopDesc 又称为对象头，instanceOopDesc 对象头包括以下两部分信息：Mark Word 和 元数据指针(Klass*)：</p>
<ol>
<li>Mark Word，主要存储对象运行时记录信息，如hashcode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等;</li>
<li>元数据指针，用来存储 klass 指针，对应的klass 指针指向一个存储类的元数据的 Klass 对象。</li>
</ol>
<p>instanceOopDesc 用于表示 Java 对象，instanceKlass 用于描述 instanceOopDesc，instanceKlassKlass 用来描述 instanceKlass，为了避免无限描述下去，所以有个klassKlass作为这个描述链上的终结符。</p>
<p>对象中的 OopMap 就是在 Klass 对象中存放，其布局如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">InstanceKlass layout:</span><br><span class="line">  [C++ vtbl pointer           ] Klass</span><br><span class="line">  [subtype cache              ] Klass</span><br><span class="line">  [instance <span class="built_in">size</span>              ] Klass</span><br><span class="line">  [java mirror                ] Klass</span><br><span class="line">  [super                      ] Klass</span><br><span class="line">  [access_flags               ] Klass</span><br><span class="line">  [name                       ] Klass</span><br><span class="line">  [first subklass             ] Klass</span><br><span class="line">  [next sibling               ] Klass</span><br><span class="line">  [<span class="built_in">array</span> klasses              ]</span><br><span class="line">  [methods                    ]</span><br><span class="line">  [local interfaces           ]</span><br><span class="line">  [transitive interfaces      ]</span><br><span class="line">  [fields                     ]</span><br><span class="line">  [constants                  ]</span><br><span class="line">  [<span class="class"><span class="keyword">class</span> <span class="title">loader</span>               ]</span></span><br><span class="line"><span class="class">  [<span class="title">source</span> <span class="title">file</span> <span class="title">name</span>           ]</span></span><br><span class="line"><span class="class">  [<span class="title">inner</span> <span class="title">classes</span>              ]</span></span><br><span class="line"><span class="class">  [<span class="title">static</span> <span class="title">field</span> <span class="title">size</span>          ]</span></span><br><span class="line"><span class="class">  [<span class="title">nonstatic</span> <span class="title">field</span> <span class="title">size</span>       ]</span></span><br><span class="line"><span class="class">  [<span class="title">static</span> <span class="title">oop</span> <span class="title">fields</span> <span class="title">size</span>     ]</span></span><br><span class="line"><span class="class">  [<span class="title">nonstatic</span> <span class="title">oop</span> <span class="title">maps</span> <span class="title">size</span>    ]</span></span><br><span class="line"><span class="class">  [<span class="title">has</span> <span class="title">finalize</span> <span class="title">method</span>        ]</span></span><br><span class="line"><span class="class">  [<span class="title">deoptimization</span> <span class="title">mark</span> <span class="title">bit</span>    ]</span></span><br><span class="line"><span class="class">  [<span class="title">initialization</span> <span class="title">state</span>       ]</span></span><br><span class="line"><span class="class">  [<span class="title">initializing</span> <span class="title">thread</span>        ]</span></span><br><span class="line"><span class="class">  [<span class="title">Java</span> <span class="title">vtable</span> <span class="title">length</span>         ]</span></span><br><span class="line"><span class="class">  [<span class="title">oop</span> <span class="title">map</span> <span class="title">cache</span> (<span class="title">stack</span> <span class="title">maps</span>) ]</span></span><br><span class="line"><span class="class">  [<span class="title">EMBEDDED</span> <span class="title">Java</span> <span class="title">vtable</span>             ] <span class="title">size</span> <span class="title">in</span> <span class="title">words</span> = <span class="title">vtable_len</span></span></span><br><span class="line"><span class="class">  [<span class="title">EMBEDDED</span> <span class="title">nonstatic</span> <span class="title">oop</span>-<span class="title">map</span> <span class="title">blocks</span>] <span class="title">size</span> <span class="title">in</span> <span class="title">words</span> = <span class="title">nonstatic_oop_map_size</span></span></span><br><span class="line"><span class="class">    <span class="title">The</span> <span class="title">embedded</span> <span class="title">nonstatic</span> <span class="title">oop</span>-<span class="title">map</span> <span class="title">blocks</span> <span class="title">are</span> <span class="title">short</span> <span class="title">pairs</span> (<span class="title">offset</span>, <span class="title">length</span>)</span></span><br><span class="line"><span class="class">    <span class="title">indicating</span> <span class="title">where</span> <span class="title">oops</span> <span class="title">are</span> <span class="title">located</span> <span class="title">in</span> <span class="title">instances</span> <span class="title">of</span> <span class="title">this</span> <span class="title">klass</span>.</span></span><br><span class="line"><span class="class">  [<span class="title">EMBEDDED</span> <span class="title">implementor</span> <span class="title">of</span> <span class="title">the</span> <span class="title">interface</span>] <span class="title">only</span> <span class="title">exist</span> <span class="title">for</span> <span class="title">interface</span></span></span><br><span class="line"><span class="class">  [<span class="title">EMBEDDED</span> <span class="title">host</span> <span class="title">klass</span>        ] <span class="title">only</span> <span class="title">exist</span> <span class="title">for</span> <span class="title">an</span> <span class="title">anonymous</span> <span class="title">class</span> (<span class="title">JSR</span> 292 <span class="title">enabled</span>)</span></span><br></pre></td></tr></table></figure></p>
<p>在上面的布局中可以看到有一个 oop map cache 的字段，猜测就是用来存放 OopMap相关的信息。</p>
<h4 id="1-3-3-小结"><a href="#1-3-3-小结" class="headerlink" title="1.3.3 小结"></a>1.3.3 小结</h4><p>用一句话来描述，OopMap 存放了堆、栈及寄存器上指针信息，借助 OopMap 不仅可以准确判定一个数值是否是指针，同时直接扫描 OopMap 集合可以加快标记的速度，从而提高垃圾回收的效率。</p>
<h2 id="2-堆的遍历"><a href="#2-堆的遍历" class="headerlink" title="2. 堆的遍历"></a>2. 堆的遍历</h2><h3 id="2-1-内存分配"><a href="#2-1-内存分配" class="headerlink" title="2.1 内存分配"></a>2.1 内存分配</h3><p>在垃圾回收算法中，需要对堆进行清除及整理操作，这时候就需要对堆从头到尾进行遍历，遍历的方式跟内存的分配方式极为相关，我们先介绍内存的分配方式。内存的分配方式有两种基本的分配策略：1）顺序分配；2）空闲链表分配。</p>
<ol>
<li><p>顺序分配<br>顺序分配使用一个较大的空闲内存块，从一端根据大小顺序分配，它的数据结构比较简单，只需要一个空闲指针（free pointer）和一个界限指针（limit pointer）。根据分配的内存块大小，只要简单移动空闲指针即可。如果存在字节对齐要求，则可能需要额外增加填充字节，分配的逻辑如下图所示：<br><img src="/images/gc/sequence-allocation.jpg" alt="sequence-allocation" title="sequence-allocation"><br>顺序分配的特点是简单、高效，适用于大块内存及内存比较规整的情况下，可以在复制回收及标记整理算法中使用。使用顺序分配的堆中，要实现堆的遍历，每一个分配的内存块需要包含一个头部，描述内存块的信息，如块的大小等等。</p>
</li>
<li><p>空闲链表分配<br>空闲链表使用某种数据结构来记录空闲内存单元（free cell）的位置和大小，该数据结构将所有的空闲内存块串联起来进行统一分配。严格来讲，空闲内存单元的组织方式不一定是链表，也可以采用其它形式。下面是使用双向空闲链表的结构：<br><img src="/images/gc/linklist-allocation.jpg" alt="linklist-allocation" title="linklist-allocation"><br>内存块中都会有一个头部，表明块的大小及是否已分配。另外在每一个空闲块中，都会包含一个pred（前驱）和succ（后继）指针，从而可以对空闲块进行双向遍历。<br>在需要分配内存时，分配器顺序检测每一个空闲内存单元，依照某种策略选择一个并从中进行分配。其算法实现通常是顺序扫描所有空闲内存单元，直到发现第一个符合条件的内存单元为止，因而也叫做顺序适应分配。典型的算法包括首次适应（first-fit）、循环首次适配（next-fit）、最佳适应（best-fit）。<br><strong>1) 首次适应分配</strong><br>对于一次内存分配请求，首次适应分配器将在所发现的第一个满足分配要求的内存单元中进行分配。如果该内存单元的空间大于所需的空间，则会进行分裂操作，将剩余的空间归还到空闲链表中。<br><strong>2) 循环首次适应分配</strong><br>循环首次适应分配是首次适应分配算法的一个变种。在分配内存时，该算法不是每次都从空闲链表头部开始查找，而是从上次成功分配的位置开始。该算法可以有效避免对空闲链表前端较小空间内存单元的遍历。<br><strong>3) 最佳适应分配</strong><br>最佳适应分配是指在空闲链表中找到满足分配要求且空间最小的空闲内存单元，其目的在于减少空间浪费，同时避免不必要的内存单元分裂。</p>
</li>
</ol>
<p>使用空闲链表分配的堆内存，进行堆的遍历相对比较容易，根据内存单元的头部信息可以快速定位到下一个内存单元。</p>
<h3 id="2-2-JVM内存分配"><a href="#2-2-JVM内存分配" class="headerlink" title="2.2 JVM内存分配"></a>2.2 JVM内存分配</h3><h4 id="2-2-1-Java对象布局"><a href="#2-2-1-Java对象布局" class="headerlink" title="2.2.1 Java对象布局"></a>2.2.1 Java对象布局</h4><p>在分析 JVM 内存分配之前，先要理解一个 Java 对象在内存中的布局，Java 对象的布局如下所示：<br><img src="/images/gc/object-layout.jpg" alt="object-layout" title="object-layout"><br>一个Java对象在内存中包括对象头、实例数据和对齐填充3个部分：<br>1、对象头<br>Mark Word：用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，在32位系统占4字节，在64位系统中占8字节；<br>klass：用来指向对象对应的 Klass 对象（其对应的元数据对象）的内存地址，在32位系统占4字节，在64位系统中占8字节；<br>Length：如果是数组对象，还有一个保存数组长度的空间，占4个字节；<br>2、实例数据<br>存储对象各字段的内容。<br>3、对齐填充<br>HotSpot 要求对象起始地址必须是8字节的整数，即对象的大小必须是8字节的整数倍。当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p>
<p>Klass指针指向的元数据对象就是我们上节讲到的InstanceKlass，它存有对象描述信息及OopMap，在垃圾回收算法中起到比较关键的作用。</p>
<h4 id="2-2-2-内存分配"><a href="#2-2-2-内存分配" class="headerlink" title="2.2.2 内存分配"></a>2.2.2 内存分配</h4><p>在 JVM 中要分配一个对象，有两种分配方式：1）指针碰撞；2）空闲列表。这两种方式跟我们在上面讲的分配方式是类似的，可以认为这两种方式是其具体的实现。<br>1、指针碰撞<br><img src="/images/gc/bump-the-pointer.jpg" alt="bump-the-pointer" title="bump-the-pointer"></p>
<p>使用该算法，直接根据分配对象的大小，移动空闲指针即可。在对象头中存放了对象元数据对象的指针，可以方便得到对象的大小，进而定位到下一个对象的位置，实现堆的遍历。</p>
<p>2、空闲列表<br><img src="/images/gc/free-list-before.jpg" alt="free-list-before" title="free-list-before"><br>使用空闲列表算法，已分配的内存块和释放的内存块互相间隔，在遍历堆的时候需要跳过释放的内存块或未分配的内存块，一种可选的做法是用一个“填充对象”覆盖释放的内存块，如下图所示：<br><img src="/images/gc/free-list-after.jpg" alt="free-list-after" title="free-list-after"><br>当释放一个对象时，回收器使用一个“填充对象”覆盖其空间，而“填充对象”内部包含一个表示自身大小的域（可以当作一个字节数组），清扫器（标记-清扫算法）可以据此快速跳过空闲内存单元并找到下一个真正的对象。</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>在这篇文章里，我们分析了垃圾回收中的两个问题：1）指针的判定；2）堆的遍历。在 JVM 中通过维护 OopMap 解决了指针的判定，同时通过对象对象头记录的元数据，可以方便定位对象的位置，从而解决对象的遍历。</p>
<p><strong>参考：</strong></p>
<hr>
<p><a href="https://www.iteye.com/blog/rednaxelafx-1044951" target="_blank" rel="noopener">1. 找出栈上的指针/引用</a><br><a href="https://book.douban.com/subject/26740958/" target="_blank" rel="noopener">2. 垃圾回收算法手册——自动内存管理的艺术</a><br><a href="https://book.douban.com/subject/26912767/" target="_blank" rel="noopener">3. 深入理解计算机系统</a><br><a href="https://www.iteye.com/blog/rednaxelafx-730461" target="_blank" rel="noopener">4. 借助HotSpot SA来一窥PermGen上的对象</a><br><a href="https://blog.csdn.net/jyxmust/article/details/88255594" target="_blank" rel="noopener">5. 浅谈JVM OOP-Klass二分模型</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/02/deep-understanding-of-high-concurrency/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/08/02/deep-understanding-of-high-concurrency/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">思维导图-高并发</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-08-02 15:28:15" itemprop="dateCreated datePublished" datetime="2020-08-02T15:28:15+08:00">2020-08-02</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-07-31 17:17:10" itemprop="dateModified" datetime="2021-07-31T17:17:10+08:00">2021-07-31</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/思维导图/" itemprop="url" rel="index"><span itemprop="name">思维导图</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">304</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">1 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇文章是对《高并发，你真的理解透彻了吗？》的记录及整理。</p>
<p><img src="/images/high-concurrency/high-concurrency.jpeg" alt="high-concurrency" title="high-concurrency"></p>
<p><strong>参考：</strong></p>
<hr>
<p><a href="https://mp.weixin.qq.com/s/lc0a8eIRL94gqeb9R1kQzg" target="_blank" rel="noopener">1. 高并发，你真的理解透彻了吗？</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/19/garbage-collecton/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/07/19/garbage-collecton/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">垃圾回收之回收算法</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-07-19 16:57:52" itemprop="dateCreated datePublished" datetime="2020-07-19T16:57:52+08:00">2020-07-19</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-07-31 17:17:10" itemprop="dateModified" datetime="2021-07-31T17:17:10+08:00">2021-07-31</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java基础/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">37k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">34 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>几乎所有的现代编程语言都使用动态内存分配，即允许进程在运行时分配或释放无法在编译期确定大小的对象，这些对象的存活时间有可能超出创建者的生存周期。动态分配的对象存在于堆（heap）中而不是栈（stack）或者静态区（statically）中。在内存的管理方式上，有两种方式：1）显示内存释放，由开发人员显示的创建或释放对象；2）自动动态内存管理，由编程语言的运行时系统（虚拟机）负责内存的回收。自动动态内存管理可以显著地降低开发成本，提供程序的健壮性。我们这篇文章主要便是讲述内存管理中常用垃圾回收算法，并结合 java来分析内部的实现。</p>
<p>垃圾回收的目的是回收程序不再使用的对象所占用的空间，任何具备自动内存管理系统的语言都要有三个功能：</p>
<ol>
<li>为新对象分配空间；</li>
<li>确定存活对象；</li>
<li>回收死亡对象所占用的空间。</li>
</ol>
<p>内存分配与回收是相关性比较强的两个功能，内存管理系统都要具备这两个功能；在实现中，使用指针的可达性来近似对象的存活：只有当堆中存在一条从根出发的指针链能最终到达某个对象时，才能认定该对象存活，更进一步，如果不存在这一条指针链，则认为对象死亡，其空间可以得到回收。回收死亡对象包括两种方式：1）直接释放该对象，有可能会与前后的空闲对象进行合并；2）将存活对象进行移动或整理，减少内存碎片的问题。</p>
<h2 id="1-标记-清扫"><a href="#1-标记-清扫" class="headerlink" title="1. 标记 - 清扫"></a>1. 标记 - 清扫</h2><p>标记 - 清除算法分为两个阶段：1）追踪（trace）阶段，即回收器（回收程序）从根集合（寄存器、线程栈、全局变量）开始遍历对象图，并标记（mark）所遇到的每一个对象；2）清扫（sweep）阶段，即回收器检查堆中每一个对象，并将所有未标记的对象当作垃圾进行回收。其算法如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">New():  // 新建对象</span><br><span class="line">    ref = allocate()</span><br><span class="line">    if ref == null    // 堆中没有可用空间</span><br><span class="line">        collect()     // 进行一次内存回收</span><br><span class="line">        ref = allocate()</span><br><span class="line">        if ref == null // 堆中仍然没有可用空间</span><br><span class="line">            error &quot;Out of memory&quot;</span><br><span class="line"></span><br><span class="line">collect():  // 回收对象</span><br><span class="line">    markFromRoots()</span><br><span class="line">    sweep(HeapStart, HeapEnd)</span><br></pre></td></tr></table></figure>
<p>在新建对象的方法中，会给对象分配一块内存空间，如果堆中没有足够的可用空间，会进行一次内存回收，回收之后再分配一次内存，如果堆中仍然没有足够的可用空间，则抛出错误。<br>在回收对象的方法中，会从根集合开始，对存活的对象进行标记，然后遍历整个堆，对未标记的对象执行回收操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">markFromRoots():</span><br><span class="line">    initialise(worklist)</span><br><span class="line">    for each fld in Roots</span><br><span class="line">        ref = *fld</span><br><span class="line">        if ref != null &amp;&amp; not isMarked(ref)</span><br><span class="line">            setMarked(ref)</span><br><span class="line">            add(wokrklist,ref)</span><br><span class="line">            mark()</span><br><span class="line"></span><br><span class="line">initialise(worklist) </span><br><span class="line">    worklist = empty</span><br><span class="line"></span><br><span class="line">mark():</span><br><span class="line">    while not isEmpty(worklist)</span><br><span class="line">        ref = remove(worklist)</span><br><span class="line">        for each fld in (Pointers(ref))</span><br><span class="line">            child = *fld</span><br><span class="line">            if ref != null &amp;&amp; not isMarked(ref)</span><br><span class="line">                setMarked(child)</span><br><span class="line">                add(worklist,child)</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong><br>1) Roots：表示根集合，包含指针扫描的起点，主要是指寄存器、线程栈和全局变量；<br>2）Pointers(ref)：表示ref指针指向的对象中包含的指针集合；</p>
<p><strong>如何得到根集合和对象中的指针集合，我们会在后面的文章再讲解，现在假定我们已经知道这些值。</strong></p>
<p>我们可以将堆看作是一个图的结构，对象是结点，结点间的指针（引用）是边，根便是图的起始结点。对堆对象进行标记就是对对象图进行遍历操作，在上面的算法中使用的深度优先遍历算法。在算法中使用栈来实现工作列表，先从根结点开始，将标记过的对象放入工作列表中，然后取出对象对其所指向的对象进行标记，直到工作列表为空。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sweep(start,end):</span><br><span class="line">    scan = start</span><br><span class="line">    while scan &lt; end</span><br><span class="line">        if (isMarked(scan))</span><br><span class="line">            unsetMarked(scan)</span><br><span class="line">        else </span><br><span class="line">            free(scan)</span><br><span class="line">        scan = nextObject(scan)</span><br></pre></td></tr></table></figure>
<p>清除操作将堆中的所有对象看作一个对象列表，可以从堆的起始地址遍历所有对象，如果对象被标记则取消标记，进行下一轮的回收，如果未标记，则说明是一个死对象，则进行回收，回收的策略取决于具体的实现。如何对堆中的对象进行遍历，我们将在后面的文章进行讲解。一个完整的标记-清扫算法如下所示：<br><img src="/images/mark-sweep.gif" alt="mark-sweep" title="mark-sweep"></p>
<h3 id="1-1-三色遍历"><a href="#1-1-三色遍历" class="headerlink" title="1.1 三色遍历"></a>1.1 三色遍历</h3><p>标记的核心操作之一就是从给定的根集合出发去遍历对象图。遍历它有两种典型顺序：深度优先（DFS）和广度优先（BFS）。</p>
<p>广度优先遍历的典型实现思路是三色遍历：给对象赋予白、灰、黑三种颜色以标记其遍历状态：<br>1）白色：未遍历到的对象，所有对象的初始状态都是白色；<br>2）灰色：已遍历到但还未处理完的对象，即还有出边没有遍历；<br>3）黑色：已遍历完的对象，所有出边已经遍历。</p>
<p><img src="/images/tricolour-abstraction.gif" alt="tricolour-abstraction" title="tricolour-abstraction"></p>
<p>算法的步骤如下：<br>1）算法开始，所有的对象标记为白色；<br>2）从根集合开始，将引用到的对象标记为灰色；<br>3）从灰色集合中取出对象，遍历其所有出边，将遍历到的对象标记为灰色，遍历结束，将该对象标记为黑色；<br>4）重复第三步，直到没有灰色对象，最后未被遍历到白色对象即为死亡对象。</p>
<h2 id="2-标记-整理"><a href="#2-标记-整理" class="headerlink" title="2. 标记 - 整理"></a>2. 标记 - 整理</h2><p>标记-清扫算法只是对不再存活的对象进行释放，不会对存活的对象进行移动，这会造成碎片的问题，即使可用内存大于对象分配所需的内存，由于这些内存不是连续的，最终会导致分配失败。为了解决这个问题，引入了标记-整理算法。该算法在标记-清除算法的基础上，会将存活的对象统一移动到某一端，让它们连续存储在一起，从而得到较大的可用内存。根据移动前后的位置，有三种移动的顺序：</p>
<ol>
<li>任意顺序：对象的移动顺序与它们的原始排列顺序和引用没有关系；</li>
<li>线性顺序：将具有关联关系的对象排列在一一起，如对象之间的引用关系或同一个数据结构中相邻的对象；</li>
<li>滑动顺序：将对象滑动到堆的一端，保持对象在堆中原有的分配顺序。</li>
</ol>
<p>这里会分别介绍四种整理算法：1）双指针整理算法；2）Lisp 2算法；3）引线整理算法；4）单次遍历算法。其中除了双指针整理算法是按照任意顺序移动对象，其它算法都是滑动顺序。所有的整理算法都遵循下面的范式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">collect():</span><br><span class="line">    markFromRoots();</span><br><span class="line">    compact()</span><br></pre></td></tr></table></figure></p>
<h3 id="2-1-双指针整理算法"><a href="#2-1-双指针整理算法" class="headerlink" title="2.1 双指针整理算法"></a>2.1 双指针整理算法</h3><p>双指针整理算法需要遍历两次堆，适用于只包含固定大小对象的区域。该算法流程如下：</p>
<ol>
<li>计算出“高水位标记”，地址大于该阈值的存活对象都被移动该阈值之下；</li>
<li>设置两个指针，free 指针指向区域始端，scan 指针指向区域末端；</li>
<li>第一次遍历，free 指针向后移动，找到空闲区域为止，scan 指针向前移动，找到存活对象为止；</li>
<li>将 scan 指针指向的存活对象移动到 free 指向的空闲区域，并将scan对象中的“转发指针”设置为 free ，方便下次做指针的更新；</li>
<li>重新移动 free 及 scan 指针，直到 free &gt; scan 为止；</li>
<li>第二次遍历，更新指针存活对象中的指针，如果指针指向的地址中存在“转发指针”则直接更新该转发地址，算法结束。</li>
</ol>
<p>算法过程如下所示：<br><img src="/images/gc/two-points-init.jpg" alt="two-points-init" title="two-points-init"><br>初始状态下:1）有A, B, C, D 4个存活对象，其中 C 对象中有两个指针分别指向 A 和 B 两个对象。</p>
<p><img src="/images/gc/two-points-first.jpg" alt="two-points-first" title="two-points-first"><br>第一次遍历，将 A 和 B 两个对象移动到低地址区域，同时将移动后的地址写入到之前的对象中。</p>
<p><img src="/images/gc/two-points-second.jpg" alt="two-points-second" title="two-points-second"><br>第二次遍历，根据“转移地址”更新 C 对象中的 A 和 B 两个指针。</p>
<p>在双指针整理算法中，移动前后的存储对象的空闲空间大小最好是相等的，否则寻找匹配大小的空闲空间需要来回移动free指针，这样会降低算法的执行效率，另外，在该算法中，移动的顺序是任意的，会破坏赋值操作的局部性。</p>
<p>整理算法的伪代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">compact():</span><br><span class="line">    relocate(HeapStart, HeapEnd)</span><br><span class="line">    updateReferences(HeapStart, free)</span><br><span class="line"></span><br><span class="line">relocate(start, end):</span><br><span class="line">    free = start</span><br><span class="line">    scan = end</span><br><span class="line"></span><br><span class="line">    while free &lt; scan</span><br><span class="line">        while isMarked(free)</span><br><span class="line">            unsetMarked(free)</span><br><span class="line">            free = free + size(free)    /* 寻找下一个空闲块 */</span><br><span class="line">        </span><br><span class="line">        while not isMarked(scan) &amp;&amp; scan &gt; free</span><br><span class="line">            scan = scan - size(scan)    /* 寻找前一个存活对象 */</span><br><span class="line">        </span><br><span class="line">        if scan &gt; free</span><br><span class="line">            unsetMarked(scan)</span><br><span class="line">            move(scan, free)</span><br><span class="line">            *scan = free    /* 记录转发地址 */</span><br><span class="line">            free = free + size(free)</span><br><span class="line">            scan = scan - size(scan)</span><br><span class="line"></span><br><span class="line">updateReferences(start, end):</span><br><span class="line">    for each fld in Roots   /* 更新指向被移动对象的根 */</span><br><span class="line">        ref = *fld</span><br><span class="line">        if ref &gt;= end</span><br><span class="line">            *fld = *ref     /* 更新转发地址 */</span><br><span class="line">    </span><br><span class="line">    scan = start</span><br><span class="line">    while scan &lt; end</span><br><span class="line">        for each fld in Pointers(scan)</span><br><span class="line">            ref = *fld</span><br><span class="line">            if ref &gt;= end</span><br><span class="line">                *fld = *ref     /* 更新转发地址 */</span><br><span class="line">        scan = scan + size(scan)    /* 下一个对象 */</span><br></pre></td></tr></table></figure></p>
<h3 id="2-2-Lisp-2-算法"><a href="#2-2-Lisp-2-算法" class="headerlink" title="2.2 Lisp 2 算法"></a>2.2 Lisp 2 算法</h3><p>Lisp 2 算法对管理的对象大小没有限制，它可以管理包含多种大小对象的空间，同时移动的时候采用滑动顺序，不会改变对象的相对顺序。不过整理的过程需要遍历三次堆，算法的流程如下：</p>
<ol>
<li>第一次遍历：计算移动的位置。假定需要整理的内存区域起始地址、结束地址分别为 heapStart 、heapEnd，移动后的内存区域起始地址为toRegion，其中 heapStart 和 toRegion 可以是同一个地址；</li>
<li>将 scan 指向 heapStart 地址，free 指针指向 toRegion地址，开始遍历存活对象，找到存活对象之后，将存活对象中的 forwadingAddress 域设置为 free，然后将 scan 和 free 向后移动 size(存活对象) 大小的位置，当 scan 大于 heapEnd 之后，第一次遍历结束；</li>
<li>第二次遍历：更新转发地址的值。遍历根集合和堆中所有的对象，更新对象指针域中指向的地址为 forwadingAddress 中的地址；</li>
<li>第三次遍历：移动对象。遍历堆中所有对象，将对象移动到 forwadingAddress 指向的地址。</li>
</ol>
<p>算法过程如下所示：<br><img src="/images/gc/lisp2-init.jpg" alt="lisp2-init" title="lisp2-init"><br>初始状态下:1）有A, B, C, D 4个存活对象，其中 C 对象中有两个指针分别指向 A 和 B 两个对象。</p>
<p><img src="/images/gc/lisp2-first.jpg" alt="lisp2-first" title="lisp2-first"><br>第一次遍历，在每一个对象中，增加一个forwadingAddress 域，即 FA域，存放移动后的地址，移动后的地址通过遍历可以获得。</p>
<p><img src="/images/gc/lisp2-second.jpg" alt="lisp2-second" title="lisp2-second"><br>第二次遍历，更新堆中所有对象的指针域，重新指向 FA 域指向的地址。</p>
<p><img src="/images/gc/lisp2-third.jpg" alt="lisp2-third" title="lisp2-third"><br>第三次遍历，根据对象中的 FA 域的值，将该对象移动到 FA 域指向的地址。</p>
<p>Lisp 2 算法需要遍历三次堆，同时对象中需要一个 forwadingAddress 域，用来存放“转发的地址”。</p>
<p>Lisp 2 算法的伪代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">compact():</span><br><span class="line">    computeLocations(HeapStart, HeapEnd, HeapStart)     /* 计算转发地址 */</span><br><span class="line">    updateReferences(HeapStart, HeapEnd)    /* 更新转发地址 */</span><br><span class="line">    relocate(HeapStart, HeapEnd)    /* 移动指针 */</span><br><span class="line"></span><br><span class="line">/* 计算转发地址 */</span><br><span class="line">computeLocations(start, end, toRegion)</span><br><span class="line">    scan = start</span><br><span class="line">    free = toRegion</span><br><span class="line"></span><br><span class="line">    while scan &lt; end</span><br><span class="line">        if isMarked(scan)</span><br><span class="line">            forwardingAddress(scan) = free  /* 设置转发地址 */</span><br><span class="line">            free = free + size(scan)</span><br><span class="line">        scan = scan + size(scan)</span><br><span class="line"></span><br><span class="line">/* 更新转发地址 */</span><br><span class="line">updateReferences(start, end)</span><br><span class="line">    for each fld in Roots   /* 更新根 */</span><br><span class="line">        ref = *fld</span><br><span class="line">        if ref != null</span><br><span class="line">            *fld = forwardingAddress(ref)</span><br><span class="line">    </span><br><span class="line">    scan = start</span><br><span class="line">    while scan &lt; end</span><br><span class="line">        if isMarked(scan)</span><br><span class="line">            for each fld in Pointers(scan)</span><br><span class="line">                if *fld != null</span><br><span class="line">                    *fld = forwardingAddress(*fld)</span><br><span class="line">        scan = scan + size(scan)</span><br><span class="line"></span><br><span class="line">/* 移动指针 */</span><br><span class="line">relocate(start, end)</span><br><span class="line">    scan = start</span><br><span class="line">    while scan &lt; end</span><br><span class="line">        if isMarked(scan)</span><br><span class="line">            dest = forwardingAddress(scan)</span><br><span class="line">            move(scan, dest)</span><br><span class="line">            unsetMarked(dest)</span><br><span class="line">        scan = scan + size(scan)</span><br></pre></td></tr></table></figure>
<h3 id="2-3-引线整理算法"><a href="#2-3-引线整理算法" class="headerlink" title="2.3 引线整理算法"></a>2.3 引线整理算法</h3><p>Lisp 2 算法有两个缺陷：1）需要遍历三次堆；2）每一个对象需要额外的空间来记录转发地址。引线整理算法通过一种不同的策略来解决指针更新的问题，该算法不需要额外存储，且支持滑动整理。引线算法要求对象头部存在足够的空间来保存一个地址，引线的目的是通过对象 N 可以找到所有引用了该对象的对象，实现的方法是临时反转指针的方向。</p>
<p><img src="/images/gc/thread-before.jpg" alt="thread-before" title="thread-before"><br>引线之前，三个对象引用了对象N</p>
<p><img src="/images/gc/thread-after.jpg" alt="thread-after" title="thread-after"><br>引线之后，所有指向对象 N 的指针都被“引线”，因此可以通过对象 N 找到引用了对象 N 的对象。在对象 N 中，指向下一个对象的指针保存在其头部的某个值中，该头部以前的值被（临时地）移动到对象 A 中引用了对象 N 的指针域中。</p>
<p>引线整理算法需要两次堆遍历，第一次遍历实现堆中前向指针（从低地址指向高地址的指针）的引线，第二次遍历实现堆中后向指针（从高地址指向低地址的指针），其算法流程如下：</p>
<ol>
<li>第一次遍历，从对根进行引线，然后在堆中从头到尾进行扫描，同时计算转发地址 free，扫描到对象 N 时，根据前向指针，修改引用对象 N 的所有对象（其地址小于对象 N）的指针，将其设置为 free。同时对对象 N 的所有指针进行引线（包括前向指针和后向指针）。</li>
<li>第二次遍历，在堆中从头到尾进行扫描，计算转发地址，扫描到对象 N 时，根据后向指针，修改引用对象 N 的所有对象（其地址大于对象 N）的指针，将其设置为 free，最后将对象移动到 free。</li>
</ol>
<p>算法过程如下所示：<br><img src="/images/gc/threading-init.jpg" alt="threading-init" title="threading-init"><br>初始状态下，有一个根对象指向对象 N, 三个对象 A, B 及 C 指向 对象 N 。</p>
<p><img src="/images/gc/threading-first-1.jpg" alt="threading-first-1" title="threading-first-1"><br>第一次遍历，扫描到对象 A，实现了前向指针的引线。</p>
<p><img src="/images/gc/threading-first-2.jpg" alt="threading-first-2" title="threading-first-2"><br>第一次遍历，扫描到对象 N，根据前向指针的引线，更新根对象及对象 A 的指针域（对象 N 的新地址 free1）。</p>
<p><img src="/images/gc/threading-first-3.jpg" alt="threading-first-3" title="threading-first-3"><br>第一次遍历，扫描到对象 C，实现了后向指针的引线。</p>
<p><img src="/images/gc/threading-second.jpg" alt="threading-second" title="threading-second"><br>第二闪遍历，根据后向指针的引线，更新后向指针，且移动存活对象。</p>
<p>引线整理算法伪代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">compact():</span><br><span class="line">    updateForwardReferences()   /* 更新前向指针 */</span><br><span class="line">    updateBackwardReferences()  /* 更新后向指针 */</span><br><span class="line"></span><br><span class="line">/* 对引用进行引线 */</span><br><span class="line">thread(ref):</span><br><span class="line">    if *ref != null</span><br><span class="line">        *ref = **ref</span><br><span class="line">        **ref = ref</span><br><span class="line"></span><br><span class="line">/* 根据引线，更新转发地址 */</span><br><span class="line">update(ref, addr):</span><br><span class="line">    tmp = *ref</span><br><span class="line">    while isReference(tmp)</span><br><span class="line">        *tmp = addr</span><br><span class="line">        tmp = *tmp</span><br><span class="line">    *ref = tmp</span><br><span class="line"></span><br><span class="line">/* 更新前向指针 */</span><br><span class="line">updateForwardReferences():</span><br><span class="line">    for each fld in Roots</span><br><span class="line">        thread(*fld)</span><br><span class="line">    </span><br><span class="line">    free = HeapStart</span><br><span class="line">    scan = HeapStart</span><br><span class="line">    while scan &lt;= HeapEnd</span><br><span class="line">        if isMarked(scan)</span><br><span class="line">            update(scan, free)  /* 将所有指向 scan 的前向指针都修改为 free */</span><br><span class="line">            for each fld in Pointers(scan)</span><br><span class="line">                thread(fld)</span><br><span class="line">            free = free + size(scan)</span><br><span class="line">        scan = scan + size(scan)</span><br><span class="line"></span><br><span class="line">/* 更新后向指针且移动对象 */</span><br><span class="line">updateBackwardReferences():</span><br><span class="line">    free = HeapStart</span><br><span class="line">    scan = HeapStart</span><br><span class="line">    while scan &lt;= HeapEnd</span><br><span class="line">        if isMarked(scan)</span><br><span class="line">            update(scan, free)  /* 将所有指向 scan 的后向指针都修改为 free */</span><br><span class="line">            move(scan, free)</span><br><span class="line">            free = free + size(scan)</span><br><span class="line">        scan = scan + size(scan)</span><br></pre></td></tr></table></figure></p>
<h3 id="2-4-单次遍历算法"><a href="#2-4-单次遍历算法" class="headerlink" title="2.4 单次遍历算法"></a>2.4 单次遍历算法</h3><p>在上面三种整理算法中，都需要多次遍历堆，有没有只需要遍历一次堆即可完成内存整理？借助额外的数据结构存储对象的“转发地址”，单次遍历算法通过一次堆的遍历便可实现内存的整理，这是典型的“空间换时间”。<br>在单次遍历算法中，使用了两种数据结构：1）标记位向量（mark-bit vector），它的每一位反映了每个存活对象的起始和结束地址；2）偏移向量（offset vector），将堆划分成大小相等的小内存块（分别是 256 字节和 512 字节），偏移向量记录了每一个内存块中第一个存活对象的的转发地址，其他存活对象的转发地址可以通过偏移向量和标记位向量实时计算得出。对于任意给定对象，可以先计算出其所在内存块的索引号，然后再根据该内存块在偏移向量和标记位向量中对应数据计算出该对象的转发地址。回收器不再需要两次遍历来移动对象和更新指针，转而可以通过对标记位向量的一次遍历来构造偏移向量，然后再通过一次堆遍历同时完成对象的移动和指针的更新。</p>
<p>以下图为例，假定每个内存块包含 8 个槽，每一个槽代表一个字，任意一个对象在标记位向量中使用起始和结束地址进行标记，如old对象，在标记位向量中使用第 16 位和第 19 位来标记。<br><img src="/images/gc/compressor.jpg" alt="compressor" title="compressor"><br>在上图中，堆被分成 4 个内存块，分别是 block 0~3，block 0 中的第 2、3、6、7位被设置，block 1 中的第 3、5 位被设置，这表示已经有 7 个内存字在标记位向量中得到了标记，因此 block 2 中的第一个存活对象将被移动到堆中的第 7 个槽中，对应 offset [ 2(block) ] = 7, old 对象在 block 2 中的偏移 offsetInBlock(old) = 3, 那么 old 对象的转发地址就等于 offset[2] +  offsetInBlock(old) = 10。</p>
<p>单次遍历算法的流程如下：</p>
<ol>
<li>根据标记过程中得到的标记位向量，计算偏移向量；</li>
<li>从头到尾遍历堆，根据标记位向量和偏移向量，计算出对象的转发地址，进行对象的移动或指针的更新。</li>
</ol>
<p>单次遍历算法伪代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">compact():</span><br><span class="line">    computeLocations(HeapStart, HeapEnd, HeapStart)     /* 计算偏移向量 */</span><br><span class="line">    updateReferencesRelocate(HeapStart, HeapEnd)        /* 更新转发地址和移动对象 */</span><br><span class="line"></span><br><span class="line">/* 计算偏移向量 */</span><br><span class="line">computeLocations(start, end, toRegion)</span><br><span class="line">    loc = toRegion</span><br><span class="line">    block = getBlockNum(start)  /* 得到指针所在块的索引 */</span><br><span class="line">    for b = 0 to numBits(start, end) - 1    /* 遍历标记位向量 */</span><br><span class="line">        if b % BITS_IN_BLOCK == 0   /* 是否跨越了块边界 */</span><br><span class="line">            offset[block] = loc     /* 存放块中第一个对象的地址 loc */</span><br><span class="line">            block = block + 1</span><br><span class="line">        if bitmap[b] = MARKED</span><br><span class="line">            loc = loc + BYTES_PER_BIT   /* 根据存活对象的大小移动 */</span><br><span class="line"></span><br><span class="line">/* 计算转发地址 */</span><br><span class="line">newAddress(old):</span><br><span class="line">    block = getBlockNum(old)</span><br><span class="line">    return offset[lock] + offsetInBlock(old)    /* 转发地址的公式 */</span><br><span class="line"></span><br><span class="line">updateReferencesRelocate(start, end):</span><br><span class="line">    for each fld in Roots</span><br><span class="line">        ref = *fld</span><br><span class="line">        if ref != null</span><br><span class="line">            *fld = newAddress(ref)</span><br><span class="line">    scan = start</span><br><span class="line">    while scan &lt; end</span><br><span class="line">        scan = nextMarkedObect(scan)    /* 使用位图 */</span><br><span class="line">        for each fld in Pointers(scan)  /* 更新引用 */</span><br><span class="line">            ref = *fld</span><br><span class="line">            if ref != null</span><br><span class="line">                *fld = newAddress(ref)</span><br><span class="line">        dest = newAddress(scan)</span><br><span class="line">        move(scan, dest)</span><br></pre></td></tr></table></figure></p>
<h2 id="3-复制式回收算法"><a href="#3-复制式回收算法" class="headerlink" title="3. 复制式回收算法"></a>3. 复制式回收算法</h2><p>相对于标记 - 整理算法，复制式回收算法，可以有效提供内存分配的效率，同时回收过程只需要遍历堆一次，其缺点是堆的可用空间降低了一半。基本的复制式回收器将堆划分为两个大小相等的半区（semispace），分别是来源空间（fromspace）和目标空间（tospace），为了简化，我们假定堆是一块连续的内存空间。当堆空间足够时，在目标空间中分配新对象的方法是根据对象的大小简单地增加空闲空间，如果可用空间不足，则进行垃圾回收。回收器先两个半区角色进行切换，然后将存活对象从来源空间得到到目标空间。在回收完成之后，所有存活对象将紧密排布在目标空间的一端。在下一轮回收之前，回收器将简单地丢弃来源空间（为了安全起见，可以作清零处理）。</p>
<p>复制式回收算法的流程如下：</p>
<ol>
<li>初始化工作列表（栈结构），将复制完成但未扫描的对象（灰色对象）放入工作列表，列表为空表示结束；</li>
<li>从根集合开始，将根对象复制到目标空间，在原有对象中设置转发地址，即目标空间的新地址，并将根对象放入工作列表中，原对象中是否有转发地址是判断复制是否完成的依据；</li>
<li>从工作列表中取出灰色对象，扫描其指针域，将指针指向的对象复制到目标空间中，设置转发地址，并加入工作列表；</li>
<li>重复第 3 步操作，直到工作列表为空。</li>
</ol>
<p>Cheney 扫描（Cheney scanning）算法是一种十分优雅的算法，该算法复用目标空间中的灰色对象实现栈的结构，它仅需要一个指针 scan 为指向下一个待扫描对象，除此之外不再需要任何额外空间。结束的标志是指针 scan 和指针 free 重合。</p>
<p>下面是一个 Cheney 扫描对象 L 的实例，该对象是链表结构的头结点，它包含指向表头和表尾的指针。<br><img src="/images/gc/cheney-scanning-init.jpg" alt="cheney-scanning-init" title="cheney-scanning-init"><br>初始状态，所有对象都在来源空间。</p>
<p><img src="/images/gc/cheney-scanning-1.jpg" alt="cheney-scanning-1" title="cheney-scanning-1"><br>复制根对象，使用原对象的头部存放转发地址。</p>
<p><img src="/images/gc/cheney-scanning-2.jpg" alt="cheney-scanning-2" title="cheney-scanning-2"><br>扫描根对象副本 L’ 的指针域，复制 A、E 对象到目标空间，扫描结束，根对象副本 L’ 出栈，继续对 A 对副本 A’ 象进行扫描。</p>
<p><img src="/images/gc/cheney-scanning-3.jpg" alt="cheney-scanning-3" title="cheney-scanning-3"><br>扫描对象 C 副本 C’</p>
<p><img src="/images/gc/cheney-scanning-4.jpg" alt="cheney-scanning-4" title="cheney-scanning-4"><br>扫描对象 D 副本 D’，此时 scan = free，说明回收结束。</p>
<p>复制式回收算法伪代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">/* 创建半区 */</span><br><span class="line">createSemispaces():</span><br><span class="line">    tospace = HeapStart</span><br><span class="line">    extent = ( HeapEnd - HeapStart ) / 2</span><br><span class="line">    top = fromspace = HeapStart + extent</span><br><span class="line">    free = tospace</span><br><span class="line"></span><br><span class="line">/* 分配内存 */</span><br><span class="line">allocate(size):</span><br><span class="line">    result = free</span><br><span class="line">    newfree = result + size</span><br><span class="line">    if newfree &gt; top</span><br><span class="line">        return null     /* 内存耗尽 */</span><br><span class="line"></span><br><span class="line">    free = newfree</span><br><span class="line">    return result</span><br><span class="line"></span><br><span class="line">/* 内存整理 */</span><br><span class="line">collect():</span><br><span class="line">    flip()  /* 切换来源空间和目标空间 */</span><br><span class="line">    initialise(worklist)    /* 将工作列表初始化为空 */</span><br><span class="line">    </span><br><span class="line">    for each fld in Roots   /* 复制根 */</span><br><span class="line">        process(fld)</span><br><span class="line">    </span><br><span class="line">    while not isEmpty(worklist)</span><br><span class="line">        ref = remove(worklist)</span><br><span class="line">        scan(ref)</span><br><span class="line"></span><br><span class="line">/* 翻转半区 */</span><br><span class="line">flip():</span><br><span class="line">    tmp = fromsapce</span><br><span class="line">    fromspace = tospace</span><br><span class="line">    tospace - tmp</span><br><span class="line"></span><br><span class="line">    top = tospace + extent</span><br><span class="line">    free = tospace</span><br><span class="line"></span><br><span class="line">scan(ref):</span><br><span class="line">    for each fld in Pointers(ref)</span><br><span class="line">        process(fld)</span><br><span class="line"></span><br><span class="line">/* 使用目标空间中新副本的地址来更新域 */</span><br><span class="line">process(fld):</span><br><span class="line">    fromRef = *fld</span><br><span class="line">    if fromRef != null</span><br><span class="line">        *fld = forward(fromRef)     /* 使用目标空间中新副本的地址来更新 */</span><br><span class="line">    </span><br><span class="line">forward(fromRef):</span><br><span class="line">    toRef = forwardingAddress(fromRef)</span><br><span class="line">    if toRef = null     /* 尚未得到复制（尚未标记） */</span><br><span class="line">        toRef = copy(fromRef)</span><br><span class="line">    </span><br><span class="line">    return toRef</span><br><span class="line"></span><br><span class="line">/* 复制对象，返回转发地址 */</span><br><span class="line">copy(fromRef):</span><br><span class="line">    toRef = free</span><br><span class="line">    free = free + size(fromRef)</span><br><span class="line">    move(fromRef, toRef)</span><br><span class="line">    forwardingAddress(fromRef) = toRef  /* 标记 */</span><br><span class="line">    add(worklist, toRef)</span><br><span class="line">    return toRef</span><br><span class="line"></span><br><span class="line">/* 使用 Cheney 工作列表进行复制 */</span><br><span class="line">initialise(worklist):</span><br><span class="line">    scan = free</span><br><span class="line"></span><br><span class="line">isEmpty(worklist):</span><br><span class="line">    return scan = free</span><br><span class="line"></span><br><span class="line">remove(worklist):</span><br><span class="line">    ref = scan</span><br><span class="line">    scan = scan + size(scan)</span><br><span class="line">    return ref</span><br><span class="line"></span><br><span class="line">add(worklist, ref):</span><br><span class="line">    /* 空 */</span><br></pre></td></tr></table></figure></p>
<h2 id="4-引用计数算法"><a href="#4-引用计数算法" class="headerlink" title="4. 引用计数算法"></a>4. 引用计数算法</h2><p>上面讲到的三种垃圾回收算法都是间接式的，它们需要从已知的根集合出发对存活对象进行遍历，进而才能确定所有的存活对象。而在引用计数算法中，对象的存活性可以通过引用关系的创建或删除直接判定，无须像上面的三种追踪式回收器那样先通过堆遍历找出所有的存活对象，然后再反向确定出未遍历到的垃圾对象。<br>引用计数算法判断一个对象是否回收的依据是：当且仅当指向某个对象的引用数量大于零时，该对象才有可能是存活的。在引用计数算法中，每个对象都需要与一个引用计数相关联，这一计数通常保存在对象头部的某个槽中。下面是一个简单的引用计数算法，Write方法用于增加新目标对象的引用计数，同时减少旧目标对象的引用计数。对象执行读写操作时，需要维护其关联的引用计数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">New():</span><br><span class="line">    ref = allocate()</span><br><span class="line">    if ref = null</span><br><span class="line">        error &quot;Out of memory&quot;</span><br><span class="line">    rc(ref) = 0     /* 初始化计数 */</span><br><span class="line">    return ref</span><br><span class="line"></span><br><span class="line">Write(src, i, ref):</span><br><span class="line">    addReference(ref)</span><br><span class="line">    deleteReference(src[i])</span><br><span class="line">    src[i] = ref</span><br><span class="line"></span><br><span class="line">addReference(ref):</span><br><span class="line">    if ref != null</span><br><span class="line">        rc(ref) = rc(ref) + 1</span><br><span class="line"></span><br><span class="line">deleteReference(ref):</span><br><span class="line">    if ref != null</span><br><span class="line">        rc(ref) = rc(ref) - 1</span><br><span class="line">    if rc(ref) = 0</span><br><span class="line">        for each fld in Pointers(ref)</span><br><span class="line">            deleteReference(*fld)</span><br><span class="line">        free(ref)</span><br></pre></td></tr></table></figure></p>
<p>引用计数算法将内存管理开销分摊在程序运行过程中，无须停顿程序便可对内存进行整理，也不用为回收器预留一定空间。另外一方面也不需要运行时系统的支持，以库的形式就可以支持内存的回收，如 C++ 的智能指针就是使用引用计数来实现内存的自动管理。除了这些优点，引用计数算法同样存在一些缺陷：1）引用计数给赋值操作带来了额外的时间开销，因为需要维护引用计数；2）引入多线程竞争的问题，引用计数的增减操作以及加载和存储指针的操作必须是原子化的；3）读操作会引发计数器的更新操作，会“污染”高速缓存；4）引用计数无法回收环状引用数据结构；5）引用计数会占用额外的存储空间。</p>
<p>注：环状垃圾回收的问题，一般需要引入停顿程序的方式来解决。</p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>本篇文章分析了四种基本的垃圾回收算法，它们分别有不同的使用场景：</p>
<ol>
<li>标记 - 清扫： 算法简单，适合于分配固定大小对象的场景；</li>
<li>标记 - 整理： 需要遍历堆多次或引入额外的数据结构来记录转发地址，算法较复杂，优势是可以解决内存碎片的问题，内存利用率较高；</li>
<li>复制式回收算法 ： 内存分配速度及效率较高，缺点是堆的可用空间降低了一半；</li>
<li>引用计数：内存管理的开销分摊到程序运行期间，不需要运行时系统的支持，但需要解决环状引用的问题。</li>
</ol>
<p><strong>参考：</strong></p>
<hr>
<p><a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection" target="_blank" rel="noopener">1. Tracing garbage collection</a><br><a href="https://book.douban.com/subject/26740958/" target="_blank" rel="noopener">2. 垃圾回收算法手册——自动内存管理的艺术</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/12/mind-mapping-insurance-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/07/12/mind-mapping-insurance-1/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">思维导图-保险知识-1</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-07-12 10:10:10" itemprop="dateCreated datePublished" datetime="2020-07-12T10:10:10+08:00">2020-07-12</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-07-31 17:17:10" itemprop="dateModified" datetime="2021-07-31T17:17:10+08:00">2021-07-31</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/思维导图/" itemprop="url" rel="index"><span itemprop="name">思维导图</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">278</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">1 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>之前给小孩和自己买保险走了一些弯路，特意研究了保险的品种及保障的作用，用思维导图做了一个总结，权当是笔记吧。</p>
<p><img src="/images/insurance.jpeg" alt="insurance" title="insurance"></p>
<p><strong>参考：</strong></p>
<hr>
<p><a href="https://book.douban.com/subject/30302000/" target="_blank" rel="noopener">1. 你的第一本保险指南</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/14/java-memory-model/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/06/14/java-memory-model/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">Java 内存模型</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-06-14 20:36:17" itemprop="dateCreated datePublished" datetime="2020-06-14T20:36:17+08:00">2020-06-14</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-07-31 17:17:10" itemprop="dateModified" datetime="2021-07-31T17:17:10+08:00">2021-07-31</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java基础/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">9.7k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">9 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>处于优化的目的，在不同的编译器及不同体系架构的cpu 中，会将指令重排，即程序中排在后面的指令有可能比排在前面的指令先执行。同时由于cpu 中存在读写缓冲区，会将指令相关的运行时数据暂存在这些缓冲区中，也会导致指令重排的问题。目前的cpu 都是多核的体系架构，同一个语言编写的程序在不同硬件体系中，在多线程执行环境下，多次执行的结果可能不一致。在Java 中，怎么解决这个问题？为了屏蔽不同硬件架构的差异，给程序员提供一致的运行结果，Java 提出了 JMM(内存模型)的概念。</p>
<p>Java 内存模型（JMM）描述了在Java 语言中线程如何与主内存（Main Memory）进行交互，定义了一套线程对共享变量的访问规则，同时决定一个线程对共享变量的写入何时对另外一个线程可见。</p>
<p>在Java 中，共享变量主要包括实例字段、静态字段和数组元素，这些变量存储在堆内存中，由所有线程共享。而局部变量、方法参数和异常处理参数不会在线程间共享，不存在可见性（一个线程对变量的写入对另外的线程可见）的问题，不受内存模型的的影响。</p>
<p>从抽象的角度来看，JMM 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local memory），本地内存中存储了该线程读/写共享变量的副本。本地内存是JMM 的一个抽象概念，并不真实存在，它涵盖了缓存、写缓存区、寄存器以及其它硬件。JMM 抽象示意图如下所示：<br><img src="/images/JMM.jpg" alt="JMM" title="JMM"></p>
<p>从上图来看，线程A与线程B要进行通过的话，必须要经历两个步骤：</p>
<ol>
<li>首先，线程A将在本地内存中修改的共享变量刷新到主内存中；</li>
<li>最后，线程B重新从主内存加载修改后的共享变量，从而看到被修改后的内容。</li>
</ol>
<p>本质上来说，JMM 通过控制主内存与每个线程的本地内存之间的交互，来提供内存可见性的保证。</p>
<h2 id="2-重排序"><a href="#2-重排序" class="headerlink" title="2. 重排序"></a>2. 重排序</h2><p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：</p>
<ol>
<li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li>
<li>指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>
<li>内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。<br>从java源代码到最终实际执行的指令序列，会分别经历下面三种重排序：<br><img src="/images/java-instruction-reorder.png" alt="java-instruction-reorder" title="java-instruction-reorder"></li>
</ol>
<p>上述的1属于编译器重排序，2和3属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM的处理器重排序规则会要求java编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel称之为memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。<br>JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</p>
<h2 id="3-内存系统重排序"><a href="#3-内存系统重排序" class="headerlink" title="3. 内存系统重排序"></a>3. 内存系统重排序</h2><p>现代处理器与内存存在较大的性能差异，以主频为3GHZ的cpu为例，cpu访问一次内存时间在10~100ns内，但cpu  在100ns内可以执行1200条指令（假定一个时钟周期可以同时执行4条指令，一个时间周期为0.3ns）。因此，现代处理器在内存之间引入了多级的缓存结构，同时为了提高指令的执行效率，在cpu 寄存器与缓存之间引入了读/写缓冲区。写缓冲区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟。同时，通过以批处理的方式刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写，可以减少对内存总线的占用。读缓冲区可以缓存当前指令读取的数据，实现cpu异步读取数据，提高cpu的吞吐率。以Intel x86 CPU （2012 Sandy Bridge）为例，如下图所示：<br><img src="/images/memory-heirarchy.png" alt="memory-heirarchy" title="memory-heirarchy"><br>其内部组成包括：</p>
<ol>
<li>寄存器：在每个cpu 核心上，有160个用于整数和144个用于浮点的寄存器单元。访问这些寄存器只需要一个时钟周期，这构成了对执行核心来说最快的内存。编译器会将本地变量和函数参数分配到这些寄存器上。当使用超线程技术（ hyperthreading ）时，这些寄存器可以在超线程协同下共享。</li>
<li>读写缓冲区：读写缓存区包含64个load 缓冲条目和36个的store 缓冲条目。这些缓冲区用于记录等待缓存子系统时正在执行的操作。store 缓冲区保存将要写到L1 缓存的数据。load 缓冲区保存正要被寄存器读取的数据。由于读/写缓存仅对当前cpu 核心可见，这会造成指令的重排序，需要通过内存屏障来保证其执行顺序。</li>
<li>L1 &amp; L2 缓存：L1和L2 是一个本地核心内的缓存，它们在大小和速度上存在差异。</li>
<li>L3 缓存： 同插槽的所有cpu 核心共享L3缓存。L3缓存被分为多个2MB的段，所有段组成一环形网络。每一个核心都连接到这个环形网络上，地址通过hash的方式映射到段上以达到更大的吞吐量。</li>
<li>主内存：在缓存没命中的情况下，内存的平均延迟为65ns。</li>
<li>NUMA：在一个多插槽的服务器上，会使用非一致性内存访问机制（ non-uniform memory access ）。之所以要使用该方式主要是因为需要的数据在另外一个远程插槽上，需要跨越QPI 总线且额外花费40ns。 </li>
</ol>
<p>在上文讲到的多级缓存系统中，L1,L2,L3级缓存与主内存之间一致性一般是通过Cache Conherence技术来实现的，Intel 使用MESIF协议，AMD 使用 MOESI，在这里不再描述，我们假定：一旦内存数据被推送到L1 缓存，就会有消息协议来确保所有的缓存会对所有的共享数据同步并保持一致。</p>
<p>现在我们来分析引入读写缓冲区带来的问题，先看下两者的作用：</p>
<blockquote>
<p>When a store is issued to the out-of-order core for renaming and scheduling, an entry in the store buffer is allocated (in-order) for the address and the data. The store buffer will hold the address and data until the instruction has retired and the data has been written to the L1 cache.</p>
</blockquote>
<blockquote>
<p>Analogously, when a load is issued, an entry in the load buffer is reserved for the address. However, loads must also compare the load address against the contents of the entire store buffer to check for aliasing with older stores. If the load address matches an older store, then the load must wait for the older store to complete to preserve the dependency. Most x86 processors optimize this further, by allowing the store to forward data to the load without accessing the cache. The load buffer entry can be released, once the instruction has retired and the load data is written into the register file.</p>
</blockquote>
<blockquote>
<p>Because of the strong x86 ordering model, the load buffer is snooped by coherency traffic. A remote store must invalidate all other copies of a cache line. If a cache line is read by a load, and then invalidated by a remote store, the load must be cancelled, since it potentially read invalid data. The x86 memory model does not require snooping the store buffer.</p>
</blockquote>
<p>其要点包括：1）写缓冲区缓存指令的地址及数据信息，直到指令执行完毕且数据写入到L1 缓存中，写入到L1 缓存中之后，会通过MESIF协议通知其它cpu 核心失效相关的缓存行；2）读缓冲区按照地址缓存数据，直到指令执行完毕且数据被读到寄存器中；2）读缓冲区缓存了来自L1 缓存的数据，所以受MESIF协议的侦测，如果数据被其它远程的写缓冲区修改，根据MESIF协议，它会失效所有的数据拷贝，包括读缓冲区中的数据。</p>
<p>由于读写缓冲区只对当前cpu 核心有效，会造成指令重排的问题，要解决这个问题，需要引入“内存屏障”的技术。内存屏障提供了两个功能。首先，它们通过确保从另一个cpu 来看屏障的两边的所有指令都是正确的程序顺序，而保持程序顺序的外部可见性；其次它们可以实现内存数据可见性，确保内存数据会同步到cpu L1。</p>
<p><strong>Store Barrier</strong><br>Store 屏障，是x86的”sfence“ 指令，强制所有在store 屏障指令之前的store 指令，都在该store 屏障指令执行之前被执行，并把store 缓冲区的数据都刷到L1 ，这会使得程序状态对其它cpu 可见。</p>
<p><strong>Load Barrier</strong><br>Load 屏障，是x86 上的”ifence“ 指令，强制所有在load 屏障指令之后的load 指令，都在该load 屏障指令执行之后被执行，并且一直等到load 缓冲区被该cpu 读完才能执行之后的load 指令。这使得从其它cpu 暴露出来的程序状态对该cpu 可见，这之后cpu 可以进行后续处理。</p>
<p><strong>Full Barrier</strong><br>Full 屏障，是x86 上的”mfence“ 指令，复合了load 和save 屏障的功能。</p>
<h2 id="4-编译器重排序"><a href="#4-编译器重排序" class="headerlink" title="4. 编译器重排序"></a>4. 编译器重排序</h2><p><strong>数据依赖性</strong><br>如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。数据依赖分下列三种类型：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>代码示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>写后读</td>
<td>a = 1;b = a;</td>
<td>写一个变量之后，再读这个位置</td>
</tr>
<tr>
<td>写后写</td>
<td>a = 1;a = 2;</td>
<td>写一个变量之后，再写这个变量</td>
</tr>
<tr>
<td>读后写</td>
<td>a = b;b = 1;</td>
<td>读一个变量之后，再写这个变量</td>
</tr>
</tbody>
</table>
<p>上面三种情况，只要重排序两个操作的执行顺序，程序的执行结果将会被改变。</p>
<p>前面提到过，编译器和处理器可能会对操作做重排序。编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序</p>
<p><strong>as-if-serial 语义</strong><br>as-if-serial 语义的意思指：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守 as-if-serial 语义。</p>
<p>为了遵守 as-if-serial 语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作可能被编译器和处理器重排序。</p>
<h2 id="5-JMM内存屏障"><a href="#5-JMM内存屏障" class="headerlink" title="5. JMM内存屏障"></a>5. JMM内存屏障</h2><p>为了保证内存可见性，Java 编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。JMM把内存屏障指令分为下列四类：</p>
<table>
<thead>
<tr>
<th>屏障类型</th>
<th>指令示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>LoadLoad Barriers</td>
<td>Load1; LoadLoad; Load2</td>
<td>确保Load1数据的装载，之前于Load2及所有后续装载指令的装载。</td>
</tr>
<tr>
<td>StoreStore Barriers</td>
<td>Store1; StoreStore; Store2</td>
<td>确保Store1数据对其他处理器可见（刷新到内存），<br>之前于Store2及所有后续存储指令的存储。</td>
</tr>
<tr>
<td>LoadStore Barriers</td>
<td>Load1; LoadStore; Store2</td>
<td>确保Load1数据装载，之前于Store2及所有后续<br>的存储指令刷新到内存。</td>
</tr>
<tr>
<td>StoreLoad Barriers</td>
<td>Store1; StoreLoad; Load2</td>
<td>确保Store1数据对其他处理器变得可见（指刷新到内存），<br>之前于Load2及所有后续装载指令的装载。StoreLoad Barriers <br>会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，<br>才执行该屏障之后的内存访问指令。</td>
</tr>
</tbody>
</table>
<p>StoreLoad Barriers是一个“全能型”的屏障，它同时具有其他三个屏障的效果。现代的多处理器大都支持该屏障（其他类型的屏障不一定被所有处理器支持）。执行该屏障开销会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中（buffer fully flush）。</p>
<p><strong>JMM 内存屏障与cpu 内存屏障的映射</strong><br>在不同cpu 架构中，实现的内存屏障是不同的，如上面的X86体系中，只允许StoreLoad指令重排，所以只用实现StoreLoad Barriers，而其它cpu 体系则有所不同，其对应关系如下图所示：<br><img src="/images/cpu-barriers-map-jmm.png" alt="cpu-barriers-map-jmm" title="cpu-barriers-map-jmm"></p>
<p>由于常见的cpu 内存屏障比 JMM 要弱，java 编译器在生成字节码时，会在执行指令序列的适当位置插入内存屏障来限制处理器的重排序。同时，由于各种处理器内存屏障的强弱并不相同，为了在不同的处理器平台向程序员展示一个一致的内存模型，JMM 在不同的处理器中需要插入的内存屏障的数量和种类也不相同。</p>
<h2 id="6-happen-before"><a href="#6-happen-before" class="headerlink" title="6. happen-before"></a>6. happen-before</h2><p>JMM 使用happens-before 的概念来阐述操作之间的内存可见性，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before 关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。<br>与程序员密切相关的happens-before 规则如下：</p>
<ol>
<li>程序顺序规则：一个线程中的每个操作，happens-before 于该线程中的任意后续操作。</li>
<li>监视器锁规则：对一个监视器锁的解锁，happens-before 于随后对这个监视器锁的加锁。</li>
<li>volatile变量规则：对一个volatile域的写，happens-before 于任意后续对这个volatile域的读。</li>
<li>传递性：如果A happens- before B，且B happens- before C，那么A happens- before C。</li>
</ol>
<p>注意，两个操作之间具有happens-before关系，并不意味着前一个操作必须要在后一个操作之前执行！happens-before 仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前（the first is visible to and ordered before the second）。<br>happens-before与JMM的关系如下图所示：<br><img src="/images/happens-before.png" alt="happens-before" title="happens-before"></p>
<h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><p>通过JMM 模型的定义，使得Java语言真正实现了跨平台，在不同平台，多线程的执行总能得到一致的结果，同时定义happens-before 规则，简化了对JMM 理解难度。</p>
<p><strong>参考：</strong></p>
<hr>
<p><a href="https://www.infoq.cn/article/java-memory-model-1/" target="_blank" rel="noopener">1. 深入理解 Java 内存模型（一）——基础</a><br><a href="https://www.infoq.cn/article/java-memory-model-2/" target="_blank" rel="noopener">2. 深入理解 Java 内存模型（二）——重排序</a><br><a href="https://download.oracle.com/otn-pub/jcp/memory_model-1.0-pfd-spec-oth-JSpec/memory_model-1_0-pfd-spec.pdf?AuthParam=1593252270_c3d47e052ce05eb43eb35a8c96217567" target="_blank" rel="noopener">3. SR-133: JavaTM Memory Model and Thread Specification</a><br><a href="https://www.realworldtech.com/haswell-tm-alt/2/" target="_blank" rel="noopener">4. Haswell Transactional Memory Alternatives</a><br><a href="http://ifeve.com/cpu-cache-flushing-fallacy/" target="_blank" rel="noopener">5. CPU Cache Flushing Fallacy</a><br><a href="http://ifeve.com/memory-barriersfences/" target="_blank" rel="noopener">6. Memory Barriers/Fences</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/24/database-transaction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/05/24/database-transaction/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">数据库事务</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-05-24 12:55:17" itemprop="dateCreated datePublished" datetime="2020-05-24T12:55:17+08:00">2020-05-24</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-07-31 17:17:10" itemprop="dateModified" datetime="2021-07-31T17:17:10+08:00">2021-07-31</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据库/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">15k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">13 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在数据库技术中，事务将应用程序的多个读、写操作捆绑在一起成为一个逻辑操作单元。即事务中的所有读写是一个执行的整体，整个事务要么成功（提交）、要么失败（中止或回滚）。如果失败，应用程序可以安全地重试。这样，由于不需要担心部分失败的情况（无论出于何种原因），应用层的错误处理就变得简单得多。</p>
<h2 id="1-ACID的含义"><a href="#1-ACID的含义" class="headerlink" title="1. ACID的含义"></a>1. ACID的含义</h2><p>事务提供了四个方面的安全保证，即ACID，分别代表原子性（Atomicity），一致性（Consistency），隔离性（Isolation）与持久性（Durability）。</p>
<h3 id="1-1-原子性"><a href="#1-1-原子性" class="headerlink" title="1.1 原子性"></a>1.1 原子性</h3><p>ACID原子性描述了客户端发起一个包含多个写操作的请求时可能发生的情况，例如在完成了一部分写入后，系统发生了故障，包括进程崩溃，网络中断，磁盘变满或者违反了某种完整性约束等；把多个写操作纳入到一个原子事务，万一出现了上述故障而导致没法完成最终提交时，则事务会中止，并且数据库丢弃或撤销那些局部完成的操作。<br>ACID原子性所定义的特征是：在出错时中止事务，并将部分完成的写入全部丢弃。它强调一个可中止性的概念。</p>
<h3 id="1-2-一致性"><a href="#1-2-一致性" class="headerlink" title="1.2 一致性"></a>1.2 一致性</h3><p>ACID中的一致性主要是指对数据有特定的预期状态，任何数据更改必须满足这些状态约束（或者恒等条件）。例如，对于一个账单系统，账户的贷款余额应和借款余额保持平衡。如果某事务从一个有效的状态开始，并且事务中任何更新操作都没有违背约束，那么最后的结果依然符合有效状态。<br>这种一致性本质上要求应用层来维护状态一致（或者恒等），应用程序有责任正确地定义事务来保持一致性。这不是数据库可以保证的事情：即如果提供的数据违背了恒等条件，数据库很难检测进而阻止该操作（数据库可以完成针对某些特定类型的恒等约束检查，例如使用外键约束或唯一性约束。但通常主要靠应用程序定义数据的有效/无效状态，数据库主要用于存储）。<br>原子性，隔离性和持久性是数据库自身的属性，而ACID中的一致性更多是应用层的属性。应用程序可能借助数据库提供的原子性和隔离性，以达到一致性，但一致性本身并不源于数据库。因此，也有一种说法，字母C其实并不应该属于ACID。</p>
<h3 id="1-3-隔离性"><a href="#1-3-隔离性" class="headerlink" title="1.3 隔离性"></a>1.3 隔离性</h3><p>ACID语义中的隔离性意味着并发执行的多个事务相互隔离，它们不能互相交叉，主要是指多个事务中对相同记录读写操作进行隔离。</p>
<h3 id="1-4-持久性"><a href="#1-4-持久性" class="headerlink" title="1.4 持久性"></a>1.4 持久性</h3><p>数据库系统本质上是提供一个安全可靠的地方来存储数据而不用担心数据丢失等。持久性它保证一旦事务提交成功，即使存在硬件故障或数据库崩溃，事务所写入的任何数据也不会消失。</p>
<p>在ACID中，原子性，隔离性和持久性是数据库自身的属性，其中原子性和持久性，我们能修改的地方不多，所以后面的内容主要关注隔离性相关的内容。</p>
<h2 id="2-隔离性"><a href="#2-隔离性" class="headerlink" title="2. 隔离性"></a>2. 隔离性</h2><p>隔离性主要是解决多个事务对相同数据或关联数据同时进行读写引发的问题，这些问题包括脏读、脏写、不可重复读及幻读。</p>
<h3 id="2-1-脏读"><a href="#2-1-脏读" class="headerlink" title="2.1 脏读"></a>2.1 脏读</h3><p><strong>定义：一个事务读取了另外一个事务未提交的数据，主要是并发读的问题。</strong></p>
<p>假定某个事务已经完成部分数据写入，但事务尚未提交（或中止），此时另一个事务可以看到尚未提交的数据，如图所示：<br><img src="/images/dirty-read.jpg" alt="dirty-read" title="dirty-read"><br>事务1设置了x=3，在事务1未提交之前，事务2的get x操作返回了3。没有脏读时，事务2只有在事务1的事务提交之后才能看到x的新值。</p>
<p>当有以下需求时，需要防止脏读：</p>
<ul>
<li>如果事务需要更新多个对象，脏读意味着另一个事务可能会看到部分更新，而非全部。</li>
<li>如果事务发生中止，则所有写入操作都需要回滚。如果发生了脏读，这意味着它可能会看到一些稍后被回滚的数据，而这些数据并未实际提交到数据库中。之后所引发的后果可能会变得难以预测。</li>
</ul>
<h3 id="2-2-脏写"><a href="#2-2-脏写" class="headerlink" title="2.2 脏写"></a>2.2 脏写</h3><p><strong>定义：一个事务覆盖了另外一个事务未提交的数据更新，主要是对同一份数据进行并发更新的问题。</strong></p>
<p>如果两个事务同时尝试更新相同的对象，会发生什么情况?我们不清楚写入的顺序，但可以想象后写的操作会覆盖较早的写入。如果先前的写入是尚未提交事务的一部分，是否还会被覆盖？如果是，那就是脏写。<br>如果事务需要更新多个对象，脏写会带来非预期的错误结果，例如Alice和Bob两个人试图购买同一辆车，而购买洗车需要两次数据的写入：商品买主需要更新，同时发票也要更新。如下图所示，车主被改为Bob（他成功更新了商品数据），而Alice成功更新了发票信息，导致了业务数据的不一致。<br><img src="/images/dirty-write.jpg" alt="dirty-write" title="dirty-write"></p>
<h3 id="2-3-隔离级别-读提交"><a href="#2-3-隔离级别-读提交" class="headerlink" title="2.3 隔离级别-读提交"></a>2.3 隔离级别-读提交</h3><p>读-提交是数据库中比较流行的事务隔离级别，它提供以下两个保证：</p>
<ul>
<li>读数据库时，只能看到已成功提交的数据，防止脏读；</li>
<li>写数据库时，只会覆盖已成功提交的数据，防止脏写。</li>
</ul>
<p>数据库通常使用行级锁来防止脏写：当事务想修改某个对象（例如行或文档）时，它必须首先获得该对象的锁；然后一直持有锁直到事务提交（或中止）。给定时刻，只有一个事务可以拿到特定对象的锁，如果有另一个事务尝试更新同一个对象，则必须等待，直到前面的事务完成了提交（或中止）后，才能获得锁并继续。<br>数据库了为防止脏读，一般使用读锁，或者对于每一个待更新的对象，数据库都会维护数据的两个版本：1）旧值的版本；2）当前事务最新的版本。在事务提交之前，所有其它读操作都读取旧值；仅当写事务提交之后，才会切换到读取最新的值。</p>
<h3 id="2-4-不可重复读"><a href="#2-4-不可重复读" class="headerlink" title="2.4 不可重复读"></a>2.4 不可重复读</h3><p><strong>定义：在同一个事务中，同一个查询操作重复多次执行，返回结果不一样，主要是并发读的问题。</strong></p>
<p>不可重复读出现在一个事务中，在同一个查询操作执行多次操作的期间，另外一个事务对相同数据对象进行更新操作并成功提交事务，导致提交前后的数据不同。如下图所示，在读提交隔离级别下不能解决不可重复读的问题。<br><img src="/images/non-repeatable-read.jpg" alt="non-repeatable-read" title="non-repeatable-read"></p>
<p>假设Alice在银行有1000美元的存款，分为两个账户，每个500美元。现在有这样一笔转账交易从账户1转账户2。如果在她提交转账请求之后而数据库系统执行转账的过程中间，来查看两个账户的余额，她有可能会看到账户1在收到转账之前的余额（500美元），和账户2在完成转账之后的敌众余额（400美元）。对于Alice来说，貌似她的账户总共有900美元，而不是1000美元。</p>
<p>在上面的场景中，主要是一个事务跨越了另外一个事务，读取到了另外一个事务前后更新的数据，导致了数据的不一致性。为了解决这个问题，数据库引入了多版本并发控制（Multivesion Concurrency Control,MVCC），这种技术保留了数据对象多个不同的提交版本。</p>
<p>提供MVCC技术的隔离级别称为快照隔离级别，在MYSQL中也叫可重复读隔离级别，我们在这里统一叫快照隔离级别。在快照隔离级别中，脏写也是通过行锁来实现的，而脏读的实现也比较简单，直接基于MVCC来实现。</p>
<p>以PostgreSQL（或Mysql）中的MVCC实现为例。当事务开始时，首先赋予一个唯一的、单调递增的事务ID(txid)。每当事务向数据库写入新内部时，所写的数据都会被标记写入者的事务ID，如下图所示：<br><img src="/images/mvcc.jpg" alt="mvcc" title="mvcc"><br>表中的每一行都有一个created_by字段，其中包含了创建该行的事务ID。每一行还有一个deleted_ty字段，初始为空。如果事务要删除某行，该行实际上并未从数据库中删除，而只是将deleted_ty字段设置为请求删除的事务ID（仅仅标记为删除）。事后，当确定没有其它事务引用该标记删除的行时，数据库的垃圾回收进程才去真正删除并释放存储空间。</p>
<p>一次更新操作在内部会转换为一个删除操作加一个创建操作。例如，事务13从账户2中扣除100元，余额从500美元减为400美元，在account表里会出现现两行：一个余额为500但标记为删除的行（由事务13删除），另一个余额为400，由事务13创建。</p>
<p>当事务读数据库时，通过事务ID可以决定哪些对象可见，哪些不可见。通常情况下，仅当以下两个条件都成立，则该数据对象对事务可见：</p>
<ul>
<li>事务开始的时刻，创建该对象的事务已经完成了提交；</li>
<li>对象没有被标记为删除；或者即使标记了，但删除事务在当前事务开始时还没有完成提交。</li>
</ul>
<p>如事务12只能看到12之前提交的数据，事务13的更改对于事务12来说是不可见的。</p>
<h3 id="2-5-当前读"><a href="#2-5-当前读" class="headerlink" title="2.5 当前读"></a>2.5 当前读</h3><p>在快照隔离级别下，以下的场景会产生问题：</p>
<ol>
<li>首先输入一些匹配条件，即采用SELECT查询所有满足条件的行（例如，至少有两名医生正在值班，同一时刻房间没有预订）。</li>
<li>根据查询的结果，应用层代码来决定下一步的操作（有可能继续，或者报告错误并中止）。</li>
<li>如果应用程序决定继续执行，它将发起数据库写入（INSERT,UPDATE或DELETE）并提交事务。</li>
</ol>
<p>假定在一个医生管理系统中，医院会安排多个医生值班，医生也可以申请调整班次，但前提是确保至少一个医生还在该班次中值班。现在的情况是，Alice和Bob是两位值班医生，两个人碰巧都感到身体不适，因而都决定请假。如果他们几乎同一个时刻执行了调班的操作，如下图所示：<br><img src="/images/write-tilt.jpg" alt="write-tilt" title="write-tilt"></p>
<p>在数据库使用快照级别隔离，两个检查都返回有两名医生，所以两个事务都安全地进入下一下阶段。接下来，两个事务执行更新操作，调班成功。两个事务都成功提交，最后的结果却是没有任何医生在值班，显然违背了至少一个医生值班的业务需求。</p>
<p>为了解决这个问题，一种可选的方案是对查询的数据行显示加锁，加上for update，如下所示：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> doctors  <span class="keyword">where</span> on_call=<span class="literal">true</span> <span class="keyword">and</span> shift_id=<span class="number">1234</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> doctors  <span class="keyword">set</span> on_call=<span class="literal">false</span>  <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'Alice'</span>  <span class="keyword">and</span> shift_id=<span class="number">1234</span>;</span><br></pre></td></tr></table></figure></p>
<p>在上面的查询语句中，加入了for update，表示对数据行进行加锁，采用的是“当前读”的模式（Mysql数据库），即当前读会读取当前最新提交的数据，即使当前事务落后于最新事务，也能看到最新事务提交后的数据。</p>
<h3 id="2-6-幻读"><a href="#2-6-幻读" class="headerlink" title="2.6 幻读"></a>2.6 幻读</h3><p><strong>定义：在一个事务中的写入（插入）操作改变了另外一个事务查询的结果。</strong></p>
<p>在Mysql中，在快照读（可重复读）隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。幻读只会在“当前读”下才会出现，同时幻读专指“新插入的行”。</p>
<p>假定有如下的表及初始数据：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`d`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`c`</span> (<span class="string">`c`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>),(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>),(<span class="number">15</span>,<span class="number">15</span>,<span class="number">15</span>),(<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>),(<span class="number">25</span>,<span class="number">25</span>,<span class="number">25</span>);</span><br></pre></td></tr></table></figure></p>
<p>现在对该表执行三个事务，如下图所示：<br><img src="/images/multi-transaction.jpg" alt="multi-transaction" title="multi-transaction"></p>
<p>可以看到，事务A里执行了三次查询，分别是 Q1、Q2 和 Q3。它们的 SQL 语句相同，都是 select * from t where d=5 for update。这个语句查询所有d=5的行，使用当前读，并且加上锁，现在来看它们的返回结果：</p>
<ol>
<li>Q1只返回id=5这一行数据；</li>
<li>在T2时刻，事务B修改了id=0这行数据，所以Q2返回id=0和id=5这两行数据；</li>
<li>在T4时刻，事务C插入了新的一行数据，所以Q3返回id=0,id=1及id=5这三行数据。</li>
</ol>
<p>其中，Q3 读到 id=1 这一行的现象，被称为“幻读”。也就是说，幻读指的是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。</p>
<h4 id="2-6-1-幻读引发的问题"><a href="#2-6-1-幻读引发的问题" class="headerlink" title="2.6.1 幻读引发的问题"></a>2.6.1 幻读引发的问题</h4><p>幻读会引入两个问题，一是语义上的问题，事务A已经对d=5的行加了锁，其它事务仍然还可以对d=5的行进行操作，如将其它行的d字段改为5或新插入d=5的行；另外一个问题，会导致数据库数据和日志的不一致，如下图所示：<br><img src="/images/phantom-read-problem.jpg" alt="phantom-read-problemn" title="phantom-read-problem"><br>在数据库中id=5的行，d字段修改为100；id=1的行，d=5,c=5。我们再来看binlog的日志：</p>
<ol>
<li><p>T2时刻，事务C提交之后，写入两行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> c=<span class="number">5</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>T4时刻，事务A提交之后，写入三行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> d=<span class="number">100</span> <span class="keyword">where</span> d=<span class="number">5</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>合在一起之后，日志内容如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> c=<span class="number">5</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> d=<span class="number">100</span> <span class="keyword">where</span> d=<span class="number">5</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure></p>
<p>从执行的语句来看，事务A的update最后执行，导致所有d=5的行，d字段都修改为100，与数据库中的数据不一致。如果使用这个binlog日志进行恢复数据或进行主从备份，会导致数据的前后不一致。</p>
<h4 id="2-6-2-解决的办法"><a href="#2-6-2-解决的办法" class="headerlink" title="2.6.2 解决的办法"></a>2.6.2 解决的办法</h4><p>事务B中的update操作可以通过行锁来解决，但对于事务C的插入操作，由于该行在插入之前根本不存在，不能使用行锁来解决，因此，为了解决幻读问题，InnoDB 引入新的锁，也就是间隙锁 (Gap Lock)。顾名思义，间隙锁，锁的就是两个值之间的空隙。比如文章开头的表 t，初始化插入了 6 个记录，这就产生了 7 个间隙。如下图所示：<br><img src="/images/gap-lock.jpg" alt="gap-lock" title="gap-lock"><br>这样，当执行 <code>select * from t where d=5 for update</code> 的时候，就不止是给数据库中已有的 6 个记录加上了行锁，还同时加了 7 个间隙锁。这样就确保了无法再插入新的记录。也就是说这时候，在一行行扫描的过程中，不仅将给行加上了行锁，还给行两边的空隙，也加上了间隙锁。<br>间隙锁和行锁合称 next-key lock，每个 next-key lock 是前开后闭区间。也就是说，我们的表 t 初始化以后，如果用 <code>select * from t for update</code> 要把整个表所有记录锁起来，就形成了 7 个 next-key lock，分别是 (-∞,0]、(0,5]、(5,10]、(10,15]、(15,20]、(20, 25]、(25, +supremum]，其中supremum是InnoDB为每个索引加的一个不存在的最大值。</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>除了上面提到的两种隔离级别：读-提交和可重复读（快照读），数据库还提供了另外两种隔离级别：读未提交和串行化，其中读未提交只解决了脏写，没有解决脏读，而串行化则要求事务串行化执行，由于性能的问题，大多数据库一般不会使用该隔离级别。</p>
<p><strong>参考：</strong></p>
<hr>
<p><a href="https://book.douban.com/subject/30329536/" target="_blank" rel="noopener">1. 数据密集型应用系统设计</a><br><a href="https://time.geekbang.org/column/article/75173?utm_source=pinpaizhuanqu&amp;utm_medium=geektime&amp;utm_campaign=guanwang&amp;utm_term=guanwang&amp;utm_content=0511" target="_blank" rel="noopener">2. 幻读是什么，幻读有什么问题？</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/16/mysql-and-ignite-update-operation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/05/16/mysql-and-ignite-update-operation/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">mysql和ignite更新性能对比</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-05-16 16:58:02" itemprop="dateCreated datePublished" datetime="2020-05-16T16:58:02+08:00">2020-05-16</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-07-31 17:17:10" itemprop="dateModified" datetime="2021-07-31T17:17:10+08:00">2021-07-31</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据库/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">9.3k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">8 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前段时间，需要对内存数据库ignite进行造型，将mysql与ignite进行了性能测试，这篇文章主要是讲在update操作上两者的差异。我们首先假定数据库表如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_token_info (</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">	token_id <span class="built_in">CHAR</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	state <span class="built_in">TINYINT</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	server_id <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	room_id <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	update_date datetime <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	PRIMARY <span class="keyword">KEY</span> (datetime)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> idx_token_id <span class="keyword">ON</span> t_token_info (token_id);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx_server_id <span class="keyword">ON</span> t_token_info (server_id);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx_room_id <span class="keyword">ON</span> t_token_info (room_id);</span><br></pre></td></tr></table></figure></p>
<p>t_token_info表上有4个索引，其中在字段id上建立主键索引，token_id上建立唯一索引，server_id和room_id上建立B+Tree索引。更新的场景包括两方面：1）在token_id上进行更新，只影响一条件记录；2）批量更新，根据server_id及room_id上进行批量更新，一次server_id操作影响的记录为2000条。下面将对mysql及ignite两种数据库进行分析 ，首先分析update操作背后的逻辑，然后再根据场景进行性能测试，最后得出结论。</p>
<h2 id="1-Mysql"><a href="#1-Mysql" class="headerlink" title="1. Mysql"></a>1. Mysql</h2><h3 id="1-1-单条记录更新"><a href="#1-1-单条记录更新" class="headerlink" title="1.1 单条记录更新"></a>1.1 单条记录更新</h3><p>以下面的更新为例，分析mysql的操作过程：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> t_token_info <span class="keyword">set</span> state=<span class="number">1</span>,update_date=<span class="keyword">now</span>(),server_id=<span class="number">12</span> <span class="keyword">where</span>  token_id=token1;</span><br></pre></td></tr></table></figure></p>
<p><img src="/images/mysql-update.jpg" alt="mysql-update" title="mysql-update"></p>
<p>涉及到的IO操作如下：</p>
<ol>
<li>读取记录：包括B+Tree索引结点及数据的读取，假定索引及数据没有加载到内存，且B+Tree索引深度为2（分支因子为500且结点大小为4K的四级树可以存储256 TB的数据），则需要3次IO操作，两次读取索引结点，一次读取数据；</li>
<li>写入操作：包括预写日志（存储引擎的redo log日志）、binlog日志及写入的数据，至少三次IO操作，如果新写入的数据，导致B+Tree叶子结点进行分裂操作，则需要更多的IO操作；</li>
<li>更新索引操作：因为更新的字段state及activeId是二级索引，更新这两个值，在事务中需要更新索引。更新索引又涉及到读取索引结点，更新索引的内容，等同于多次对数据进行更新操作，索引越多，则IO操作越多。</li>
</ol>
<h3 id="1-2-批量更新"><a href="#1-2-批量更新" class="headerlink" title="1.2 批量更新"></a>1.2 批量更新</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> t_token_info <span class="keyword">set</span> state=<span class="number">1</span>,update_date=<span class="keyword">now</span>() <span class="keyword">where</span> server_id=<span class="number">12</span>;</span><br></pre></td></tr></table></figure>
<p>批量更新操作最终会转换为多次主键更新操作，这个操作由mysql服务器中执行器模块来执行，如下图所示：<br><img src="/images/mysql-batch-update.jpg" alt="mysql-batch-update" title="mysql-batch-update"></p>
<p>批量更新的操作如下：</p>
<ol>
<li>根据activeId的索引找到更新的tokenId列表；</li>
<li>遍历tokenId列表，取到tokenId，再根据主键索引找到token的数据；</li>
<li>执行单个token的执行操作，直到所有的token更新完毕；</li>
<li>批量更新的时间与影响的记录数存在线性的关系，记录数越多，时间越长。</li>
</ol>
<h2 id="2-ignite"><a href="#2-ignite" class="headerlink" title="2. ignite"></a>2. ignite</h2><h3 id="2-1-ignite固化内存模型"><a href="#2-1-ignite固化内存模型" class="headerlink" title="2.1 ignite固化内存模型"></a>2.1 ignite固化内存模型</h3><p><img src="/images/Durable_Memory_Diagram.png" alt="Durable_Memory_Diagram" title="Durable_Memory_Diagram"><br>iginte固化内存模型的层次：</p>
<ul>
<li>内存区域：可以根据业务需要，可以将内存分为不同的大小的段，每一个区域分为不同的页，如存放key-value对（ignite本质是基于key-value的内存数据库）的数据页；B+Tree元数据页，存放每一个索引的根结点及层次信息；索引页面，存放B+Tree结点，根据索引字段进行排序，值存储数据结点的页号及偏移值；空闲页，由多个空闲链表进行维护。</li>
<li>页：分为不同类型，一般为4K，可以进行配置。</li>
</ul>
<h3 id="2-2-B-Tree和索引页面"><a href="#2-2-B-Tree和索引页面" class="headerlink" title="2.2 B+Tree和索引页面"></a>2.2 B+Tree和索引页面</h3><p><img src="/images/page-memory-b-tree.png" alt="page-memory-b-tree" title="page-memory-b-tree"><br>应用定义和使用的SQL索引是以B+Tree数据结构的形式进行维护的。每个唯一索引Ignite会实例化并且管理一个专用的B+Tree实例。<br>整个B+Tree的目的就是链接和排序在固化内存中分配和存储的索引页面。从内部来说，索引页面包括了定位索引值、索引指向的缓存条目在数据页面中的偏移量、还有到其它索引页面的引用（用来遍历树）等所有必要的信息，缓存的键也会存储于B+Tree，它们通过哈希值进行排序。<br>B+树的元页面需要获得特定B+Tree的根和它的层次，以高效地执行范围查询。比如，当执行myCache.get(keyA)时，它会触发下面的操作流程：</p>
<ol>
<li>Ignite会查找myCache属于那个内存区；<br>在该内存区中，会定位持有myCache的键的B+Tree的元页面；</li>
<li>根据keyA的哈希值，然后在B+Tree中检索该键所属的索引页面；</li>
<li>如果对应的索引页面在内存/磁盘中没找到，那么意味着其在myCache中不存在，然后Ignite会返回null；</li>
<li>如果索引页面存在，那么它会包含找到缓存条目keyA所在的数据页面的所有必要信息；</li>
<li>Ignite定位keyA所属的数据页面然后将值返回给应用。</li>
</ol>
<p>3、数据的存储<br> <img src="/images/inginte-data.png" alt="inginte-data" title="inginte-data"><br>上图是一个数据页的内部结构，包括三个部分：1）Page Header；2）Data Header；3）Page Data，数据区，存放key-value对。</p>
<p>4、更新操作流程<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> t_token_info <span class="keyword">set</span> state=<span class="number">1</span>,update_date=<span class="keyword">now</span>(),server_id=<span class="number">12</span> <span class="keyword">where</span>  token_id=token1;</span><br></pre></td></tr></table></figure></p>
<p>在ignite内部中，一次操作为转化为缓存的一次put操作。myCache.put(keyA,valueA)操作的执行流程如下：</p>
<ol>
<li>Ignite会找到myCache所属的内存区；</li>
<li>在该内存区中，会定位持有myCache的键的B+树的元数据页面；</li>
<li>根据keyA的哈希值，然后在B+树中检索该键所属的索引页面；</li>
<li>如果对应的索引页面在内存或者磁盘上都没有找到，那么会从空闲列表中申请一个新的页面，成功之后，它就会被加入B+树；</li>
<li>如果索引页面是空的（即未引用任何数据页面），根据总的缓存条目大小会从空闲列表中分配一个新的数据页面，然后在索引页面中添加到新数据页面的引用；</li>
<li>该缓存条目会加入该数据页面。</li>
</ol>
<p>5、批量更新<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> t_token_info <span class="keyword">set</span> state=<span class="number">1</span>,update_date=<span class="keyword">now</span>() <span class="keyword">where</span> server_id=<span class="number">12</span>;</span><br></pre></td></tr></table></figure></p>
<p>在ignite中，批量更新操作，内部会转化为两个操作：1）select * from tokeninfo where activeId=12，先进行一次select操作，查询出修改的记录；2）再调用cache.invokeAll(…) 修改数据。<br>使用这种方式，批量更新的操作等同于：一次select操作（客户端操作） + n次单条记录的更新操作（客户端批量提交到服务器器），下面就对批量更新的性能进行验证。</p>
<h2 id="3-性能验证"><a href="#3-性能验证" class="headerlink" title="3. 性能验证"></a>3. 性能验证</h2><ol>
<li>场景1：假定有20万token数据，每一个服务器上的token数为2000个；</li>
<li>场景1：假定有20万token数据，每一个服务器上的token数为200个；</li>
<li>场景1：假定有20万token数据，每一个服务器上的token数为20个；</li>
</ol>
<p>分别在三种场景下，执行两种操作：1）按照唯一键token_id更新; 2）按照server_id进行批量更新。</p>
<h2 id="4-结论（ignite使用纯内存）"><a href="#4-结论（ignite使用纯内存）" class="headerlink" title="4. 结论（ignite使用纯内存）"></a>4. 结论（ignite使用纯内存）</h2><ol>
<li>ignite按照主键进行更新，QPS可以达到10,000，响应时间在5~10ms，性能相比mysql，有较大的提升。</li>
<li>ignite中批量更新操作会转换为：一个select操作 + n个token的更新操作。在批量执行token前，客户端需要执行一次select操作，获取影响的记录（获取主键），然后向服务器批量提交更新操作（根据主键进行操作）。客户端执行一次select操作，性能上会有一定的影响；</li>
<li>根据三种场景的测试，按照服务器进行批量更新操作，QPS及响应时间受两个因素影响：1）数据库服务器1S内可更新的缓存数量SC；2）一个操作影响的记录数ST。在SC确定的情况下，ST越大，QPS越小，响应时间越长，ST越小，QPS越大，响应时间越短。目前测试得出，在单台服务上1S可以完成对20，000个缓存的更新操作，如果ST为2000个，QPS只能达到10，受SC影响，如果ST为200个，QPS增大10倍，响应时间减少到10/1。</li>
</ol>
<p><strong>参考：</strong></p>
<hr>
<p><a href="https://www.ignite-service.cn/doc/java/DurableMemory.html#_1-%E5%9B%BA%E5%8C%96%E5%86%85%E5%AD%98" target="_blank" rel="noopener">1. 固化内存</a></p>
<p><a href="https://cwiki.apache.org/confluence/display/IGNITE/Ignite+Durable+Memory+-+under+the+hood" target="_blank" rel="noopener">2. Ignite Durable Memory - under the hood</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/05/storage-model/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/05/05/storage-model/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">存储引擎</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-05-05 16:20:33" itemprop="dateCreated datePublished" datetime="2020-05-05T16:20:33+08:00">2020-05-05</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-07-31 17:17:10" itemprop="dateModified" datetime="2021-07-31T17:17:10+08:00">2021-07-31</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据库/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">4.8k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">4 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>概括来讲，存储引擎分为两大类：针对事务处理（OLTP）优化的结构，以及针对分析型（OLAP）的优化结构。它们典型的访问模式存在很大的差异：</p>
<ul>
<li>OLTP系统通常面向用户，这意味着它们可能收到大量的请求。为了处理负载，应用程序通常在每个用户查询中只涉及小量的记录。应用程序基于某种键来请求记录，而存储引擎使用索引来查找所请求的数据。磁盘寻道时间往往是瓶颈。</li>
<li>由于不直接面对最终用户，数据仓库和类似的分析系统相对并不太广为人知，它们主要由业务分析师使用。处理的查询请求数目远低于OLTP系统，但每个查询通常要求非常苛刻，需要在短时间内扫描百万条记录。磁盘带宽（不是寻道时间）通常是瓶颈，而面向列的存储对于这种工作负载成为日益流行的解决方案。<br>在OLTP方面，有两个主要流派的存储引擎：</li>
<li>日志结构流派：它只允许追加方式更新文件和删除过时的文件，但不会修改已写入的文件。BitCask、SSTable、LST-Tree、LevelDB、Cassandra、HBase、Lucence等属于此类；</li>
<li>原地更新流派：将磁盘视为可以覆盖的一组固定大小的页。B-Tree是这个哲学的最典型代表，它已用于所有主要的关系数据库，以及大量的非关系数据库。</li>
</ul>
<p>日志结构的存储引擎是一个相对较新的方案。其关键思想是系统地将磁盘上随机访问写入转为顺序写入，由于硬盘驱动器和SSD的性能特性，可以实现更高的写入吞吐量。下面将针对这两种存储引擎进行分析。</p>
<h2 id="1-LSM-Tree"><a href="#1-LSM-Tree" class="headerlink" title="1. LSM-Tree"></a>1. LSM-Tree</h2><p>LSM-Tree(Log-Structured Merge Tree)广泛用于key-value存储引擎库中，如LevelDB和RocksDB，类似的存储引擎还用于Cassandra和HBase中，它的主要特征包括：1）数据顺序写入，不支持更新（更新及删除通过压缩合并数据段来实现）；2）数据写入操作内存表，数据异步写入磁盘；3）数据以SSTable段的形式写入磁盘，按照key进行排序，定期对数据段进行压缩合并；4）在内存中建立索引，由于数据段已经排序，只需要记录段首的记录即可。其结构如下所示：<br><img src="/images/lsm-tree.jpg" alt="lsm-tree" title="lsm-tree"></p>
<p>LSM-Tree存储引擎数据存储于SSTables中，一个SSTables表示一个数据段，存储的是key-value值，且按照key进行排序，这种格式也称为排序字符串表。SSTables有两种形式，在内存中，采用的数据结构主要是树状数据结构，如红黑树或AVL树，进行内存排序；内存中的SSTables大于某个阈值时，顺序写入到磁盘中的日志文件中。</p>
<p>LSM-Tree存储引擎的工作流程如下：</p>
<ul>
<li>当写入时，将其添加到内存中的平衡树数据结构中（例如红黑树）。这个内存中的树有时也被称为内存表；</li>
<li>当内存表大于某个阈值（通常为几兆字节）时，将其作为SSTable文件写入到磁盘。由于树已经维护了按照key排序的key-value对，写磁盘可以比较高效。新的SSTable文件成为数据库的最新部分。当SSTable写磁盘的同时，写入可以继续添加到一个新的内存表实例；</li>
<li>为了处理读请求，首先尝试在内存表中查找key,然后是最新的磁盘段文件，接下来是次新的磁盘段文件，以此类推，直到找到目标；</li>
<li>后台进程周期性执行段合并及压缩过程，以合并多个段文件，并丢弃那些已经被覆盖或删除的值；</li>
<li>每个写入操作都会立即追加到一个WAL日志文件中，它记录了操作的内容，它的目的是在数据库崩溃之后恢复内存表，每当将内存表写入SSTable时，相应的日志可以被丢弃。</li>
</ul>
<p>数据库运行一段时间之后，磁盘上会生成多个SSTable文件，一个key可以包含在多个SSTable文件中，即一个key可以有多个版本。后台进程使用合并排序算法周期性地合并数据段，如下图所示。并发读取多个输入段文件，比较每个文件的第一个key，把最小的key（根据排序文件）拷贝到输出文件，并重复这个过程，最后会产生一个新的按key排序的合并段文件。当多个段包含相同的key时，可以保留最新段的值，并丢弃旧段中的值。<br>在文件中查找特定的key时，不需要在内存中保存所有key的索引，因为段是排序的，只需要一个内存索引来记录段首的key，可以减少内存的占用，同时可以进行区间查询。由于读请求往往需要扫描请求范围内的多个key-value对，可以考虑将这些记录保存到一个磁盘块中并在写磁盘前将其压缩。然后内存索引的每个条目指向压缩块的开关。除了节省磁盘空间，压缩还减少了I/O带宽的占用。</p>
<p><img src="/images/lsm-tree-combine.jpg" alt="lsm-tree-combine" title="lsm-tree-combine"></p>
<p>查找数据库中某个不存在的key时，LSM-Tree算法可能很慢：在确定key不存在之前，必须先检查内存表，然后将段一直回溯访问到最旧的段文件（可能必须从磁盘多次读取），为了优化这种访问，存储引擎通常使用额外的布隆过滤器。</p>
<h2 id="2-B-Tree"><a href="#2-B-Tree" class="headerlink" title="2. B-Tree"></a>2. B-Tree</h2><p>B-Tree是关系数据库中被广泛使用的索引结构，像SSTable一样，B-Tree留按照key排序的key-value对，这样可以实现高效的key-value查找和区间查询。从本质上来说，B-Tree具有非常不同的设计理念。<br>在LSM-Tree中，日志结构索引将数据库分解为可变大小的段，通常大小为几兆字节或更大，并且始终按顺序写入段。相比之下，B-Tree将数据库分解为固定大小的块或页，传统上大小为4 KB（有时更大），页是内部读/写的最小单元。这种设计更接近底层硬件，因为磁盘也是以固定大小的块排列。<br>每个页面都可以使用地址或位置进行标识，这样可以让一个页面引用另一个页面，类似指针，不过是指向磁盘地址，而不是内存，可以使用这些页面引用来构造一个树状页面，如下所示。<br><img src="/images/b-tree.jpg" alt="b-tree" title="b-tree"><br>某一页被指定为B-Tree的根，每当查找索引中的一个key时，总是从这里开始。该页面包含若干个key和对子页的引用。每个孩子都负责一个连续范围内的key,相邻引用之间的key可以指示这些范围之间的边界。<br>假定正在查找key 251,需要沿着200~300间的页引用，到达类似的页，它进一步将200~300范围分解成子范围。最终到达一个包含单个key的页(叶子页)，该页包含每个内联key的值或包含找到值的页的引用。<br>B-Tree中每一个页所包含的子页引用数量称为分支因子，例如在上图中，分支因子为6，在实际中，分支因子取决于存储页面引用和范围过界所需的空间总量，通常为几百个。<br>在正常情况下，数据库表一般只包含一个主键索引，如上图中以user_id为主键的索引。在主键索引中根据叶子结点中存储记录的内容还是引用，可以分为聚集索引和非聚集索引，而二级索引引用主键，如下图所示，在user_name上建立一个二级索引，它引用的值是主键。<br><img src="/images/b-tree-index.jpg" alt="b-tree-index" title="b-tree-index"></p>
<p>如果更新B-Tree中原有的值，首先搜索包含该key的叶子页，更改该页的值，并将页定回到磁盘（对该页的任何引用仍然有效）。如果要添加新key，则需要找到其范围包含新key的页，并将其添加到该页，如果页中没有足够的可用空间来容纳新key，则将其分裂为两个半满的页，并且父页也需要更新以包含分裂之后的新key范围，如下图所示：<br><img src="/images/b-tree-split.jpg" alt="b-tree-split" title="b-tree-split"><br>该算法确保树保持平衡：具有n个key的B-Tree总是具有O(log n)的深度，大多数数据库可以适合3~4层的B-Tree，因此不需要遍历非常深的页面层次即可找到所需的页（分支因子为500的4 KB页的四级树可以存储高达256 TB）。</p>
<p>为了使数据库能从崩溃中恢复，常见的B-Tree的实现需要支持磁盘上的额外的数据结构：预写日志（Write-ahead log,WAL），也称为重做日志。这是一个仅支持追加修改的文件，每一个B-Tree的修改必须先更新WAL然后再修改树本身的页。当数据库在崩溃后需要恢复时，该日志用于将B-Tree恢复到最近一致的状态。</p>
<h2 id="3-对比B-Tree和LSM-Tree"><a href="#3-对比B-Tree和LSM-Tree" class="headerlink" title="3. 对比B-Tree和LSM-Tree"></a>3. 对比B-Tree和LSM-Tree</h2><p>根据经验，LSM-Tree通常对于写入更快，而B-Tree被认为对于读取更快。读取通常在LSM-Tree上较慢，主要是因为它们必须在不同的压缩阶段检查多个不同的数据结构和SSTable。</p>
<h3 id="3-1-磁盘写入"><a href="#3-1-磁盘写入" class="headerlink" title="3.1 磁盘写入"></a>3.1 磁盘写入</h3><p>B-Tree索引必须至少写两次数据：一个写入预写日志，一次写入树的页本身（还可能发生页分裂）。即使该页中只有几个字节更改，也必须承受整个页的开销。另外，B-Tree存储引擎使用与磁盘类似的分页结构，存在磁盘的碎片化。<br>LSM-Tree数据通常是写入内存表，内存表达到一定阈值的时候再统一写入磁盘，对于磁盘上的SStable段文件由后台线程进行合并压缩，效率更高，同时也会减少磁盘碎片。相对B-Tree来说，具有更高的写入吞吐量。</p>
<h3 id="3-2-事务支持"><a href="#3-2-事务支持" class="headerlink" title="3.2 事务支持"></a>3.2 事务支持</h3><p>B-Tree的优点则是每个键都恰好唯一对应于索引中的某个位置，而日志结构的存储引擎可能在不同的段中具有相同键的多个副本。如果数据库希望提供强大的事务语义，B-Tree显得更具吸引力：在许多关系数据库，事务隔离是通过键范围上的锁来实现的，并且在B-Tree索引中，这些锁可以直接定义到树中。</p>
<p><strong>参考：</strong></p>
<hr>
<p><a href="https://book.douban.com/subject/30329536/" target="_blank" rel="noopener">1. 数据密集型应用系统设计</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Noahsark</p>
              <p class="site-description motion-element" itemprop="description">不畏将来，不念过往</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">36</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">19</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">130</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Noahsark</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数">296k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
    <span title="站点阅读时长">4:29</span>
  
</div>

<div class="BbeiAn-info">
    <a target="_blank" href="https://beian.miit.gov.cn/" rel="nofollow">粤ICP备 2021097726号-1 </a>
	<a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44030702004132" style="text-decoration:none;padding-left:30px;background:url(https://s1.ax1x.com/2018/09/29/ilmwIH.png) no-repeat left center" rel="nofollow">粤公网安备 44030702004132号</a>
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v6.5.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.5.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.5.0"></script>



  



  










  





  

  

  

  

  

  
  

  

  

  

  

  

  

</body>
</html>
