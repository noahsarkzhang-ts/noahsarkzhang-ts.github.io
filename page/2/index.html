<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.5.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.5.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.5.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.5.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="不畏将来，不念过往">
<meta name="keywords" content="Java">
<meta property="og:type" content="website">
<meta property="og:title" content="以太格">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="以太格">
<meta property="og:description" content="不畏将来，不念过往">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="以太格">
<meta name="twitter:description" content="不畏将来，不念过往">






  <link rel="canonical" href="http://yoursite.com/page/2/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>以太格</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">以太格</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-commonweal">

    
    
    
      
    

    

    <a href="/404/" rel="section"><i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>公益 404</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于我</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/14/alligator-heartbeat-detection/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2021/08/14/alligator-heartbeat-detection/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">Alligator 系列：心跳检测</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2021-08-14 17:30:36" itemprop="dateCreated datePublished" datetime="2021-08-14T17:30:36+08:00">2021-08-14</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-08-21 23:12:07" itemprop="dateModified" datetime="2021-08-21T23:12:07+08:00">2021-08-21</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Alligator网关/" itemprop="url" rel="index"><span itemprop="name">Alligator网关</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">8.8k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">8 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>在长连接系统中，客户端及服务器之间需要通过发送心跳包来感知对方的存活状态，一般来说，心跳包不承载业务信息，不过在一些场景中，会把当前服务的状态推送给对方。在 Alligator 系统中统一在客户端发送心跳包，服务器会检测当前连接的空闲时间（即多久未收到数据），若超过一定时间，则判定为连接断线。在客户端，会检测连接的空闲写时间，超过一定时间，则触发发送心跳包，同时对服务端的响应做计数，超时一定次数未收到心跳响应，则判定服务器下线，触发重连操作。在注册中心系统中，客户端发送的心跳包中，会带上当前客户端的负载信息（连接数或用户数），注册中心根据这些负载信息，可以实现流量的有效负载。</p>
<h2 id="2-具体实现"><a href="#2-具体实现" class="headerlink" title="2. 具体实现"></a>2. 具体实现</h2><h3 id="2-1-客户端"><a href="#2-1-客户端" class="headerlink" title="2.1 客户端"></a>2.1 客户端</h3><p>客户端主要包含两个操作：</p>
<ol>
<li>借助 IdleStateHandler 触发一个连接空闲事件；</li>
<li>添加一个 Handler，捕获空闲事件，发送心跳包。</li>
</ol>
<p>在第一个步骤中，使用 Netty 提供的 IdleStateHandler 类来实现连接通道空闲状态的检测，当空闲时间超过设置的数值之后，触发一个连接空闲状态的用户事件。在该类中，提供了读空闲、写空闲或两者时间的配置。在业务中，可以根据具体情况进行设置。在这里，主要是配置写空闲时间。当连接超过一写时间（如 15S）没有写数据，则触发事件，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">pipeline.addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">0</span>, <span class="number">15</span>, <span class="number">0</span>));  <span class="comment">// 设置写空间时间为 15 S</span></span><br><span class="line">pipeline.addLast(<span class="keyword">new</span> ClientIdleStateTrigger(<span class="keyword">this</span>.client));</span><br></pre></td></tr></table></figure>
<p>连接空闲状态的检测是通过向 EventLoop 中加入一个定时任务来实现的，如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ScheduledFuture&lt;?&gt; schedule(ChannelHandlerContext ctx, Runnable task, <span class="keyword">long</span> delay, TimeUnit unit) &#123;</span><br><span class="line">    <span class="keyword">return</span> ctx.executor().schedule(task, delay, unit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>触发了一个空闲写事件之后，第二步是需要定义一个 Handler 类来处理该事件，一般在该 Handler 类中有两类操作：1）判断计数，如果超过一定次数，触发服务器重连操作；2）发送心跳包</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">        IdleState state = ((IdleStateEvent) evt).state();</span><br><span class="line">        <span class="keyword">if</span> (state == IdleState.WRITER_IDLE) &#123;</span><br><span class="line"></span><br><span class="line">            log.info(<span class="string">"Idle timeout,send heart beat!"</span>);</span><br><span class="line"></span><br><span class="line">            HeartbeatStatus heartbeatStatus = remotingClient.getConnectionManager()</span><br><span class="line">                .getHeartbeatStatus();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (heartbeatStatus.incAndtimeout()) &#123;  <span class="comment">// 1. 心跳计数加 1，如果超过 3 次，触发切换服务器操作。</span></span><br><span class="line">                log.info(<span class="string">"server time out, and toggle server"</span>);</span><br><span class="line"></span><br><span class="line">                heartbeatStatus.reset();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.remotingClient.toggleServer();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.remotingClient.ping();  <span class="comment">// 2. 发送心跳。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>心跳计数在收到心跳响应之后会被重置为 0。</p>
<p>在 Websoket 协议中，已经定义了心跳的格式，如 ping/pong。客户端只要发送 ping 包就行，在 TCP 协议中，需要自己定义消息格式。在 Alligator 系统中，统计定义了一套消息格式，后续文章再补充，其中使用一个特定的命令字段来表示心跳信息，同时业务上，可以根据使用场景的不同，可以自定义心跳包中承载的内容，如负载信息。</p>
<h3 id="2-2-服务器"><a href="#2-2-服务器" class="headerlink" title="2.2 服务器"></a>2.2 服务器</h3><p>服务器代码则相应的检测连接的读空闲时间，如果没有收到读数据一定时间之后，则触发读空闲事件，服务器会进行连接的清理工作。代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 设置读空闲时间为 45S，如果 45S内，没有收到请示数据，则触发读空闲事件。</span></span><br><span class="line">pipeline.addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">45</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">pipeline.addLast(<span class="keyword">new</span> ServerIdleStateTrigger());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 事件处理逻辑</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerIdleStateTrigger</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">            IdleState state = ((IdleStateEvent) evt).state();</span><br><span class="line">            <span class="keyword">if</span> (state == IdleState.READER_IDLE) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 连接超过，删除会话</span></span><br><span class="line">                SessionManager.getInstance().disconnect(ctx);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>Netty 为心跳的处理、连接的超时提供较好的支持，充分理解这些组件，可以有效地提高开发效率。</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/07/31/alligator-gateway-overview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2021/07/31/alligator-gateway-overview/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">Alligator 序列：长连接网关概述</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2021-07-31 19:58:01" itemprop="dateCreated datePublished" datetime="2021-07-31T19:58:01+08:00">2021-07-31</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-08-21 23:12:07" itemprop="dateModified" datetime="2021-08-21T23:12:07+08:00">2021-08-21</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Alligator网关/" itemprop="url" rel="index"><span itemprop="name">Alligator网关</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">1.5k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">1 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>在项目中经常遇到双向通信的场景，如指令的实时下发、状态的上报等，这时候使用 HTTP 协议就有点捉襟见肘。正常情况下一般会使用 TCP/Websocket 协议来实现，不过不同于 HTTP 协议简单及有大量框架的支持，使用 TCP/Websocket 需要考虑心跳、协议的定义、数据的序列化（反序列化）及 RPC 调用的实现。相对来说，入门相对比较复杂。 如果能有一个项目能够对上述功能进行封装，隐藏不同协议之间的差异，对上层应用提供一套统一的接口，上层业务只关心业务，那么就会减少开发人员的学习成本，快速接入项目。<br>Alligator 项目就是为了解决上述的场景而开发的，它提供了一个框架，可以让开发人员快速进行 TCP/Websocket 及 HTTP 的开发，而无需关心下层使用的协议。在此基础上，Alligator 还提供了一个进行长连接网关开发的脚手架，它是业务无关的，可以快速接入不同的业务场景。</p>
<h2 id="2-架构"><a href="#2-架构" class="headerlink" title="2. 架构"></a>2. 架构</h2><p><img src="/images/alligator/alligator-architecture.jpg" alt="alligator-architecture" title="alligator-architecture"></p>
<p>模块说明：</p>
<ul>
<li>注册中心：实现服务的注册、发现及负载功能；</li>
<li>TCP 网关：接入 TCP 协议客户端，实现用户的登陆、退出及消息的转发功能，同时它维护了客户端及网关之间的 Session 信息；</li>
<li>WEBSOCKET 网关：功能同 TCP 网关，接入 WEBSOCKET 协议的客户端；</li>
<li>HTTP/HTTP2 网关：实现 HTTP/HTTP2 协议的接入；</li>
<li>在线服务：接收用户登陆/退出事件，实现用户的在线维护功能；</li>
<li>聊天服务：实现聊天功能；</li>
<li>MQ 服务：实现消息的存储及转发功能；</li>
</ul>
<p>系统特点：</p>
<ul>
<li>全异步编程：所有模块使用全异步通信，能有效提高模块的吞吐量；</li>
<li>RPC 通信：实现 request - response ，oneway ，request - streaming（待开发） 三种双向通信模式；</li>
<li>消息存储及路由：使用 MQ 进行消息的存储及路由，减少模块之间的耦合；</li>
<li>业务无关：对底层模块进行了统一地抽象及封装，业务人员可以专注业务开发；</li>
</ul>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>Alligator 不仅提供了一个快速进行长连接开发的框架，同时还提供了一个开发脚手架，让长连接网关开发不再是一件困难的事。后续将出一个序列专门介绍其底层实现；</p>
<p><a href="https://github.com/noahsarkzhang-ts/alligator" target="_blank" rel="noopener">工程代码</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/07/24/Use-nginx-to-publish-a-website/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2021/07/24/Use-nginx-to-publish-a-website/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">用 Nginx 发布网站</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2021-07-24 21:49:11" itemprop="dateCreated datePublished" datetime="2021-07-24T21:49:11+08:00">2021-07-24</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-07-31 20:04:21" itemprop="dateModified" datetime="2021-07-31T20:04:21+08:00">2021-07-31</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/hexo/" itemprop="url" rel="index"><span itemprop="name">hexo</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">9.5k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">9 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>之前买了一台阿里云的云主机，一直想把用起来。考虑到我的个人网站之前部署在 github 上，网页加载比较慢，正好可以用云主机进行部署，提升速度，开始操作。</p>
<h2 id="1-前置条件"><a href="#1-前置条件" class="headerlink" title="1. 前置条件"></a>1. 前置条件</h2><ul>
<li>购买云主机</li>
<li>购买域名</li>
<li>申请免费证书</li>
<li>网站备案</li>
<li>用 nginx 发布网站</li>
</ul>
<p>前面的四个环节，参考阿里云的帮助文档操作即可，这篇文章主要讲述第五步：用 nginx 发布网站。</p>
<h2 id="2-用-Docker-安装-nginx"><a href="#2-用-Docker-安装-nginx" class="headerlink" title="2. 用 Docker 安装 nginx"></a>2. 用 Docker 安装 nginx</h2><p>执行下面一条命令，即可安装最新版的 nginx。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run \</span><br><span class="line">  -d \</span><br><span class="line">  -p 80:80 \</span><br><span class="line">  --rm \</span><br><span class="line">  --name mynginx \</span><br><span class="line">  nginx</span><br></pre></td></tr></table></figure></p>
<p>参数说明：</p>
<ul>
<li>-d：在后台运行</li>
<li>-p：容器的 80 端口映射到宿主机的 80 端口</li>
<li>–rm：容器停止运行后，自动删除容器文件</li>
<li>–name：容器的名字为 mynginx</li>
</ul>
<p>正常情况下，通过 80 端口便可访问到 nginx 的默认页面。</p>
<p>关闭命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container stop mynginx</span><br></pre></td></tr></table></figure>
<h2 id="3-映射目录文件"><a href="#3-映射目录文件" class="headerlink" title="3. 映射目录文件"></a>3. 映射目录文件</h2><p>网页及配置文件包含在容器里，不方便部署，现在将这两个目录映射到宿主机上，要更新直接在宿主机上更新即可。</p>
<h3 id="3-1-网页目录"><a href="#3-1-网页目录" class="headerlink" title="3.1 网页目录"></a>3.1 网页目录</h3><p>在 nginx 中，网页存放的目录是 /usr/share/nginx/html。在宿主机上建立 /data/blog/html 目录（根据需要随意指定），通过 volume 选项建立映射，命令如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run \</span><br><span class="line">  -d \</span><br><span class="line">  -p 80:80 \</span><br><span class="line">  --rm \</span><br><span class="line">  --name mynginx \</span><br><span class="line">  --volume /data/blog/html:/usr/share/nginx/html \</span><br><span class="line">  nginx</span><br></pre></td></tr></table></figure></p>
<h3 id="3-2-配置文件目录"><a href="#3-2-配置文件目录" class="headerlink" title="3.2 配置文件目录"></a>3.2 配置文件目录</h3><p>nginx 的配置文件目录在 /etc/nginx 下，先将其复制到宿主机目录下，再建立映射。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir /data/nginx</span><br><span class="line">$ <span class="built_in">cd</span> /data/nginx</span><br><span class="line"></span><br><span class="line">$ docker container cp mynginx:/etc/nginx .x</span><br><span class="line"></span><br><span class="line">$ mv nginx conf</span><br></pre></td></tr></table></figure></p>
<p>上面的命令将把 mynginx 容器的 /etc/nginx 拷贝到 /data/nginx 目录下，形成的目录是 /etc/nginx/nginx，最后将最后一个 nginx 目录改为 conf 目录。</p>
<p>最后使用如下命令建立映射：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run \</span><br><span class="line">  -d \</span><br><span class="line">  -p 80:80 \</span><br><span class="line">  --rm \</span><br><span class="line">  --name mynginx \</span><br><span class="line">  --volume /data/blog/html:/usr/share/nginx/html \</span><br><span class="line">  --volume /data/nginx/conf:/etc/nginx \</span><br><span class="line">  nginx</span><br></pre></td></tr></table></figure></p>
<h2 id="4-配置-HTTPS-证书"><a href="#4-配置-HTTPS-证书" class="headerlink" title="4. 配置 HTTPS 证书"></a>4. 配置 HTTPS 证书</h2><p>在阿里云申请到 SSL 证书之后，会得到两个文件：1）证书文件（以 cert-file-name.pem 为例）； 2）私钥文件（以 cert-file-name.key 为例）。<br>在 /data/nginx/conf 目录下新建一个 certs 目录，将上述文件复制到该目录下，修改 /data/nginx/conf/nginx.conf 文件，将页面的配置片断加入到 http 选项中，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	server &#123;</span><br><span class="line">		listen 443 ssl;</span><br><span class="line">		<span class="comment">#配置HTTPS的默认访问端口为443。</span></span><br><span class="line">		<span class="comment">#如果未在此处配置HTTPS的默认访问端口，可能会造成Nginx无法启动。</span></span><br><span class="line">		<span class="comment">#如果您使用Nginx 1.15.0及以上版本，请使用listen 443 ssl代替listen 443和ssl on。</span></span><br><span class="line">		server_name yourdomain.com; <span class="comment">#需要将yourdomain.com替换成证书绑定的域名。</span></span><br><span class="line">		root /usr/share/nginx/html;</span><br><span class="line">		index index.html index.htm;</span><br><span class="line">		ssl_certificate certs/cert-file-name.pem;  <span class="comment">#需要将cert-file-name.pem替换成已上传的证书文件的名称。</span></span><br><span class="line">		ssl_certificate_key certs/cert-file-name.key; <span class="comment">#需要将cert-file-name.key替换成已上传的证书密钥文件的名称。</span></span><br><span class="line">		ssl_session_timeout 5m;</span><br><span class="line">		ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">		<span class="comment">#表示使用的加密套件的类型。</span></span><br><span class="line">		ssl_protocols TLSv1 TLSv1.1 TLSv1.2; <span class="comment">#表示使用的TLS协议的类型。</span></span><br><span class="line">		ssl_prefer_server_ciphers on;</span><br><span class="line">		location / &#123;</span><br><span class="line">			root /usr/share/nginx/html;  <span class="comment">#站点目录。</span></span><br><span class="line">			index index.html index.htm;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 设置HTTP请求自动跳转HTTPS</span></span><br><span class="line">	server &#123;</span><br><span class="line">		listen 80;</span><br><span class="line">		server_name yourdomain.com; <span class="comment">#需要将yourdomain.com替换成证书绑定的域名。</span></span><br><span class="line">		rewrite ^(.*)$ https://<span class="variable">$host</span><span class="variable">$1</span>; <span class="comment">#将所有HTTP请求通过rewrite指令重定向到HTTPS。</span></span><br><span class="line">		location / &#123;</span><br><span class="line">			index index.html index.htm;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>开放 HTTPS 443 端口，命令如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run \</span><br><span class="line">  -d \</span><br><span class="line">  -p 80:80 \</span><br><span class="line">  -p 443:443 \</span><br><span class="line">  --rm \</span><br><span class="line">  --name mynginx \</span><br><span class="line">  --volume /data/blog/html:/usr/share/nginx/html \</span><br><span class="line">  --volume /data/nginx/conf:/etc/nginx \</span><br><span class="line">  nginx</span><br></pre></td></tr></table></figure></p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>最后将 hexo public 目录下的文件复制到 /data/blog/html 即可。 </p>
<p><strong>参考：</strong></p>
<hr>
<p><a href="https://www.ruanyifeng.com/blog/2018/02/nginx-docker.html" target="_blank" rel="noopener">1. Nginx 容器教程</a><br><a href="https://help.aliyun.com/document_detail/98728.html" target="_blank" rel="noopener">2. 在Nginx（或Tengine）服务器上安装证书</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/14/network-model-of-k8s/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2021/02/14/network-model-of-k8s/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">思维导图-容器网络模型</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2021-02-14 19:27:24" itemprop="dateCreated datePublished" datetime="2021-02-14T19:27:24+08:00">2021-02-14</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-07-31 17:17:10" itemprop="dateModified" datetime="2021-07-31T17:17:10+08:00">2021-07-31</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">153</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">1 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇文章是学习刘超老师在“极客时间”的课程《趣谈网络协议》之后，做的一个总结。<br><img src="/images/container/container-network.jpeg" alt="container-network" title="container-network"></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/14/laws-and-principles/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2021/02/14/laws-and-principles/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">法则及基本原则</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2021-02-14 10:06:31" itemprop="dateCreated datePublished" datetime="2021-02-14T10:06:31+08:00">2021-02-14</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-07-31 17:17:10" itemprop="dateModified" datetime="2021-07-31T17:17:10+08:00">2021-07-31</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/法则/" itemprop="url" rel="index"><span itemprop="name">法则</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">1.3k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">1 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇文章主要是记录一些生活或工作中基本原则，方便后续查看及思考。</p>
<p><strong>1. 海因里希法则（Hainrich’s law）</strong><br>美国安全工程师海因里希，在分析工伤事故后发现：<strong style="color:red">每一起严重事故的背后，必然有 29 次轻微事故、300 起未遂先兆以及 1000 起事故隐患…</strong></p>
<p><strong>2. 墨菲定律（Murphy’s Law）</strong><br><strong style="color:red">“凡是可能出错的事就一定会出错”</strong>，指的是任何一个事件，只要具有大于零的几率，就可确定它终有一天会发生。</p>
<p><strong>3. 学习金字塔（Learning Pyramid）</strong><br>“学习金字塔”是美国学者艾德加·戴尔 1946 年发现的。是强调自主学习理论依据。美国缅因州国家科学实验室做过类似的研究，他们的金字塔如图如下：<br><img src="/images/law/learning-pyramid.jpg" alt="learning-pyramid" title="learning-pyramid"><br>学习金字塔理论告诉我们，不同的学习方法达到的学习效果不同，研究表明在两周之后，学生对知识的保持率，从5%至90%不等：<br>用耳朵听讲授，知识保留5%，用眼去阅读，知识保留10%，视听结合，知识保留20%，用演示的办法，知识保留30%分组，讨论法，知识保留50%，练习操作实践，知识保留75%，向别人讲授相互教，快速使用，知识保留90%。</p>
<p><strong>4. 邓宁-克鲁格效应（Dunning-Kruger Effect）</strong><br>邓宁-克鲁格效应（Dunning-Kruger effect），或简称达克效应（DK effect），是一种认知偏差，能力欠缺的人有一种虚幻的自我优越感，错误地认为自己比真实情况更加优秀。美国康乃尔大学的社会心理学家大卫·邓宁和贾斯汀·克鲁格将其归咎于认知上的缺陷，能力欠缺的人无法认识到自身的无能，不能准确评估自身的能力。他们的研究还表明，反之，非常能干的人会低估自己的能力，错误地假定他们自己能够很容易完成的任务，别人也能够很容易地完成。<br><img src="/images/law/dunning-kruger-effect.jpg" alt="dunning-kruger-effect" title="dunning-kruger-effect"></p>
<p><strong>参考：</strong></p>
<hr>
<p><a href="https://zh.wikipedia.org/wiki/%E9%84%A7%E5%AF%A7-%E5%85%8B%E9%AD%AF%E6%A0%BC%E6%95%88%E6%87%89" target="_blank" rel="noopener">1. 邓宁-克鲁格效应</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/31/mysql-log/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2021/01/31/mysql-log/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">Mysql 事务日志</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2021-01-31 17:56:29" itemprop="dateCreated datePublished" datetime="2021-01-31T17:56:29+08:00">2021-01-31</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-07-31 17:17:10" itemprop="dateModified" datetime="2021-07-31T17:17:10+08:00">2021-07-31</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据库/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">13k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">12 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>在 Mysql 中，存储有三种日志，分别是 binlog log、undo log及 redo log，其中 binlog 日志由 Mysql Server 生成，用来记录对数据库的更新操作，使用场景有主从同步及数据恢复；undo log及 redo log由 Innodb 存储引擎生成，用于保障事务进行。undo日志用于事务的回滚及MVCC，实现事务的原子性，而 redo log基于 WAL（ Write-Ahead Logging） 技术，存储事务过程中对数据表的修改，主要是数据页的修改，保证了事务的持久性。这三种日志在数据库表的更新操作（包括新增、修改及删除）中，相互配合，保障了事务的顺利执行，下图以一次数据更新操作演示了它们的工作机制。<br><img src="/images/mysql-log/mysql-transaction-overview.jpg" alt="mysql-transaction-overview" title="mysql-transaction-overview"></p>
<ol>
<li>undo log 存储在系统表空间中（新版的 Mysql 已经可以设置独立的表空间），对 undo log 的更改同样记录到 redo log中；</li>
<li>redo log 由独立的日志文件存储，日志文件只有追加操作，顺序写入到磁盘中，相比数据页的随机写入，具有较高的效率；</li>
<li>binlog log 配合 redo log，实现了内部的 XA 协议，保证了数据在 Innodb 及 Mysql 之间的一致性。</li>
</ol>
<h2 id="2-基础概念"><a href="#2-基础概念" class="headerlink" title="2. 基础概念"></a>2. 基础概念</h2><p><strong>内存缓冲池</strong><br>如果 Mysql 不使用内存缓冲池，每次读取数据时，都需要访问磁盘，会大大的增加磁盘的 IO 请求，导致效率低下；Innodb 引擎在读取数据的时候，把相应的数据和索引载入到内存的缓冲池（buffer pool）中，一定程度的提高了数据的读写速度。</p>
<p><strong>buffer pool</strong><br>用来存放各种数据的缓存，这些数据包括：索引页、数据页、undo 页、插入缓冲、自适应哈希索引、Innodb 存储的锁信息及数据字典等。工作方式是将数据库文件按照页（每页16k）读取到缓冲池，然后按照最近最少使用算法（LRU）来保留缓冲池中的缓冲数据。如果数据库文件需要修改，总是首先修改在缓冲池中的页（发生修改后即成为脏页），然后在按照一定的频率将缓冲池中的脏页刷新到文件。</p>
<p><strong>表空间</strong><br>表空间可以看作是 InnoDB 存储引擎 逻辑结构的最高层。表空间文件：InnoDB默认的表空间文件为 ibdata1。</p>
<ul>
<li>页：每页数据为16kb，且不能进行修改。常见的页类型有：数据页，Undo页，系统页，事务数据页，插入缓冲位图页，插入缓冲空闲列表页，未压缩的二进制大对象页，压缩的二进制大对象页</li>
<li>区：由64个连续的页组成，每个页大小为16kb，即每个区的大小为1024kb即1MB</li>
<li>段：表空间由各个段组成，常见的段有数据段，索引段，回滚段（undo log段）等。</li>
</ul>
<h2 id="3-redo-log"><a href="#3-redo-log" class="headerlink" title="3. redo log"></a>3. redo log</h2><p>缓存技术是一种常用的性能优化技术，在 Mysql 中，使用 Buffer Pool 来缓存表数据，它是以数据页为单位。引入缓存，也会引入同步数据到磁盘的问题，如果每一个事务都同步数据，由于一个事务可能涉及到数据面，同步数据的操作是一个随机 IO 的操作，性能损耗很大。为了解决问题，使用了WAL（ Write-Ahead Logging）技术，引入 redo log。它的基本思想是：将数据页修改写入 redo log，日志文件是顺序写入，性能很高，同时Buffer Pool 数据异步写入磁盘。通过 redo log，即使 Mysql 宕机，也可以通过 redo log 进行恢复。</p>
<p>redo log由两部分组成：</p>
<ol>
<li>redo log缓冲区 Log Buffer；</li>
<li>redo log日志文件，在 InnoDB 中，redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，从头开始写，写到末尾又回到开头循环写，如下图所示：<br><img src="/images/mysql-log/undo-circle.png" alt="undo-circle" title="undo-circle"></li>
</ol>
<p>write pos 是当前记录的位置，一边写一边后移动，写到第 3 号文件末尾后就回到 0 号文件开头。checkpoint 是当前要删除的位置，也是往后推移并且循环的，删除记录前要把记录更新到数据文件。<br>write pos 和 checkpoint 之间的部分可以用来记录新的操作。如果 write pos 追上 checkpoint，表示文件满了，这时候不能再执行新的更新，需要先删除一些记录，把 checkpoint 推进一下。<br>有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 crash-safe。<br>另外，为了实现数据完整性，在 Buffer Pool 刷新到磁盘之前，必须先把 redo log 写入到磁盘。除了数据页，聚集索引、辅助索引以及 undo log 都需要记录到 redo log中。</p>
<p><strong>redo log的记录内容</strong><br>undo log和 redo log 本身是分开的。Innodb 的 undo log 是记录在数据文件（系统表空间）中的，而且 innodb 将 undo log 的内容看做是数据，因此对undo log本身的操作（如向undo log插入一条undo log记录等），都会记录到redo log。undo log 可以通过redo log 将其恢复。因此当数据表插入一条记录时，涉及到的操作如下所示：</p>
<ul>
<li>向 undo log 插入一条 undo log 记录；</li>
<li>向 redo log 中插入一条 “插入 undo log 记录”的redo log记录；</li>
<li>Buffer Pool 中插入数据 （异步同步到磁盘）；</li>
<li>向 redo log 插入一条 “insert” 的 redo log记录。</li>
</ul>
<p><strong>redo log 参数</strong></p>
<ul>
<li><p>innodb_log_files_in_group<br>redo log 文件的个数，命名方式如：ib_logfile0，iblogfile1… iblogfilen。默认2个，最大100个。</p>
</li>
<li><p>innodb_log_file_size<br>文件设置大小，默认值为 48M，最大值为512G，注意最大值指的是整个 redo log系列文件之和，即（innodb_log_files_in_group * innodb_log_file_size ）不能大于最大值512G。</p>
</li>
<li><p>innodb_log_group_home_dir<br>文件存放路径</p>
</li>
<li><p>innodb_log_buffer_size<br>redo Log 缓存区，默认8M，可设置1-8M。延迟事务日志写入磁盘，把redo log 放到该缓冲区，然后根据 innodb_flush_log_at_trx_commit参数的设置，再把日志从buffer 中flush 到磁盘中。</p>
</li>
<li><p>innodb_flush_log_at_trx_commit</p>
<ul>
<li>innodb_flush_log_at_trx_commit=1，每次commit都会把redo log从redo log buffer写入到system，并fsync刷新到磁盘文件中。</li>
<li>innodb_flush_log_at_trx_commit=2，每次事务提交时MySQL会把日志从redo log buffer写入到system，但只写入到file system buffer，由系统内部来fsync到磁盘文件。如果数据库实例crash，不会丢失redo log，但是如果服务器crash，由于file system buffer还来不及fsync到磁盘文件，所以会丢失这一部分的数据。</li>
<li>innodb_flush_log_at_trx_commit=0，事务发生过程，日志一直激励在redo log buffer中，跟其他设置一样，但是在事务提交时，不产生redo 写操作，而是MySQL内部每秒操作一次，从redo log buffer，把数据写入到系统中去。如果发生crash，即丢失1s内的事务修改操作。</li>
</ul>
</li>
</ul>
<h2 id="4-undo-log"><a href="#4-undo-log" class="headerlink" title="4. undo log"></a>4. undo log</h2><p>Innodb 为了支持回滚和 MVCC，需要备份旧数据，undo log 就负责存储这些数据，在操作任何数据之前，首先将数据备份到undo log，然后进行数据的修改。如果出现了错误或者用户手动执行了 rollback，系统可以利用 undo log 中的备份将数据恢复到事务开始之前的状态。与 redo log不同的是，磁盘上不存在单独的 undo log 文件，它存放在数据库内部的特殊段（segment）中，这称之为 undo 段（undo segment），undo 段位于共享表空间内。<br><img src="/images/mysql-log/undo-tablespace.png" alt="undo-tablespace" title="undo-tablespace"></p>
<p>其中32个rollback segment创建在临时表空间中，96个创建在系统表空间中，每一个rollback segment可以分配 1024个 slot，也就是可以支持96*1024个并发的事务。</p>
<h3 id="4-1-undo-log-类型"><a href="#4-1-undo-log-类型" class="headerlink" title="4.1 undo log 类型"></a>4.1 undo log 类型</h3><p>undo log有两种类型，分别是 insert undo log 和 update undo log。前者记录的是insert 语句对应的undo log，后者对应的是 update、delete 语句对应的undo log。</p>
<ol>
<li><p>insert undo log<br>nsert undo log 只对事务本身可见，所以insert undo log在事务提交后可直接删除，无需通过 purge 线程执行清理操作。insert undo log 包含的字段如下：<br><img src="/images/mysql-log/insert-undo-log.jpg" alt="insert-undo-log" title="insert-undo-log"></p>
</li>
<li><p>update undo log<br>执行 update 或者 delete 会产生 undo log，会影响已存在的记录，为了实现MVCC，会将同一个记录的多个版本的 undo log 串联起来，根据隔离级别的不同，会看到不同版本的数据，update undo log 不能在事务提交时立刻删除，需要等待 purge 线程进行最后的删除操作。如果是长事务，会产生大量的 undo log。undo log 包含的字段如下：<br><img src="/images/mysql-log/update-undo-log.jpg" alt="update-undo-log" title="update-undo-log"></p>
</li>
</ol>
<h3 id="4-2-事务回滚"><a href="#4-2-事务回滚" class="headerlink" title="4.2 事务回滚"></a>4.2 事务回滚</h3><p>事务根据 sql的类型，进行相应的处理：</p>
<ul>
<li>insert sql : 在 undo log 中记录下 insert 进来的数据的 ID，当 rollback 时，根据 ID 完成精准的删除；</li>
<li>delete sql ：在 undo log 中记录删除的数据，当回滚时会将删除前的数据 insert 进去；</li>
<li>update sql ：在 undo log 中记录下修改前的数据，回滚时只需要反向update即可；</li>
<li>select sql ：select不需要回滚。</li>
</ul>
<p>对于 insert 类型的 undo log，由于只对当前事务可见（没有事务会对还未插入的数据感兴趣），在事务提交之后该 undo log就会被删除。但对于 update 类型的 undo log 来说，该操作会影响当前的记录，由于同时可能会有多个事务对当前记录进行 update 操作，Innodb 使用 DATA_ROLL_ID 指针将多个版本的 undo log 串联起来，而链条的起点则是行记录中的隐藏字段 DB_ROLL_PTR 。</p>
<p>Innodb 为每个记录中记录了三个隐藏字段：</p>
<ul>
<li>6字节的事务ID（DB_TRX_ID）；</li>
<li>7字节的回滚指针（DB_ROLL_PTR）；</li>
<li>隐藏的主键id，如果没有主键，Mysql 自动生成一个主键。</li>
</ul>
<p>以 test 表为例，我们分别进行 insert及upadte 操作来演示 undo log 日志。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`test`</span>(</span><br><span class="line">   <span class="string">`id`</span> <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> AUTO_INCREMENT,</span><br><span class="line">   <span class="string">`a`</span> <span class="built_in">VARCHAR</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">   <span class="string">`b`</span> <span class="built_in">VARCHAR</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">   PRIMARY <span class="keyword">KEY</span> ( <span class="string">`id`</span> )</span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行的操作</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span>(<span class="keyword">id</span>, a, b) <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">'redo'</span>,<span class="string">'undo'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">test</span> <span class="keyword">set</span> a=<span class="string">"redo log"</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<p>其 undo log 链如下所示：<br><img src="/images/mysql-log/undo-log-list.jpg" alt="undo-log-list" title="undo-log-list"><br>如上图，删除的数据行不会立刻删除，而是在行记录头信息记录了一个 deleted_flag 标志位。最终会在 purge 线程 purge undo log 的时候进行实际的删除操作，这个时候undo log也会清理掉。</p>
<h2 id="5-binlog-log"><a href="#5-binlog-log" class="headerlink" title="5. binlog log"></a>5. binlog log</h2><p>binlog 用于记录数据库执行的更新操作(不包括查询)信息，以二进制的形式保存在磁盘中。 binlog 是 Mysql 的逻辑日志，并且由 Server 层进行记录，使用任何存储引擎的 mysql 数据库都会记录 binlog log。</p>
<p><strong>binlog log 格式</strong><br>binlog log 有三种格式，分别为 STATMENT 、 ROW 和 MIXED 。</p>
<ul>
<li>STATMENT ： 基于 SQL 语句的复制( statement-based replication, SBR )，每一条会修改数据的 sql 语句会记录到 binlog 中；</li>
<li>ROW ： 基于行的复制( row-based replication, RBR )，不记录每条 sql 语句的上下文信息，仅需记录哪条数据被修改了；</li>
<li>MIXED ： 基于 STATMENT 和 ROW 两种模式的混合复制( mixed-based replication, MBR )，一般的复制使用 STATEMENT 模式保存 binlog ，对于 STATEMENT 模式无法复制的操作使用 ROW 模式保存 binlog。</li>
</ul>
<p><strong>binlog log 写盘</strong><br>在写 binlog，通过参数 sync_binlog 来控制何时将 binlog fsync到磁盘。</p>
<ul>
<li>0：事务提交是没有立即 fsync 文件到磁盘，而是依赖于操作系统的 fsync 机制；</li>
<li>1：每次 commit 的时候都要将 binlog fsync 磁盘；</li>
<li>N：指定提交次数后，统一fsync到磁盘。</li>
</ul>
<p>要保证数据的可持久性，sync_binlog 必须设置为 1。</p>
<p><strong>使用场景</strong></p>
<ol>
<li>主从同步；</li>
<li>数据恢复。</li>
</ol>
<h2 id="6-内部-XA-协议"><a href="#6-内部-XA-协议" class="headerlink" title="6. 内部 XA 协议"></a>6. 内部 XA 协议</h2><p>从上面的内容可知，一个更新操作需要 Server 及 Innodb 协同完成，一个事务，Server 会写 binlog log， Innodb 会写 redo/undo log，这两部分是怎么保证数据的一致性及数据不丢失？在 Myslq 内部，使用了“两阶段提交”来实现这两个特性， 在此处的“两阶段提交”称为内部的 XA 协议，有别于多数据源的分布式事务。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">test</span> <span class="keyword">set</span> a=<span class="string">'redo'</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>以上面的 update 操作为例，更新的流程如下：<br><img src="/images/mysql-log/two-phase-commit.jpg" alt="two-phase-commit" title="two-phase-commit"></p>
<p><strong>两阶段提交过程</strong><br>MySQL 采用了如下的过程实现内部 XA 的两阶段提交：</p>
<ol>
<li>Prepare 阶段：Innodb 将回滚段设置为 prepare 状态；将 redo log 写文件并刷盘；</li>
<li>Commit 阶段：binlog 写入文件；binlog 刷盘；Innodb commit；</li>
</ol>
<p>两阶段提交保证了事务在多个引擎和 binlog 之间的原子性，以 binlog 写入成功作为事务提交的标志，而 InnoDB 的 commit 标志并不是事务成功与否的标志。</p>
<p>在崩溃恢复中，是以 binlog 中的 xid 和 redo log 中的 xid 进行比较，xid 在 binlog 里存在则提交，不存在则回滚。我们来看崩溃恢复时具体的情况：</p>
<ul>
<li>在 prepare 阶段崩溃，即已经写入 redolog，在写入 binlog 之前崩溃，则会回滚；</li>
<li>在 commit 阶段，当没有成功写入 binlog 时崩溃，也会回滚；</li>
<li>如果已经写入 binlog，在写入 InnoDB commit 标志时崩溃，则重新写入 commit 标志，完成提交。</li>
</ul>
<h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><p>这篇文章分析了 Mysql 的三种日志文件，通过日志文件，Mysql 实现的事务的原子性及持久性，其中 undo log 实现了原子性，同时也用来实现 MVCC，redo log 实现了持久性，保证在服务宕机的情况下进行事务的恢复。另外，使用两阶段提交，结合 binlog 及 redo log，保证了 Mysql Sever 及 Innodb 数据的一致性。</p>
<p><strong>参考：</strong></p>
<hr>
<p><a href="https://segmentfault.com/a/1190000009122071" target="_blank" rel="noopener">1. Innodb中的buffer poll和redo undo log</a><br><a href="https://mp.weixin.qq.com/s/b7Qnzh1EIM4wbExwmIkJyA" target="_blank" rel="noopener">2. 一个线上SQL死锁异常分析：深入了解事务和锁</a><br><a href="https://www.cnblogs.com/xinysu/p/6555082.html" target="_blank" rel="noopener">3. 说说MySQL中的Redo log Undo log都在干啥</a><br><a href="http://mysql.taobao.org/monthly/2016/07/01/" target="_blank" rel="noopener">4. MySQL · 特性分析 ·MySQL 5.7新特性系列三</a><br><a href="https://segmentfault.com/a/1190000023827696" target="_blank" rel="noopener">5. 必须了解的mysql三大日志-binlog、redo log和undo log</a><br><a href="https://mp.weixin.qq.com/s/zDiuK1wTIdwK4U3W3mrIlg" target="_blank" rel="noopener">6. 简介undo log、truncate、​以及undo log如何帮你回滚事物？</a><br><a href="https://xie.infoq.cn/article/ed531f74ecfd44eacb1a98258" target="_blank" rel="noopener">7. 洞悉 MySQL 底层架构：游走在缓冲与磁盘之间</a><br><a href="http://mysql.taobao.org/monthly/2018/12/04/" target="_blank" rel="noopener">8. MySQL的事务处理—两阶段事务提交2PC</a><br><a href="http://mysql.taobao.org/monthly/2020/05/07/" target="_blank" rel="noopener">9. MySQL · 源码分析 · 内部 XA 和组提交</a><br><a href="https://time.geekbang.org/column/article/68633" target="_blank" rel="noopener">10. 日志系统：一条SQL更新语句是如何执行的？</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/29/gossip-protocol/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/11/29/gossip-protocol/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">Gossip 协议</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-11-29 17:15:14" itemprop="dateCreated datePublished" datetime="2020-11-29T17:15:14+08:00">2020-11-29</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-07-31 17:17:10" itemprop="dateModified" datetime="2021-07-31T17:17:10+08:00">2021-07-31</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/一致性算法/" itemprop="url" rel="index"><span itemprop="name">一致性算法</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">16k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">14 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>在一致性算法中，Raft 及 Paxos 是强一致性的算法，属于 CP（一致性及分区容错性） 的使用场景，为了保证算法的准确性，必须保证大部分节点（服务器）是正常的（三个节点容忍一个节点失败）。但在 AP （可用性及分区容错性）场景中，即使只有少数机器的存在，仍然可以对外提供服务，这些场景包括：失败检测、路由同步、Pub/Sub 及动态负载均衡。而 Gossip 协议就是这样一种支持最终一致性算法的协议。</p>
<h2 id="2-Gossip-协议"><a href="#2-Gossip-协议" class="headerlink" title="2. Gossip 协议"></a>2. Gossip 协议</h2><p>Gossip 协议，顾名思义，就像流言蜚语一样，利用一种随机、带有传染性的方式，将信息传播到整个网络中，并在一定时间内，使得系统内的所有节点数据一致。相对于 Raft 来说，数据的一致性收敛是随机且滞后的，但提高了系统的可用性。</p>
<p>在一些分类中，将 Gossip 协议分为三类，分别是：</p>
<ol>
<li>直接邮寄（Direct Mail）：数据的变更直接由数据源结点复制给目标结点，不通过中间结点；</li>
<li>反熵（Anti-entropy）：反熵指的是集群中的节点，每隔段时间就随机选择某个其他节点，然后通过互相交换自己的所有数据来消除两者之间的差异，实现数据的最终一致性：</li>
<li>谣言传播（Rumor mongering）：它指是当一个节点有了新数据后，这个节点变成活跃状态，并周期性地联系其他节点向其发送新数据，直到所有的节点都存储了该新数据：</li>
</ol>
<p>相比较而言，反熵需要拷贝全量数据进行比对，会消耗较大的网络带宽及性能，优势是数据可以在相对确定的时间内达成一致；而谣言传播周期性地进行部分增量数据的传播，占用网络带宽较少，具备较好的性能，缺点也是显然的，数据的收敛时间不确定。后面我们将 Gossip 协议特指谣言传播，重点说明谣言传播算法。</p>
<h3 id="2-1-基本原理"><a href="#2-1-基本原理" class="headerlink" title="2.1 基本原理"></a>2.1 基本原理</h3><p>Gossip协议 基本思想就是：一个节点想要分享一些信息给网络中的其他的一些节点。于是，它周期性的随机选择一些节点，并把信息传递给这些节点。这些收到信息的节点接下来会做同样的事情，即把这些信息传递给其他一些随机选择的节点。一般而言，信息会周期性的传递给 n 个目标节点，而不只是一个，如下图所示：<br><img src="/images/consensus-algorithm/gosssip.gif" alt="gossip" title="gossip"></p>
<p><strong>容错性</strong><br>Gossip 协议具备失败容错的能力，即使节点之间没有直接相连，也可以通过其它结点传播信息；</p>
<p><strong>收敛时间</strong><br>Gossip 协议周期性随机选择 n 个结点进行消息的广播，集群中所有结点收到广播的时间是不确定的，虽然可以保证数据最终都可以收到，但收到的时候没有办法预估。可以通过另外一种办法来评估收敛的时间，即通过广播的轮数。它的计算方式如下：<br><img src="/images/consensus-algorithm/gossip-convergence.jpg" alt="gossip-convergence.jpg" title="gossip-convergence.jpg"></p>
<p>排除传播过程中有可能重复的结点，20 个结点的集群进行三轮的广播之后就可要以将数据传播到集群中的所有结点。</p>
<h2 id="3-使用场景"><a href="#3-使用场景" class="headerlink" title="3. 使用场景"></a>3. 使用场景</h2><h2 id="4-Gossip-在-Redis-中的使用"><a href="#4-Gossip-在-Redis-中的使用" class="headerlink" title="4. Gossip 在 Redis 中的使用"></a>4. Gossip 在 Redis 中的使用</h2><p>Redis Cluster 在 3.0 版本引入集群功能。为了让让集群中的每个实例都知道其它所有实例的状态信息，Redis 集群规定各个实例之间按照 Gossip 协议来通信传递信息。<br><img src="/images/consensus-algorithm/redis-cluster.jpg" alt="redis-cluster" title="redis-cluster"></p>
<p>Redis Cluster 中的每个节点都维护一份集群相关的信息，主要包括：</p>
<ol>
<li>当前集群状态；</li>
<li>集群中各节点所负责的 slots 信息及其 migrate 状态；</li>
<li>集群中各节点的 master-slave 状态; </li>
<li>集群中各节点的存活状态及怀疑 Fail 状态。</li>
</ol>
<p>Gossip 协议的主要职责就是信息交换，这些信息包括上面所说的内容。信息交换的载体就是节点彼此发送的 Gossip 消息，常用的 Gossip 消息可分为：ping 消息、pong 消息、meet 消息、fail 消息。</p>
<ol>
<li>meet 消息：用于通知新节点加入。消息发送者通知接收者加入到当前集群，meet 消息通信正常完成后，接收节点会加入到集群中并进行周期性的ping、pong 消息交换；</li>
<li>ping 消息：集群内交换最频繁的消息，集群内每个节点每秒向多个其它节点发送 ping 消息，用于检测节点是否在线和交换彼此状态信息。ping 消息发送封装了自身节点和部分其它节点的状态数据；</li>
<li>pong 消息：当接收到 ping、meet 消息时，作为响应消息回复给发送方确认消息正常通信。pong消息内部封装了自身状态数据。节点也可以向集群内广播自身的 pon g消息来通知整个集群对自身状态进行更新；</li>
<li>fail 消息：当节点判定集群内另一个节点下线时，会向集群内广播一个 fail 消息，其他节点接收到 fail 消息之后把对应节点更新为下线状态。</li>
</ol>
<h3 id="4-1-消息体"><a href="#4-1-消息体" class="headerlink" title="4.1 消息体"></a>4.1 消息体</h3><p>一个 Gossip 协议消息常常包括一个 clusterMsg + n 个 clusterMsgData，clusterMsg 当前结点的信息，包括主从信息及本结点的 slots 信息。clusterMsgData 根据消息类型的不同表示为不同的数据结构，后面进到。消息的结构下图所示：<br><img src="/images/consensus-algorithm/redis-clusterMsg.jpg" alt="redis-clusterMsg" title="redis-clusterMsg"></p>
<p>clusterMsg 结构如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> sig[<span class="number">4</span>];        <span class="comment">/* Signature "RCmb" (Redis Cluster message bus). */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> totlen;    <span class="comment">/* Total length of this message */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> ver;       <span class="comment">/* Protocol version, currently set to 1. */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> port;      <span class="comment">/* TCP base port number. */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> type;      <span class="comment">/* Message type */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> count;     <span class="comment">/* Only used for some kind of messages. */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> currentEpoch;  <span class="comment">/* The epoch accordingly to the sending node. */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> configEpoch;   <span class="comment">/* The config epoch if it's a master, or the last</span></span><br><span class="line"><span class="comment">                               epoch advertised by its master if it is a</span></span><br><span class="line"><span class="comment">                               slave. */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> offset;    <span class="comment">/* Master replication offset if node is a master or</span></span><br><span class="line"><span class="comment">                           processed replication offset if node is a slave. */</span></span><br><span class="line">    <span class="keyword">char</span> sender[CLUSTER_NAMELEN]; <span class="comment">/* Name of the sender node */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> myslots[CLUSTER_SLOTS/<span class="number">8</span>];  <span class="comment">/* 本结点的 slot 信息 */</span></span><br><span class="line">    <span class="keyword">char</span> slaveof[CLUSTER_NAMELEN];</span><br><span class="line">    <span class="keyword">char</span> myip[NET_IP_STR_LEN];    <span class="comment">/* Sender IP, if not all zeroed. */</span></span><br><span class="line">    <span class="keyword">char</span> notused1[<span class="number">34</span>];  <span class="comment">/* 34 bytes reserved for future usage. */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> cport;      <span class="comment">/* Sender TCP cluster bus port */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> flags;      <span class="comment">/* Sender node flags */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> state; <span class="comment">/* Cluster state from the POV of the sender */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> mflags[<span class="number">3</span>]; <span class="comment">/* Message flags: CLUSTERMSG_FLAG[012]_... */</span></span><br><span class="line">    <span class="keyword">union</span> clusterMsgData data;</span><br><span class="line">&#125; clusterMsg;</span><br></pre></td></tr></table></figure>
<p>如果是 PING, MEET and PONG 消息的话，clusterMsgData 发送的是一个 clusterMsgDataGossip 数组，clusterMsgDataGossip 描述了一个结点的简要信息，包括了结点的状态，其中就包括疑似下线结点的状态。如果是 FAIL 消息，则发送的是 clusterMsgDataFail 数据，clusterMsgDataFail 只包含一个字段，即下线结点的名字。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> clusterMsgData &#123;</span><br><span class="line">    <span class="comment">/* PING, MEET and PONG */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="comment">/* Array of N clusterMsgDataGossip structures */</span></span><br><span class="line">        clusterMsgDataGossip gossip[<span class="number">1</span>];</span><br><span class="line">    &#125; ping;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* FAIL */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        clusterMsgDataFail about;</span><br><span class="line">    &#125; fail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* PUBLISH */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        clusterMsgDataPublish msg;</span><br><span class="line">    &#125; publish;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* UPDATE */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        clusterMsgDataUpdate nodecfg;</span><br><span class="line">    &#125; update;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* MODULE */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        clusterMsgModule msg;</span><br><span class="line">    &#125; <span class="keyword">module</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>clusterMsgDataGossip 结构体包括了一个结点的基本信息，其中 pong_received 字段记录了该结点最近一次发送 pong 消息的时间，flags 状态记录了结点的状态，疑似下线状态就是由这个标志来记录的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Initially we don't know our "name", but we'll find it once we connect</span></span><br><span class="line"><span class="comment"> * to the first node, using the getsockname() function. Then we'll use this</span></span><br><span class="line"><span class="comment"> * address for all the next messages. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> nodename[CLUSTER_NAMELEN];</span><br><span class="line">    <span class="keyword">uint32_t</span> ping_sent;</span><br><span class="line">    <span class="keyword">uint32_t</span> pong_received;</span><br><span class="line">    <span class="keyword">char</span> ip[NET_IP_STR_LEN];  <span class="comment">/* IP address last time it was seen */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> port;              <span class="comment">/* base port last time it was seen */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> cport;             <span class="comment">/* cluster port last time it was seen */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> flags;             <span class="comment">/* node-&gt;flags copy */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> notused1;</span><br><span class="line">&#125; clusterMsgDataGossip;</span><br></pre></td></tr></table></figure>
<p>clusterMsgDataFail 结构体只包括了结点的名称，相对比较简单。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> nodename[CLUSTER_NAMELEN];</span><br><span class="line">&#125; clusterMsgDataFail;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-消息传播"><a href="#4-2-消息传播" class="headerlink" title="4.2 消息传播"></a>4.2 消息传播</h3><p>Redis cluser 通过以下的方式进行消息的传播：</p>
<ol>
<li>每 1 S 从 5 个随机结点中选择一个最久未发送 Pong 消息的结点发送　Ping 消息。发送的消息中包括当前结点的信息及多个随机结点的简要信息和状态消息；收到消息的结点，回复一个 Pong 消息；</li>
<li>每 100 MS 扫描一遍所有结点，比较结点上次发送 Pong 消息的时间到当前时间的时长，如果这个时长大于集群超时时间的 1/2，则立即发送 Ping 信息，避免在第一步中有结点长期未被选中的情况发生。</li>
</ol>
<p>这个流程如下图代码所示：<br><img src="/images/consensus-algorithm/redis-clusterCron.jpg" alt="redis-clusterCron" title="redis-clusterCron"></p>
<p>一个消息体包括发送结点本身的信息，同时会随机选择多个结点的状态信息，结点的数量小于总结点数的 1/10，这其中包括正常的结点和疑似下线的结点，流程如下所示：<br><img src="/images/consensus-algorithm/redis-clusterSendPing.jpg" alt="redis-clusterSendPing" title="redis-clusterSendPing"></p>
<h3 id="4-2-故障检测"><a href="#4-2-故障检测" class="headerlink" title="4.2 故障检测"></a>4.2 故障检测</h3><ol>
<li>下线检测：集群中的每个节点都会定期向集群中的其它节点发送 Ping 消息，用于检测对方是否在线，如果接收 Ping 消息的节点没有在规定的时间收到响应的 Ping 消息，那么，发送 Ping 消息的节点就会将接收 Ping 消息的节点标注为疑似下线状态（Probable Fail，Pfail）；</li>
<li>状态传递：集群中的各个节点会通过相互发送 Ping 消息的方式来交换自己掌握的集群中各个节点的状态信息，如在线、疑似下线（Pfail）、下线（fail）。如果一个结点检测到另外一结点疑似下线，该结点会将疑似下线结点的状态通过 Ping 消息传播给集群中其它结点，其它结点收到消息会更新其结点的状态；</li>
<li>下线判定：如果在一个集群里，超过半数的持有 slot(槽) 的主节点都将某个主节点 A 报告为疑似下线，那么，主节点 A 将被标记为下线（fail），检测到 A 结点下线的主结点广播一条 A 下线的 Fail 消息，所有收到这条 Fail 消息的节点都会立即将主节点 A 标记为 fail。至此，故障检测完成。</li>
</ol>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>Gossip 协议在 AP 场景及结点数量频繁变化的场景下，具有较大的优势，但是随着结点数量的增加，消息通信的成本也就更高，因此对于Redis集群来说并不是越大越好。</p>
<p><strong>参考：</strong></p>
<hr>
<p><a href="https://time.geekbang.org/" target="_blank" rel="noopener">1. Gossip协议：流言蜚语，原来也可以实现一致性</a><br><a href="https://segmentfault.com/a/1190000022957348" target="_blank" rel="noopener">2. 漫谈 Gossip 协议</a><br><a href="https://www.cnblogs.com/charlieroro/articles/12655967.html" target="_blank" rel="noopener">3. Gossip是什么</a><br><a href="https://blog.csdn.net/Jin_Kwok/article/details/90111631" target="_blank" rel="noopener">4. 第三章：深入浅出理解分布式一致性协议Gossip和Redis集群原理</a><br><a href="https://segmentfault.com/a/1190000038373546" target="_blank" rel="noopener">5. 一万字详解 Redis Cluster Gossip 协议</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/08/paxos-and-raft/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/11/08/paxos-and-raft/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">Paxos 和 Raft 算法</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-11-08 16:31:26" itemprop="dateCreated datePublished" datetime="2020-11-08T16:31:26+08:00">2020-11-08</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-07-31 17:17:10" itemprop="dateModified" datetime="2021-07-31T17:17:10+08:00">2021-07-31</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/一致性算法/" itemprop="url" rel="index"><span itemprop="name">一致性算法</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">23k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">21 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>在分布式系统中，一个核心的问题就是解决数据一致性的问题，即共识问题（多副本共识问题）：</p>
<blockquote>
<p>Consensus Problem : Requires agreement among a number of processes (or agents) for a single data value.</p>
</blockquote>
<p>共识问题简单来说，就是多个进程（代理）就某个单值达成一致，主要的应用场景数据多副本的复制。而 Paxos 及 Raft 算法的提出便是为了解决共识问题，它们在工程实现上得到了广泛的应用，如 Goggle 的 Chubby、Apache 的 ZooKeeper 及 Raft算法实现 Etcd。这些算法都可以统称为一致性算法。</p>
<p><img src="/images/consensus-algorithm/paxos-evolution.jpg" alt="paxos-evolution" title="paxos-evolution"></p>
<p>一致性算法大概可以分为4个类型：</p>
<ol>
<li>Basic-Paxos : 提供就一个提案达成一致的算法，是最基本的算法，在工程实践中很少使用该算法；</li>
<li>Multi-Paxos : 在 Basic-Paxos 算法的基础上，提供了就一批提案达成一致的算法，在工程中有很多类似的实现；</li>
<li>Raft : 针对 Multi-Paxos 算法难于理解及实现复杂，提供了一种简化的实现；</li>
<li>Multi-Raft : 为了提供更大的并发请求量，可以将单个 Raft 集群进行分区，提供更大的集群规模。</li>
</ol>
<p>这篇文章就四种类型的算法进行一个概要的分析，更多的是逻辑概念层面，不会对细节及实现过多讨论，那也超出本人的认知。</p>
<h2 id="2-Paxos"><a href="#2-Paxos" class="headerlink" title="2. Paxos"></a>2. Paxos</h2><p>Paxos 算法解决的问题是一个分布式系统如何就某个值（提案）达成一致。一个典型的场景是，在一个分布式数据库系统中，如果各节点的初始状态一致，每个节点都执行相同的操作序列，那么他们最后能得到一个一致的状态。为保证每个节点执行相同的命令序列，需要在每一条指令上执行一个“一致性算法”以保证每个节点看到的指令一致，是分布式计算中的重要问题。</p>
<h3 id="2-1-Basic-Paxos"><a href="#2-1-Basic-Paxos" class="headerlink" title="2.1 Basic-Paxos"></a>2.1 Basic-Paxos</h3><p>在 Paxos 算法中，节点分为三种角色：</p>
<ol>
<li>Proposers：提案（value）发起者，接收客户端请求；</li>
<li>Acceptors：接收提案（value）进行决策，存储 accept 的提案（value）；</li>
<li>Learners：不参与决策，从 Proposers 和 Acceptors 学习最新达成一致的提案（value）。<br>由于 Learners 不参与决策，暂不讨论。</li>
</ol>
<p>Paxos 算法分为两个阶段，为什么使用两个阶段，可以参考这篇文章：<a href="https://mp.weixin.qq.com/s?__biz=MjM5MDg2NjIyMA==&amp;mid=203607654&amp;idx=1&amp;sn=bfe71374fbca7ec5adf31bd3500ab95a&amp;key=8ea74966bf01cfb6684dc066454e04bb5194d780db67f87b55480b52800238c2dfae323218ee8645f0c094e607ea7e6f&amp;ascene=1&amp;uin=MjA1MDk3Njk1&amp;devicetype=webwx&amp;version=70000001&amp;pass_ticket=2ivcW%2FcENyzkz%2FGjIaPDdMzzf%2Bberd36%2FR3FYecikmo%3D" target="_blank" rel="noopener">一步一步理解Paxos算法</a></p>
<p><strong>Paxos 协议分为两个阶段：</strong></p>
<ol>
<li>第一阶段 Prepare：<ul>
<li>Proposer 生成全局唯一且递增的提案 ID （ProposalId），向 Paxos 集群的所有机器发送 PrepareRequest，这里无需携带提案内容，只携带 ProposalId 即可。Acceptor 收到  PrepareRequest 后，做出“两个承诺，一个应答”。</li>
<li>两个承诺主要是指：<ul>
<li>不再应答 ProposalId 小于等于（注意：这里是 &lt;= ）当前请求的 PrepareRequest；</li>
<li>不再应答 ProposalId 小于（注意：这里是 &lt; ）当前请求的 AcceptRequest。</li>
</ul>
</li>
<li>一个应答主要是指：<br>返回自己已经 Accept 过的提案中 ProposalID 最大的那个提案的内容，如果没有则返回空值;</li>
</ul>
</li>
</ol>
<ol start="2">
<li><p>第二阶段 Accept：</p>
<ul>
<li><p>P2a：Proposer 发送 Accept<br>“提案生成规则”：Proposer 收集到多数派应答的 PrepareResponse 后，从中选择 ProposalId 最大的提案内容，作为要发起 Accept 的提案，如果这个提案为空值，则可以自己随意决定提案内容。然后携带上当前 ProposalId，向 Paxos 集群的所有机器发送 AccpetRequest。</p>
</li>
<li><p>P2b：Acceptor 应答 Accept<br>Accpetor 收到 AccpetRequest 后，检查不违背自己之前作出的“两个承诺”情况下，持久化当前 ProposalId 和提案内容。最后 Proposer 收集到多数派应答的 AcceptResponse 后，形成决议。</p>
</li>
</ul>
</li>
</ol>
<p>在执行上面两个步骤之后，实际上后续还有一个步骤。在实际应用中，如使用 Paxos 算法的 KV 系统，上述两个步骤只是完成了日志在不同系统的提交，对于一个写操作，还需要将写操作提交到背后的存储结构中，这个操作往往是异步操作。</p>
<p>在 Paxos 两个阶段中隐含了两个规则：</p>
<ol>
<li>喜新厌旧：在第一阶段中，更大的 ProposalId 会抢占比它小的提案，前提是还没有 ProposalId 被 Accept；</li>
<li>后者认同前者：在第二阶段中，如果提案还没有被 Accept，则提交自己新的 Proposal，如果已经提案已经被 Accept，则使用旧的提案内容进行提交。</li>
</ol>
<p>在第一个规则中，要保证新的 ProposalId 比之前的 ProposalId 大，包含两层意思，1） 同一个 Proposer 生成的 ProposalId 是自增的；2）不同 Proposer 生成的 ProposalId 要要求是自增。正常会使用如下的方案：<br>假设有 n 个proposer，每个编号为ir (0 &lt;= ir &lt; n)，Proposor 编号的任何值 s 都应该大于它已知的最大值，并且满足：s %n = ir =&gt; s = m*n + ir。</p>
<p>Basic-Paxos 算法如下图所示：<br><img src="/images/consensus-algorithm/paxos-algorithem.jpg" alt="paxos-algorithem" title="paxos-algorithem"></p>
<p>在算法中，必须持久化存储 minProposal, acceptedProposal,和 acceptedValue 三个变量。</p>
<p>Basic-Paxos 实例 1：<br><img src="/images/consensus-algorithm/paxos-example-1.jpg" alt="paxos-example-1" title="paxos-example-1"><br>说明：<br>Proposal ID：round number(3), server id(1)，即 Proposal ID = 3.1 ，其中 3 代表轮数，1 代表 节点编号。<br>P 3.1达成多数派，其 Value(X) 被 Accept，然后P 4.5学习到 Value(X)，并Accept。</p>
<p>实例 2：<br><img src="/images/consensus-algorithm/paxos-example-2.jpg" alt="paxos-example-2" title="paxos-example-2"><br>P 3.1没有被多数派Accept（只有S3 Accept），但是被P 4.5学习到，P 4.5 将自己的Value 由 Y 替换为 X，Accept（X）</p>
<p>实例 3：<br><img src="/images/consensus-algorithm/paxos-example-3.jpg" alt="paxos-example-3" title="paxos-example-3"><br>P 3.1 没有被多数派Accept（只有S1 Accept），同时也没有被 P 4.5学习到。由于P 4.5 Propose的所有应答，均未返回 Value，则 P 4.5 可以Accept 自己的Value（Y）。<br>后续 P 3.1的Accept（X）会失败，已经 Accept 的 S1，会被覆盖。</p>
<p>Basic-Paxos 存在一个活锁的问题，如下图所示：<br><img src="/images/consensus-algorithm/liveness-lock.jpg" alt="liveness-lock" title="liveness-lock"><br>两个Proposers交替Propose成功，Accept失败，形成活锁（Livelock）</p>
<h2 id="3-Multi-Paxos"><a href="#3-Multi-Paxos" class="headerlink" title="3. Multi-Paxos"></a>3. Multi-Paxos</h2><p>如果想确定一个确定，一个值，Basic-Paxos 就可以实现了。如果想确定连续多个提案，确定连续多个值，Basic-Paxos 算法就搞不定了，就要使用 Multi-Paxos。如下图所示：<br><img src="/images/consensus-algorithm/multi-paxos.jpg" alt="multi-paxos" title="multi-paxos"></p>
<p>Multi-Paxos 就是对每一个 Paxos Instance 执行一次 Paxos 算法，确保每一台节点上的数据都是一致的。</p>
<p>Multi-Paxos 有如下一些缺点：</p>
<ol>
<li>比较复杂，难以理解，工程实现难度比较大；</li>
<li>每一个服务器都可以执行写操作，性能较差。</li>
</ol>
<p>为了解决 Multi-Paxos 的缺点，在算法中引入了 Leader 的角色，所有的决议都通过 Leader 来进行，然后同步到其它节点，其结构如下图所示：<br><img src="/images/consensus-algorithm/multi-paxos-2.jpg" alt="multi-paxos-2" title="multi-paxos-2"></p>
<p>通过 Consensus Module， 完成多个连续的提案的确定，通过日志同步到各个节点，保证节点以相同的顺序执行，使得节点的状态保持一致。其中，Raft 算法便是 Multi-Paxos 算法的一个实现版本。</p>
<h2 id="4-Raft"><a href="#4-Raft" class="headerlink" title="4. Raft"></a>4. Raft</h2><p>Raft 通过选举一个 Leader，然后让它负责日志的复制来实现一致性。Leader 从客户端接收日志条目，把日志条目复制到其它节点上，并且当保证安全性的时候告诉其它节点应用日志条目到他们的状态机中。拥有一个 Leader 大大简化了对复制日志的管理。例如，Leader 可以决定新的日志条目需要放在日志中的什么位置而不需要和其他节点商议，并且数据只从 Leader 流向其他节点。一个 Leader 可以宕机，可以和其他节点失去连接，这时一个新的 Leader 会被选举出来。</p>
<p>通过 Leader 的方式，Raft 将一致性问题分解成了三个相对独立的子问题：</p>
<ol>
<li>Leader 选举：当现存的 Leader 宕机的时候，一个新的 Leader 需要被选举出来；</li>
<li>日志复制：Leader 必须从客户端接收日志然后复制到集群中的其他节点，并且强制要求其它节点的日志保持和自己相同；</li>
<li>安全性：如果有任何的节点节点已经应用了一个确定的日志条目到它的状态机中，那么其它节点节点不能在同一个日志索引位置应用一个不同的指令。</li>
</ol>
<h3 id="4-1-基本概念"><a href="#4-1-基本概念" class="headerlink" title="4.1 基本概念"></a>4.1 基本概念</h3><p><strong>Server状态：</strong></p>
<p>在任何时刻，每一个节点节点都处于这三个状态之一：Leader 、Follower 或者 Candidate。在通常情况下，系统中只有一个 Leader 并且其它的节点全部都是 Follower。Follower 都是被动的：它们不会发送任何请求，只是简单的响应来自 Leader 或者 Candidate 的请求。Leader 处理所有的客户端请求（如果一个客户端和 Leader 联系，那么 Follower 会把请求重定向给 Leader）。第三种状态，Candiate，是用来在选举新 Leader 时使用。下图展示了这些状态和它们之间的转换关系。</p>
<p><img src="/images/consensus-algorithm/raft_server_state.png" alt="raft_server_state" title="raft_server_state"></p>
<ul>
<li>Leader : 处理客户端的请求以及日志复制；</li>
<li>Follower : 接收来自 Leader 或者 Canditate 的 Message，并响应；</li>
<li>Candidate : 用于选主的中间状态。</li>
</ul>
<p><strong>Term：</strong><br>Raft 把时间分割成任意长度的任期，如下图所示，任期用连续的整数标记。每一段任期从一次选举开始，一个或者多个 Candidate 尝试成为 Leader。如果一个 Candidate 赢得选举，然后它就在接下来的任期内充当 Leader 的职责。在某些情况下，一次选举过程会造成选票的瓜分。在这种情况下，这一任期会以没有 Leader 结束；一个新的任期（和一次新的选举）会很快重新开始。Raft 保证了在一个给定的任期内，最多只有一个 Leader。<br><img src="/images/consensus-algorithm/raft-term.png" alt="raft_term" title="raft_term"></p>
<p><strong>Message类型：</strong><br>Raft 算法中服务器节点之间通信使用远程过程调用（RPCs），并且基本的一致性算法只需要两种类型的 RPCs。请求投票（RequestVote） RPCs ，由 Candidate 在选举期间发起，然后追加条目（AppendEntries）RPCs 由Leader 发起，用来复制日志和提供一种心跳机制。安装快照 (InstallSnapshot）在新服务器启动时或者 Follower 落后太多日志时使用。</p>
<h3 id="4-2-Leader-选择"><a href="#4-2-Leader-选择" class="headerlink" title="4.2 Leader 选择"></a>4.2 Leader 选择</h3><p>Raft 使用心跳机制来触发 Leader 选举。当服务器程序启动时，他们都是 Follower 身份。只要从 Leader 或者 Candidate 处接收到有效的 AppendEntries RPC， 一个服务器节点继续保持着 Folllowr 状态。Leader 周期性的向所有 Follower 发送心跳包（即不包含日志项内容的追加日志项 RPCs）来维持自己的权威。如果一个 Follower 在一段时间里没有接收到任何消息，也就是选举超时，那么他就会认为系统中没有可用的 Leader,并且发起选举以选出新的 Leader。<br>要开始一次选举过程，Follower 先要增加自己的当前任期号并且转换到 Candidate 状态。然后它会并行的向集群中的其他服务器节点发送请求投票的 RPCs 来给自己投票。如果一个 Candidate 从整个集群的大多数服务器节点获得了针对同一个任期号的选票，那么它就赢得了这次选举并成为 Leader。每一个服务器最多会对一个任期号投出一张选票，按照先来先服务的原则，并且确保 Candidate 的日志比服务器更新。要求大多数选票的规则确保了最多只会有一个 Candidate 赢得此次选举，要求 Candidate 的日志最新，确保日志只从 Leader 流向 Follower。一旦候选人赢得选举，它就立即成为领导人。然后他它会向其他的服务器发送心跳消息来建立自己的权威并且阻止新的 Leader 的产生。</p>
<p><img src="/images/consensus-algorithm/raft-election.jpg" alt="raft-election" title="raft-election"></p>
<p>一个 Candidate 获得集群中多数服务器的选票，并不代表真正获得了 Leader，因为它只完成了类似 Basic-Paxos的 Prepare阶段，此时它还需要向集群中的服务器发送 AppendEntries RPC，阻止其它服务器发起选主请求，其它服务器收到该 RPC 之后，将自己的状态转化为 Follower。<br>在Basic-Paxos 中存在活锁的问题，在 Raft 选主中也同样存在，即多个 Candidate 同时对同一个 Term 发起选主请求，选票会被多个 Candidate 瓜分，为了避免这个问题，Raft 为每一个 Candidate 选择一个随机选主超时时间，可以有效避免这种情况，即使发生这种情况，因为没有一个 Candidate 获得多数选票，等待超时时间之后，将触发下一轮的选主，而下一轮的触发的时间也是随机的。<br>在选主的操作中，只有那些包含更新更多日志的 Candiate 才有机会获得选票，这主要是通过比较 LastLogIndex 和 LastLogTerm 来实现的。通过这种方式，Raft 简化了后续日志复制的过程，保证了日志只会由 Leader 流向 Follower。</p>
<p>通过以上的方式，保证了选主的安全性：<strong style="color:red">对于一个给定的任期号，最多只会有一个领导人被选举出来。</strong></p>
<h3 id="4-3-日志复制"><a href="#4-3-日志复制" class="headerlink" title="4.3 日志复制"></a>4.3 日志复制</h3><p>一旦一个 Leader 被选举出来，它就开始为客户端提供服务。客户端的每一个请求都包含一条被状态机执行的指令。Leader 把这条指令作为一条新的日志条目附加到日志中去，然后并行的发起追加条目 RPCs 给其他的服务器，让它们复制这条日志条目。当这条日志条目被安全的复制并回复 ACK 给Leader ，Leader 会应用这条日志条目到它的状态机中然后把执行的结果返回给客户端。如果少数派的 Follower 崩溃或者运行缓慢，再或者网络丢包，Leader 人会不断的重复尝试追加日志条目 RPCs （尽管已经回复了客户端）直到所有的 Follower 都最终存储了所有的日志条目。<br><img src="/images/consensus-algorithm/raft-log.png" alt="raft-log" title="raft-log"></p>
<p>每一个 Log Entry 由有序序号标记的条目组成。每个条目都包含创建时的任期号，和一个状态机需要执行的指令。当一个条目复制到多数派的服务器上时就被认为已提交 (Committed) 状态了。<br><img src="/images/consensus-algorithm/raft-log-format.jpg" alt="raft-log-format" title="raft-log-format"></p>
<p>当日志被多数派服务器持久化之后就成为 Committed 状态，应用到状态机之后变为 Applied，正常情况下，一旦日志成为 Committed 状态之后，就不允许撤消。一个未被多数派持久化的日志有可能被撤消。<br><img src="/images/consensus-algorithm/raft-log-state.jpg" alt="raft-log-state" title="raft-log-state"></p>
<p>Leader 决定什么时候将日志应用给状态机是安全的，Raft 保证 Committed Entries 持久化，并且最终被其它状态机应用。一个 Log Entry 一旦复制给了大多数节点就成为 Committed。同时还有一种情况，如果当前待提交 Entry 之前有未提交的 Entry，即使是以前过时的 Leader 创建的，只要满足已存储在大多数节点上就一次性按顺序都提交。Leader 要追踪最新的 Committed 的 index，并在每次AppendEntries RPCs（包括心跳）都要带给其它服务器，以使其它服务器知道一个 Log Entry是已提交的，从而在它们本地的状态机上也应用。<br><img src="/images/consensus-algorithm/raft-log-flow.jpg" alt="raft-log-flow" title="raft-log-flow"><br>从上图可以知道，日志的 Commited 状态由 Leader 来决定，并在下一次的 AppendEntries RPC 中由 leaderCommit 字段传递给 Follower。正常情况下，在返回客户端之前，日志会应用到 Leader 的状态机中，而 Follower 什么时候将日志应用到状态机，是一个异步操作，会滞后于 Leader。所以 Leader 状态机中持有最新的数据。</p>
<p><strong>日志修复</strong><br>一个日志只要多数派持久化成功，就会认为是 Committed 的。由于各种原因，总有 Follower 落后于 Leader。Leader 为每个 Follower 维护一个 nextId，标示下一个要发送的 logIndex。Follower 接收到 AppendEntries（传递 prevTermID，prevLogIndex 参数），之后会进行一致性检查，检查 AppendEntries 中指定的 LastLogIndex 是否一致，如果不一致就会向 Leader 返回失败。Leader 接收到失败之后，会将 nextId 减1，重新进行发送，直到成功。这个回溯的过程实际上就是寻找 Follower 上最后一个 CommittedId，然后 Leader 发送其后的 LogEntry。<br><img src="/images/consensus-algorithm/raft_log_recovery.png" alt="raft_log_recovery" title="raft_log_recovery"></p>
<p>重新选主后，新的 Leader 没有之前内存中维护的 nextId，以本地 lastLogIndex + 1 作为每个节点的 nextId。这样根据节点的 AppendEntries应答可以调整 nextId：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nextIndex</span></span><br><span class="line">local.nextIndex = max(min(local.nextIndex-<span class="number">1</span>, resp.LastLogIndex+<span class="number">1</span>), <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="4-4-日志压缩"><a href="#4-4-日志压缩" class="headerlink" title="4.4 日志压缩"></a>4.4 日志压缩</h3><p>Raft 的日志在正常操作中不断的增长，但是在实际的系统中，日志不能无限制的增长。随着日志不断增长，它会占用越来越多的空间，花费越来越多的时间来重置。如果没有一定的机制去清除日志里积累的陈旧的信息，那么会带来可用性问题。</p>
<p>快照是最简单的压缩方法。在快照系统中，整个系统的状态都以快照的形式写入到稳定的持久化存储中，然后到那个时间点之前的日志全部丢弃。在 Chubby 和 ZooKeeper 中同样使用快照技术。<br><img src="/images/consensus-algorithm/raft-log-conpress.png" alt="raft-log-conpress" title="raft-log-conpress"><br>上图展示了 Raft 中快照的基础思想。每个服务器独立的创建快照，只包括已经被提交的日志。主要的工作包括将状态机的状态写入到快照中。Raft 也包含一些少量的元数据到快照中：<strong style="color:red">最后被包含索引（lastIncludedIndex）</strong>指的是被快照取代的最后的条目在日志中的索引值（状态机最后应用的日志），<strong style="color:red">最后被包含的任期（lastIncludedTerm）</strong>指的是该条目的任期号。保留这些数据是为了支持快照后紧接着的第一个条目的追加日志请求时的一致性检查，因为这个条目需要前一日志条目的索引值和任期号。为了支持集群成员更新，快照中也将最后的一次配置作为最后一个条目存下来。一旦服务器完成一次快照，他就可以删除最后索引位置之前的所有日志和快照了。<br>做快照的时机选择，对系统也是有影响的。如果过于频繁的快照，那么将会浪费大量的磁盘带宽；如果过于不频繁的快照，那么 Log 将会占用大量的磁盘空间，启动速度也很慢。一个简单的方式就是当 Log 达到一定大小之后再进行快照，或者是达到一定时间之后再进行快照。<br>快照会花费比较长的时间，如果期望快照不影响正常的 Log Entry同步，可以采用 Copy-On-Write 的技术来实现。例如，选择底层的数据结构支持 COW (Copy-On-Write)、LSM-Tree 类型的存储结构，或者是使用系统的 COW 支持，Linux的fork，或者是 ZFS 的 Snapshot 等。</p>
<h3 id="4-5-集群成员变化"><a href="#4-5-集群成员变化" class="headerlink" title="4.5  集群成员变化"></a>4.5  集群成员变化</h3><p>集群成员变化主要是指集群节点数量的增删，在实际场景中，集群的扩容（副本数的增加）或者节点当机下线都是常见的事情。在不停机的情况下，由于节点不能一次性原子地变更节点的成员配置信息，会导致同一时间，同一个任期出现两个领导者，违背了算法安全性原则，如下图所示：<br><img src="/images/consensus-algorithm/raft-membership.png" alt="raft-membership" title="raft-membership"><br>3 个节点的集群扩展到 5 个节点的集群，直接扩展可能会造成 Server1 和Server2 构成老的多数集合，Server3、Server4 和 Server5 构成新的多数集合，产生两个领导者。</p>
<p><strong>Joint-Consensus</strong><br>Raft 算法采用协同一致性的方式来解决节点的变更，先提交一个包含新老节点结合的 Configuration 命令，当这条消息 Commit 之后再提交一条只包含新节点的 Configuration 命令。新老集合中任何一个节点都可以成为 Leader，这样 Leader 当机之后，如果新的 Leader 没有看到包括新老节点集合的 Configuration 日志，继续以老节点集合组建集群；如果新的 Leader 看到了包括新老节点集合的 Configuration 日志，将未完成的节点变更流程走完。具体流程如下：</p>
<ol>
<li>加入新对节点，从 Leader 中追加数据；</li>
<li>全部新节点完成数据同步之后，向新老集合发送 Cold+new 命令；</li>
<li>如果新节点集合多数和老节点集合多数都应答了 Cold+new，就向新老节点集合发送 Cnew 命令；</li>
<li>如果新老节点集合多数应答了 Cnew，完成节点切换。</li>
</ol>
<p>在这里，我们可以把 Cold+new 理解为包含新老结点地址集合，如果当前集群包括 server1, server2 及 server3, 新加的结点为 server4, server5,那么 Cold+new 等同于集合 [server1, server2, server3, server4, server5], Cold 为 [server1, server2, server3], Cnew 为 [server4, server5]。</p>
<p><img src="/images/consensus-algorithm/raft-member-transmit.png" alt="raft-member-transmit" title="raft-member-transmit"><br>虚线表示已经被创建但是还没有被提交的配置日志条目，实线表示最后被提交的配置日志条目。领导人首先创建了 Cold+new 的配置条目在自己的日志中，并提交到 Cold+new 中（Cold 的大多数和 Cnew 的大多数）。然后它创建 Cnew 条目并提交到 Cnew 中的大多数。这样就不存在 Cnew 和 Cold 可以同时做出决定的时间点。<br>如果 Cold+new 被 Commit 到新老集合多数的话，即使过程终止，新的 Leader 依然能够看到 Cold+new，并继续完成 Cnew 的流程，最终完成节点变更；如果 Cold+new 没有提交到新老集合多数的话，新的Leader可能看到了 Cold+new 也可能没有看到，如果看到了依然可以完成 Cnew 的流程，如果没有看到，说明 Cold+new 在两个集合都没有拿到多数应答，重新按照 Cold 进行集群操作，两阶段过程中选主需要新老两个集合都达到多数同意。</p>
<p>节点配置变更过程中需要满足如下规则：</p>
<ul>
<li>新老集合中的任何节点都可能成为 Leader；</li>
<li>任何决议都需要新老集合的多数通过。</li>
</ul>
<p>在这里有一个关键的点就是：<strong style="color:red">任何决议都需要新老集合的多数通过。</strong>如果不能形成两个多数集合，算法是否就可以简化？单节点变更就是基于这个想法产生的。</p>
<p><strong>Single-Server Change</strong><br>单节点变更是对 Joint-Consensus 的简化， 它每次只增删一个节点，这样就不会出现两个多数集合，不会造成决议冲突的情况，如果需要变更多个节点，那需要执行多次单节点变更。比如将 3 节点集群扩容为 5 节点集群，这时你需要执行 2 次单节点变更，先将 3 节点集群变更为 4 节点集群，然后再将 4 节点集群变更为 5 节点集群，如下图所示：<br><img src="/images/consensus-algorithm/raft-node-new.jpg" alt="raft-node-new" title="raft-node-new"><br>还是以三结点 Raft 集群为例，演示下变更为五结点的过程，假定节点 A 为 Leader。<br><img src="/images/consensus-algorithm/raft-node-evolution-1.jpg" alt="raft-node-evolution-1" title="raft-node-evolution-1"><br>目前的集群配置为[A, B, C]，先向集群中加入节点 D，这意味着新配置为[A, B, C, D]。成员变更，是通过两步实现的：</p>
<ol>
<li>Leader（节点 A）向新节点（节点 D）同步数据；</li>
<li>Leader（节点 A）将新配置 [A, B, C, D] 作为一个日志项，复制到新配置中所有节点（节点 A、B、C、D）上，然后将新配置的日志项应用（Apply）到本地状态机，完成单节点变更。<br><img src="/images/consensus-algorithm/raft-node-evolution-2.jpg" alt="raft-node-evolution-2" title="raft-node-evolution-2"></li>
</ol>
<p>变更完成后，集群的配置变为 [A, B, C, D],接着向集群加入结点 E，即新配置为[A, B, C, D, E]，流程类似:</p>
<ol>
<li>Leader（节点 A）向新节点（节点 E）同步数据；</li>
<li>Leader（节点 A）将新配置 [A, B, C, D, E] 作为一个日志项，复制到新配置中所有节点（节点 A、B、C、D、E）上，然后将新配置的日志项应用（Apply）到本地状态机，完成单节点变更。<br><img src="/images/consensus-algorithm/raft-node-evolution-3.jpg" alt="raft-node-evolution-3" title="raft-node-evolution-3"></li>
</ol>
<p>通过连续执行两次单结点变更，完成了集群结点的扩容。</p>
<p>一次性加入一个结点，重点在于新老配置的结点不会形成两个多数派，新老配置要形成多数派总会有重叠的结点，重叠的结点不会给同一任期的两个结点投两次票，这是由 Raft 算法的安全性保证的。</p>
<p><img src="/images/consensus-algorithm/raft-node-evolution.jpg" alt="raft-node-evolution" title="raft-node-evolution"></p>
<p>不管节点数是偶数还是奇数，增加或减少一个结点都不能形成新老配置的两个多数派，两个集合总会有重叠，从而确保了算法的安全性。</p>
<p>另外，在分区错误、节点故障等情况下，有可能并发执行单节点变更，那么就可能出现一次单节点变更尚未完成，新的单节点变更又在执行，导致集群出现 2 个 Leader 的情况。解决的办法是，可以在 Leader 启时 （选主成功之后）时，创建一个 NO_OP 日志项（也就是空日志项），只有当 Leader将 NO_OP 日志项应用后，再执行成员变更请求。</p>
<h3 id="4-6-线性一致读"><a href="#4-6-线性一致读" class="headerlink" title="4.6 线性一致读"></a>4.6 线性一致读</h3><p>什么是线性一致读? 所谓线性一致读，一个简单的例子是在 t1 的时刻写入了一个值，那么在 t1 之后，一定能读到这个值，不可能读到 t1 之前的旧值(类似 Java 中的 volatile 关键字，即线性一致读就是在分布式系统中实现 Java volatile 语义)。简而言之是需要在分布式环境中实现 Java volatile 语义效果，即当 Client 向集群发起写操作的请求并且获得成功响应之后，该写操作的结果要对所有后来的读请求可见。和 volatile 的区别在于 volatile 是实现线程之间的可见，而线性一致读需要实现 Server 之间的可见。<br><img src="/images/consensus-algorithm/raft-linearizability-read.png" alt="raft-linearizability-read" title="raft-linearizability-read"><br>如上图 Client A、B、C、D 均符合线性一致读，其中 D 看起来是 Stale Read，其实并不是，D 请求横跨 3 个阶段，而 Read 可能发生在任意时刻，所以读到 1 或 2 都行。</p>
<p><strong>Raft Log read</strong><br>实现线性一致读最常规的办法是走 Raft 协议，将读请求同样按照 Log 处理，通过 Log 复制和状态机执行来获取读结果，然后再把读取的结果返回给客户端。因为 Raft 本来就是一个为了实现分布式环境下线性一致性的算法，所以通过 Raft 非常方便的实现线性 Read，也就是将任何的读请求走一次 Raft Log，等此 Log 提交之后在 apply 的时候从状态机里面读取值，一定能够保证这个读取到的值是满足线性要求的。</p>
<p>因为每次 Read 都需要走 Raft 流程，Raft Log 存储、复制带来刷盘开销、存储开销、网络开销，走 Raft Log 不仅仅有日志落盘的开销，还有日志复制的网络开销，另外还有一堆的 Raft “读日志” 造成的磁盘占用开销，导致 Read 操作性能是非常低效的，所以在读操作很多的场景下对性能影响很大，在读比重很大的系统中是无法被接受的，通常都不会使用。</p>
<p>个人理解：<strong style="color:red">Raft Log read 关键点在于提交一次读操作并应用到状态机后，将之前处于 Commited　状态的 log 都应用到状态机，确保状态机的状态是最新的。</strong></p>
<p>在 Raft 算法中，执行一次写操作，由客户端向 Leader 发起，首先 Leader 将本次操作写入本地日志，然后向所有的 Follower 同步日志，Follower 收到日志之后写入本地，并回复给 Leader ； Leader 收到半数以上的回复之后将本次操作应用到本地的状态机，并返回客户端写入成功，最后 Leader 在下次同步日志时再将本次日志 Commited 的信息传递给 Follower , Follower再异步更新本地状机。可见，一次写入操作之后，Leader 状态机拥有最新的状态，而 Follower 状态机的状态有可能落后于 Leader。如果直接从 Follower 读到数据，会读到 Stale 数据。如果从 Leader 读取数据的话，则可以保证线性读取最新的数据。现在关键的问题是：<strong style="color:red">如何确认 Leader 在处理这次 Read 的时候一定是 Leader ? </strong>，在这里，有两种方法：</p>
<ol>
<li>ReadIndex Read;</li>
<li>Lease Read.</li>
</ol>
<p><strong>ReadIndex Read</strong><br>ReadIndex Read 有两个关键点：</p>
<ol>
<li>Leader 向 Follower 发送心跳确认自己仍然是 Leader，避免 Leader 已经过期而不自知；</li>
<li>维护一个 ReadIndex , 初始值等于 Leader 的 CommitIndex , 并将 ReadIndex 指向的所有 Log 都应用到状态机中，确保所有的写操作都已经应用。</li>
</ol>
<p>ReadIndex Read 可以从 Leader 和 Followr 读取，过程如下描述。</p>
<p>从 Leader 读取：</p>
<ol>
<li>Leader 将自己当前 Log 的 commitIndex 记录到一个 Local 变量 ReadIndex 里面；</li>
<li>接着向 Followers 节点发起一轮 Heartbeat，如果半数以上节点返回对应的 Heartbeat Response，那么 Leader就能够确定现在自己仍然是 Leader；</li>
<li>Leader 等待自己的 StateMachine 状态机执行，至少应用到 ReadIndex 记录的 Log，直到 applyIndex 超过 ReadIndex，这样就能够安全提供 Linearizable Read，也不必管读的时刻是否 Leader 已飘走；</li>
<li>Leader 执行 Read 请求，将结果返回给 Client。</li>
</ol>
<p>从 Follower 读取：</p>
<ol>
<li>Follower 节点向 Leader 请求最新的 ReadIndex；</li>
<li>Leader 仍然走一遍之前的流程，执行上面前 3 步的过程(确定自己真的是 Leader)，并且返回 ReadIndex 给 Follower；</li>
<li>Follower 等待当前的状态机的 applyIndex 超过 ReadIndex；</li>
<li>Follower 执行 Read 请求，将结果返回给 Client</li>
</ol>
<p><strong>Lease Read</strong><br>在 ReadIndex Read 中执行一次读操作，Leader 都要向 Follower 发送心跳确认当前自己仍然是 Leader，还是存在网络开销，是否可以优化？ Leader 的选主是通过选择超时时间进行的，在这里引入任期的概念，在下一次选主前，都可以认为当前 Leader 的角色都是不会改变的，在这期间的读操作，可以节省心跳的操作。<br>Raft 论文里面提及一种通过 Clock + Heartbeat 的 Lease Read 优化方法，也就是 Leader 发送 Heartbeat 的时候首先记录一个时间点 Start，当系统大部分节点都回复 Heartbeat Response，由于 Raft 的选举机制，Follower 会在 Election Timeout 的时间之后才重新发生选举，下一个 Leader 选举出来的时间保证大于 Start + Election Timeout/Clock Drift Bound，所以可以认为 Leader 的 Lease 有效期可以到 Start + Election Timeout/Clock Drift Bound 时间点。</p>
<p>Lease Read 基本思路是 Leader 取一个比 Election Timeout 小的租期（最好小一个数量级），在租约期内不会发生选举，确保 Leader 不会变化，所以跳过 ReadIndex 的第二步也就降低延时。由此可见 Lease Read 的正确性和时间是挂钩的，依赖本地时钟的准确性，因此虽然采用 Lease Read 做法非常高效，但是仍然面临风险问题，也就是存在预设的前提即各个服务器的 CPU Clock 的时间是准的，即使有误差，也会在一个非常小的 Bound 范围里面，时间的实现至关重要，如果时钟漂移严重，各个服务器之间 Clock 走的频率不一样，这套 Lease 机制可能出问题。</p>
<p>Lease Read 实现方式包括：</p>
<ol>
<li>定时 Heartbeat 获得多数派响应，确认 Leader 的有效性；</li>
<li>在租约有效时间内，可以认为当前 Leader 是唯一有效 Leader，可忽略 ReadIndex 中的 Heartbeat 确认步骤；</li>
<li>Leader 等待自己的状态机执行，直到 applyIndex 超过 ReadIndex，这样就能够安全的提供 Linearizable Read</li>
</ol>
<h3 id="4-7-安全性"><a href="#4-7-安全性" class="headerlink" title="4.7 安全性"></a>4.7 安全性</h3><p>使用 Raft 算法，需要保证如下的安全性：</p>
<ol>
<li>选举安全特性：对于一个给定的任期号，最多只会有一个领导人被选举出来；</li>
<li>领导人只附加原则：领导人绝对不会删除或者覆盖自己的日志，只会增加；</li>
<li>日志匹配原则：如果两个日志在相同的索引位置的日志条目的任期号相同，那么我们就认为这个日志从头到这个索引位置之间全部完全相同；</li>
<li>领导人完全特性：如果某个日志条目在某个任期号中已经被提交，那么这个条目必然出现在更大任期号的所有领导人中；</li>
<li>状态机安全特性：如果一个领导人已经将给定的索引值位置的日志条目应用到状态机中，那么其他任何的服务器在这个索引位置不会应用一个不同的日志。</li>
</ol>
<h2 id="5-Multi-Raft"><a href="#5-Multi-Raft" class="headerlink" title="5. Multi-Raft"></a>5. Multi-Raft</h2><p>因为 Raft 集群内只有 Leader 提供读写服务，所以读写也会形成单点的瓶颈。因此为了支持水平扩展，可以按某种 Key 进行分片部署，比如用户 ID，让 Group 1 对 [0, 10000) 的 ID 提供服务，让 Group 2 对 [10000, 20000) 的 ID 提供服务，以此类推。如下是 SOFAJRaft 的实现：</p>
<p><img src="/images/consensus-algorithm/multi-raft.png" alt="multi-raft" title="multi-raft"></p>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>这篇文章对主要的一致性算法进行了一个概念上描述，并没有深入到具体实现细节。在工程实践境中，已经有几个 Raft 的实现用于生产环境中，如 GO 语言版本的 Etcd、C++ 语言的 braft 及 Java 语言的 SOFAJRaft 。后面有时间，专门研究分析下 SOFAJRaft 源码，提升对共识算法的理解。</p>
<p><strong>参考：</strong></p>
<hr>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&amp;mid=403582309&amp;idx=1&amp;sn=80c006f4e84a8af35dc8e9654f018ace&amp;scene=1&amp;srcid=0119gtt2MOru0Jz4DHA3Rzqy&amp;key=710a5d99946419d927f6d5cd845dc9a72ff3d652a8e66f0ddf87d91262fd262f61f63660690d2d5da76a44a29e155610&amp;ascene=0&amp;uin=MjA1MDk3Njk1&amp;devicetype=iMac+MacBookPro11%2C4+OSX+OSX+10.11.1+build(15B42)&amp;version=11020201&amp;pass_ticket=bhstP11nRHvorVXvQ4pt9fzB9Vdzj5sSRBe84783gsg%3D" target="_blank" rel="noopener">1. 架构师需要了解的Paxos原理、历程及实战</a><br><a href="https://mp.weixin.qq.com/s?__biz=MjM5MDg2NjIyMA==&amp;mid=203607654&amp;idx=1&amp;sn=bfe71374fbca7ec5adf31bd3500ab95a&amp;key=8ea74966bf01cfb6684dc066454e04bb5194d780db67f87b55480b52800238c2dfae323218ee8645f0c094e607ea7e6f&amp;ascene=1&amp;uin=MjA1MDk3Njk1&amp;devicetype=webwx&amp;version=70000001&amp;pass_ticket=2ivcW%2FcENyzkz%2FGjIaPDdMzzf%2Bberd36%2FR3FYecikmo%3D" target="_blank" rel="noopener">2. 一步一步理解Paxos算法</a><br><a href="https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md" target="_blank" rel="noopener">3. 寻找一种易于理解的一致性算法（扩展版）</a><br><a href="https://www.sofastack.tech/blog/sofa-jraft-election-mechanism/" target="_blank" rel="noopener">4. SOFAJRaft 选举机制剖析 | SOFAJRaft 实现原理</a><br><a href="https://github.com/baidu/braft/blob/master/docs/cn/raft_protocol.md" target="_blank" rel="noopener">5. RAFT介绍</a><br><a href="https://www.sofastack.tech/blog/sofa-jraft-linear-consistent-read-implementation/" target="_blank" rel="noopener">6. SOFAJRaft 线性一致读实现剖析 | SOFAJRaft 实现原理</a><br><a href="https://www.sofastack.tech/blog/sofa-jraft-deep-dive/" target="_blank" rel="noopener">7. 蚂蚁金服开源 SOFAJRaft 详解| 生产级高性能 Java 实现</a><br><a href="https://github.com/hedengcheng/tech/blob/master/distributed/PaxosRaft%20%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E5%8F%8A%E5%85%B6%E5%9C%A8%E5%AE%9E%E6%88%98%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8.pdf" target="_blank" rel="noopener">8. PaxosRaft 分布式一致性算法原理剖析及其在实战中的应用.pdf</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/10/08/select-and-epoll/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/10/08/select-and-epoll/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">Select 和 Epoll实现</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-10-08 18:17:33" itemprop="dateCreated datePublished" datetime="2020-10-08T18:17:33+08:00">2020-10-08</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-07-31 17:17:10" itemprop="dateModified" datetime="2021-07-31T17:17:10+08:00">2021-07-31</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/网络协议/" itemprop="url" rel="index"><span itemprop="name">网络协议</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">41k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">37 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇文章主要讲述 select 和 epoll 的实现原理，包括底层的数据结构、与设备的回调处理机制及两种实现之间的差异。</p>
<h2 id="1-知识储备"><a href="#1-知识储备" class="headerlink" title="1. 知识储备"></a>1. 知识储备</h2><p>在介绍 select 和 epoll 的实现原理前，先介绍两个知识点，分别是 1）文件的 poll 函数；2）linux 的wakeup callback机制。select 和 epoll 很大程度上就是基于这两点构建的。</p>
<h3 id="1-1-poll-函数"><a href="#1-1-poll-函数" class="headerlink" title="1.1 poll 函数"></a>1.1 poll 函数</h3><p>在 linux 中，设备的操作抽象为文件的操作，对网络设备的操作同样也是文件操作。为了实现非阻塞的数据读取，文件提供了 poll 操作，该操作为上层应用提供了探测设备文件是否有数据可读的接口，同时结合文件的等待队列，上层应用可以对感兴趣的事件添加处理函数，这个处理函数通常是向等待队列中添加一个等待结点，这个等待结点会关联一个 callback 函数，当相关事件满足时触发 callback 函数，最后 poll 函数返回当前设备文件的状态，上层应用根据返回状态决定是否阻塞该线程，poll 函数不阻塞线程。通过这种方式，设备文件提供了基于事件处理的回调机制，select/poll/epoll 就是基于这种方式来实现的。 </p>
<p><img src="/images/tcp/poll.jpg" alt="poll" title="poll"></p>
<p>poll 函数分为三个步骤：</p>
<ol>
<li>获取事件对应的等待队列；</li>
<li>初始化一个等待结点，设置 callback 函数，并将等待结点加入到等待队列中，此时并不阻塞调用线程；</li>
<li>获取设备当前的状态并返回。</li>
</ol>
<p>在 poll 函数中，上层应用可以根据业务的不同可以自定义 poll_queue_proc 和 唤醒 callback 函数，从而实现不同的功能，select/poll/epoll 分别实现了这两个函数，它们之间的差异从这两个函数中也可以看出。下面是一个 poll 函数实例。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">scull_p_poll</span><span class="params">(struct file *filp, poll_table *wait)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Scull_Pipe *dev = filp-&gt;private_data;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* The buffer is circular; it is considered full</span></span><br><span class="line"><span class="comment">	* if "wp" is right behind "rp". "left" is 0 if the</span></span><br><span class="line"><span class="comment">	* buffer is empty, and it is "1" if it is completely full.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="comment">// 处理私有业务</span></span><br><span class="line">	<span class="keyword">int</span> left = (dev-&gt;rp + dev-&gt;buffersize - dev-&gt;wp) % dev-&gt;buffersize;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 在不同的等待队列上调用 poll_wait 函数</span></span><br><span class="line">	poll_wait(filp, &amp;dev-&gt;inq, wait);</span><br><span class="line">	poll_wait(filp, &amp;dev-&gt;outq, wait);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* readable */</span></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;rp != dev-&gt;wp) mask |= POLLIN | POLLRDNORM;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* writable */</span></span><br><span class="line">	<span class="keyword">if</span> (left != <span class="number">1</span>) mask |= POLLOUT | POLLWRNORM;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>poll 函数的定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 文件操作  </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供给 poll/select/epoll 使用，获取文件当前状态, 以及就绪通知接口函数</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*poll)</span> <span class="params">(struct file *, struct poll_table_struct *)</span></span>; </span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向文件注册事件及处理函数  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_struct</span> &#123;</span></span><br><span class="line">    <span class="comment">// 处理函数</span></span><br><span class="line">    poll_queue_proc _qproc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事件</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>  _key;  </span><br><span class="line">&#125; poll_table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// poll_queue_proc 函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*poll_queue_proc)</span><span class="params">(struct file *, <span class="keyword">wait_queue_head_t</span> *, struct poll_table_struct *)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="1-2-wakeup-callback机制"><a href="#1-2-wakeup-callback机制" class="headerlink" title="1.2 wakeup callback机制"></a>1.2 wakeup callback机制</h3><p>在上节的 poll 函数中，会检查文件的状态（可读/可写/可连接），同时在事件的等待队列添加一个等待结点，待续结点中注册一个 callback 回调函数，事件触发时，再调用 callback 回调函数，唤醒结点中的 task 来处理事件。这种机制正时使用了 linux 内核 wakeup callback机制。<br>Linux 内核通过睡眠队列来组织所有等待某个事件的 task，而 wakeup 机制则可以异步唤醒整个睡眠队列上的 task，每一个睡眠队列上的节点都拥有一个 callback，wakeup 逻辑在唤醒睡眠队列时，会遍历该队列链表上的每一个节点，调用每一个节点的 callback，如果遍历过程中遇到某个节点是排他节点，则终止遍历，不再继续遍历后面的节点。总体上的逻辑可以用下面的伪代码表示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">define sleep_list;</span><br><span class="line">define wait_entry;</span><br><span class="line">wait_entry.task = current_task;</span><br><span class="line">wait_entry.callback = func1;</span><br><span class="line"><span class="keyword">if</span> (something_not_ready); then</span><br><span class="line">    <span class="comment"># 将任务加入等待队列</span></span><br><span class="line">    add_entry_to_list(wait_entry, sleep_list);</span><br><span class="line">go_on:</span><br><span class="line">    <span class="comment"># 根据情况进行睡眠或唤醒</span></span><br><span class="line">    schedule();</span><br><span class="line">    <span class="keyword">if</span> (something_not_ready); then</span><br><span class="line">        goto go_on;</span><br><span class="line">    endif</span><br><span class="line">    del_entry_from_list(wait_entry, sleep_list);</span><br><span class="line">endif</span><br></pre></td></tr></table></figure></p>
<p>唤醒的流程：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">something_ready;</span><br><span class="line">for_each(sleep_list) <span class="keyword">as</span> wait_entry; do</span><br><span class="line">    wait_entry.callback(...);</span><br><span class="line">    <span class="keyword">if</span>(wait_entry.exclusion); then</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    endif</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<p>callback 函数包含于唤醒的主要逻辑，伪代码如下所示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">common_callback_func(...)</span><br><span class="line">&#123;</span><br><span class="line">    do_something_private;</span><br><span class="line">    wakeup_common;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 poll/select/epoll 中都会定义各自的 callback 函数，该函数一般包括两部分：1）私有逻辑；2）唤醒 task。callback 函数由驱动来调用（在 NIC 中由软件中断调用）。</p>
<h3 id="1-3-I-O-多路复用"><a href="#1-3-I-O-多路复用" class="headerlink" title="1.3 I/O 多路复用"></a>1.3 I/O 多路复用</h3><p>I/O 多路复用是一种优化技术，它是为了避免一个线程处理一个 I/O 设备文件，转而由一个线程来监听多个 I/O 文件，来提供系统的效率。poll/select/epoll 底层使用了这种 I/O 模式。<br><img src="/images/tcp/io-multiplexing.jpg" alt="io-multiplexing" title="io-multiplexing"></p>
<h2 id="2-select"><a href="#2-select" class="headerlink" title="2. select"></a>2. select</h2><h3 id="2-1-整体流程"><a href="#2-1-整体流程" class="headerlink" title="2.1 整体流程"></a>2.1 整体流程</h3><p>select 方法调用：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FD_SETSIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFDBITS (8 * sizeof(unsigned long))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __FDSET_LONGS (FD_SETSIZE/NFDBITS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据结构 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> fds_bits[__FDSET_LONGS];</span><br><span class="line">&#125; fd_set;</span><br><span class="line"></span><br><span class="line"><span class="comment">// select 文件调用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> max_fd,  <span class="comment">/* 最大文件数 */</span></span></span></span><br><span class="line"><span class="function"><span class="params">    fd_set *readset, <span class="comment">/* 读事件文件集合 */</span></span></span></span><br><span class="line"><span class="function"><span class="params">    fd_set *writeset, <span class="comment">/* 写事件文件集合 */</span></span></span></span><br><span class="line"><span class="function"><span class="params">    fd_set *exceptset, </span></span></span><br><span class="line"><span class="function"><span class="params">    struct timeval *timeout</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>; <span class="comment">// 返回值就绪描述符的数目</span></span><br></pre></td></tr></table></figure></p>
<p>从 select 方法定义来看，每次调用都需要将文件集合在用户空间及内核空间进行复制，并且文件最大的数量限制在 1024 个。组合上面的内容，可以知道 select 会定义两个函数 poll_queue_proc 和 唤醒 callback 函数，注册到 poll 函数中，在这里，这两个函数分别对应：__pollwait() 和 pollwake。其整体的流程如下所示：</p>
<p><img src="/images/tcp/select.jpg" alt="select" title="select"></p>
<p>select 调用主要做了三件事情：</p>
<ol>
<li>初始化poll_wqueues结构，包括几个关键函数指针的初始化，用于驱动中进行回调处理；</li>
<li>循环遍历监测的文件描述符，并且调用 f_op-&gt;poll() 函数，如果有监测条件满足，则会跳出循环；</li>
<li>在监测的文件描述符都不满足条件时，会让当前进程进行睡眠，超时唤醒，或者被所属的等待队列唤醒。</li>
</ol>
<p>select 函数的循环退出条件有三个：</p>
<ol>
<li>检测的文件描述符满足条件；</li>
<li>超时；</li>
<li>由等待事件触发。</li>
</ol>
<h3 id="2-2-数据结构"><a href="#2-2-数据结构" class="headerlink" title="2.2 数据结构"></a>2.2 数据结构</h3><p>接下来再看下 select 内部的数据结构：<br><img src="/images/tcp/select_data_struct.jpg" alt="select_data_struct" title="select_data_struct"><br>在 select 方法中，会维护一个 struct poll_wqueues 结构，其中两个关键字段：</p>
<ol>
<li>poll_table：该结构体中的函数指针_qproc指向__pollwait函数；</li>
<li>struct poll_table_entry[]：存放不同文件的 poll_table_entry，这些条目的增加是在驱动调用 __pollwait() 时进行初始化并完成添加的，每一个文件都会添加一个条目。</li>
</ol>
<p>在这个数据结构可以看出，调用 poll 函数之后，会在所有文件的等待队列中加入一个结点，这个结点会持有当前 task 的信息，当事件触发之后，从而可以知道唤醒那一个进程；</p>
<p>从上面的分析可以看出，select 有以下的缺点：</p>
<ol>
<li>每次 select 方法调用都会传入文件集合参数，涉及到用户空间及内核空间的两次复制；</li>
<li>每一次调用都需要遍历所有的文件调用 poll 函数，效率较低（在用户空间中，也需要遍历所有文件查看那些文件有事件触发）；</li>
<li>监听的文件数量有限，最大 1024 个。</li>
</ol>
<h2 id="3-epoll"><a href="#3-epoll" class="headerlink" title="3. epoll"></a>3. epoll</h2><h3 id="3-1-整体流程"><a href="#3-1-整体流程" class="headerlink" title="3.1 整体流程"></a>3.1 整体流程</h3><p>epoll 解决了 select 的缺点，在大并发场景下，epoll 得到了广泛的应用，它从以下几个方面解决了 select 的缺点：</p>
<ol>
<li>生成一个 epoll 文件，将监听的文件描述符加入到这个文件的数据结构（红黑树）中，只用添加一次，避免了数据的来回复制；</li>
<li>epoll 文件中维护了一个可读文件队列，每次只遍历该队列，避免所有文件的遍历；</li>
<li>监听的文件不受限制。</li>
</ol>
<p>下面我们来看下 epoll的实现原理，首先看下调用方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成一个 ep 文件，把所有需要监听的文件都放到 ep 文件中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> <span class="built_in">size</span>)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// epoll_ctl 添加一个监听的文件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">int</span> epfd,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">int</span> op, </span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">int</span> fd, </span></span></span><br><span class="line"><span class="function"><span class="params">	struct epoll_event *event</span></span></span><br><span class="line"><span class="function"><span class="params">	)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// epoll_wait 负责检测可读队列，没有可读的文件则阻塞进程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">int</span> epfd, </span></span></span><br><span class="line"><span class="function"><span class="params">	struct epoll_event * events, </span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">int</span> maxevents, </span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">int</span> timeout</span></span></span><br><span class="line"><span class="function"><span class="params">	)</span></span>;</span><br></pre></td></tr></table></figure>
<p>epoll_create 生成一个 ep 文件，通过 epoll_ctl 方法添加/删除文件，epoll_wait 方法只遍历满足条件的可读队列，提高了效率。这三个方法大概的逻辑如下描述。<br><strong>epoll_ctl 主要逻辑：</strong></p>
<ol>
<li>定义一个 epitem 结构，代表一个监听的文件，并加入到红黑树中；</li>
<li>生成一个等待结点，加入到这文件 （socket 文件）的等待队列中；</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">define epitem</span><br><span class="line">add_epitem_to_rbtree(epitem) </span><br><span class="line"></span><br><span class="line">define wait_entry</span><br><span class="line">wait_entry.socket = this_socket;</span><br><span class="line">wait_entry.callback = epoll_wakecallback;</span><br><span class="line">add_entry_to_list(wait_entry, this_socket.sleep_list);</span><br></pre></td></tr></table></figure>
<p><strong>epoll_wait 主要逻辑：</strong></p>
<ol>
<li>定义一个等待结点，将结点的 task （实际为 private 字段，为了简要描述，定义为 task） 设置为当前 task （调用 epoll_wait的进程），并设置回调函数；</li>
<li>判断当前可读队列是否为空，如果为空则将等待结点加入到 ep 文件的等待队列上，并阻塞该进程；</li>
<li>如果当前可读队列不为空，则遍历准备好的可读队列，返回数据给用户进程；</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">define single_wait_list</span><br><span class="line">define single_wait_entry</span><br><span class="line">single_wait_entry.callback = wakeup_common;</span><br><span class="line">single_wait_entry.task = current_task;</span><br><span class="line"><span class="keyword">if</span> (ready_list_is_empty); then</span><br><span class="line">    <span class="comment"># 等待结点加入到 ep 文件的等待队列中</span></span><br><span class="line">    add_entry_to_list(single_wait_entry, single_wait_list);</span><br><span class="line">go_on:  </span><br><span class="line">    <span class="comment"># 阻塞进程</span></span><br><span class="line">    schedule();</span><br><span class="line">    <span class="keyword">if</span> (sready_list_is_empty); then</span><br><span class="line">        goto go_on;</span><br><span class="line">    endif</span><br><span class="line">    del_entry_from_list(single_wait_entry, single_wait_list);</span><br><span class="line">endif</span><br><span class="line"><span class="comment"># 遍历准备好的可读队列</span></span><br><span class="line">for_each_ready_list <span class="keyword">as</span> sk; do</span><br><span class="line">    event.evt = sk.poll(...);</span><br><span class="line">    event.sk = sk;</span><br><span class="line">    put_event_to_user;</span><br><span class="line">done;</span><br></pre></td></tr></table></figure>
<p>在这里需要注意的是，当前进程不像 select 方法，进程是阻塞在监听文件（socket 文件）的等待队列上，而是阻塞在 ep 文件自己的阻塞队列上，如上面的流程所述。这里有问题，如何唤醒阻塞的进程？答案在注册到监听文件的回调函数上，在 epoll_ctl 中，我们同样在监听文件的等待队列上加入了一个等待结点，当文件可读时，调用该回调函数，借助该函数，再唤醒阻塞在 ep 文件等待队列上的进程，其流程如下所述：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">epoll_wakecallback(...)</span><br><span class="line">&#123;</span><br><span class="line">    add_this_socket_to_ready_list;</span><br><span class="line">    wakeup_single_epoll_waitlist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在唤醒进程之前，会将该文件加入到可读队列中。</p>
<p>epoll_wait 流程如下图所示：<br><img src="/images/tcp/epoll.jpg" alt="epoll" title="epoll"></p>
<h3 id="3-2-数据结构"><a href="#3-2-数据结构" class="headerlink" title="3.2 数据结构"></a>3.2 数据结构</h3><p>数据结构如下所示：<br><img src="/images/tcp/epoll_data_struct.jpg" alt="epoll_data_struct" title="epoll_data_struct"><br>关键点说明：</p>
<ol>
<li>进程阻塞在 epoll 文件的等待队列上，不是监听文件的等待队列上；</li>
<li>epoll 会将满足条件的文件提前放在可读文件队列 rdllist 中，减少文件遍历的数量；</li>
<li>epoll 将监听的文件使用红黑树管理，可有效地进行文件的添加及删除；</li>
<li>唤醒操作由监听文件等待队列中的回调函数触发，然后再唤醒阻塞在 epoll 文件上的进程。</li>
</ol>
<p>对应的数据结构定义为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 每创建一个epoll 文件, 内核就会分配一个eventpoll与之对应 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Protect the this structure access */</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> lock;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This mutex is used to ensure that files are not removed</span></span><br><span class="line"><span class="comment">     * while epoll is using them. This is held during the event</span></span><br><span class="line"><span class="comment">     * collection loop, the file cleanup path, the epoll file exit</span></span><br><span class="line"><span class="comment">     * code and the ctl operations.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mtx</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wait queue used by sys_epoll_wait() */</span></span><br><span class="line">    <span class="comment">/* epoll 文件等待队列，进程就是阻塞在该队列上 */</span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> wq;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wait queue used by file-&gt;poll() */</span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> poll_wait;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* List of ready file descriptors */</span></span><br><span class="line">    <span class="comment">/* 所有已经准备好的可读文件队列 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdllist</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* RB tree root used to store monitored fd structs */</span></span><br><span class="line">    <span class="comment">/* 红黑树，存储所有监听的文件 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">rbr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This is a single linked list that chains all the "struct epitem" that</span></span><br><span class="line"><span class="comment">     * happened while transfering ready events to userspace w/out</span></span><br><span class="line"><span class="comment">     * holding -&gt;lock.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">ovflist</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The user that created the eventpoll descriptor */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Each file descriptor added to the eventpoll interface will</span></span><br><span class="line"><span class="comment"> * have an entry of this type linked to the "rbr" RB tree.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* epitem 表示一个被监听的文件 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> &#123;</span></span><br><span class="line">    <span class="comment">/* RB tree node used to link this structure to the eventpoll RB tree */</span></span><br><span class="line">    <span class="comment">/* 代表在红黑树中的结点 */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="comment">/* RB tree node links this structure to the eventpoll RB tree */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rbn</span>;</span></span><br><span class="line">		<span class="comment">/* Used to free the struct epitem */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* List header used to link this structure to the eventpoll ready list */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdllink</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Works together "struct eventpoll"-&gt;ovflist in keeping the</span></span><br><span class="line"><span class="comment">     * single linked chain of items.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The file descriptor information this item refers to */</span></span><br><span class="line">    <span class="comment">/* epitem对应的文件和 struct file */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_filefd</span> <span class="title">ffd</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Number of active wait queue attached to poll operations */</span></span><br><span class="line">    <span class="keyword">int</span> nwait;</span><br><span class="line">    <span class="comment">/* List containing poll wait queues */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">pwqlist</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The "container" of this item */</span></span><br><span class="line">    <span class="comment">/* 关联的eventpoll结构 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* List header used to link this item to the "struct file" items list */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">fllink</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The structure that describe the interested events and the source fd */</span></span><br><span class="line">    <span class="comment">/* 当前文件关心的事件 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 红黑树结点 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>  __rb_parent_color;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rb_right</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rb_left</span>;</span></span><br><span class="line">&#125; __attribute__((aligned(<span class="keyword">sizeof</span>(<span class="keyword">long</span>))));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 红黑树根结点 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rb_node</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_filefd</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Wait structure used by the poll hooks */</span></span><br><span class="line"><span class="comment">/* 用于构造回调函数的数据结构，在 ep_ptable_queue_proc 中使用 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eppoll_entry</span> &#123;</span></span><br><span class="line">    <span class="comment">/* List header used to link this structure to the "struct epitem" */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">llink</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The "base" pointer is set to the container "struct epitem" */</span></span><br><span class="line">    <span class="comment">/* 关联的 epitem */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">base</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Wait queue item that will be linked to the target file wait</span></span><br><span class="line"><span class="comment">     * queue head.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* 添加到监听文件等待队列中的等待结点 */</span></span><br><span class="line">    <span class="keyword">wait_queue_t</span> wait;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The wait queue head that linked the "wait" wait queue item */</span></span><br><span class="line">    <span class="comment">/* 监听文件等待队列队首结点 */</span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> *whead;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Wrapper struct used by poll queueing */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ep_pqueue</span> &#123;</span></span><br><span class="line">    poll_table pt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Used by the ep_send_events() function as callback private data */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ep_send_events_data</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> maxevents;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> __<span class="title">user</span> *<span class="title">events</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>通过对 select 及 epoll 方法的分析，可以知道，epoll 从各个方面进行了优化，相对 select, 在大部分场景下，性能有了质的飞跃，这也是网络中间件中大部分选用 epoll 的原因。</p>
<p><strong>参考：</strong></p>
<hr>
<p><a href="https://coderbee.net/index.php/linux/20190919/1942" target="_blank" rel="noopener">1. Linux select/poll/epoll 原理（一）实现基础</a><br><a href="https://blog.csdn.net/eZiMu/article/details/54896708" target="_blank" rel="noopener">2. inux驱动—file_operations之poll</a><br><a href="https://mp.weixin.qq.com/s/bjM3uEDg61vhNN8Y661L7w" target="_blank" rel="noopener">3. Linux select/poll机制原理分析</a><br><a href="https://blog.csdn.net/dog250/article/details/50528373" target="_blank" rel="noopener">4. Linux内核中网络数据包的接收-第二部分 select/poll/epoll</a><br><a href="https://my.oschina.net/alchemystar/blog/3008840" target="_blank" rel="noopener">5. 从linux源码看epoll</a><br><a href="https://blog.csdn.net/russell_tao/article/details/17119729" target="_blank" rel="noopener">6. 高性能网络编程5–IO复用与并发编程</a><br><a href="https://blog.nowcoder.net/n/dade4d8c53d144dfa78157887e2cb33e" target="_blank" rel="noopener">7. epoll源码分析</a><br><a href="https://zhuanlan.zhihu.com/p/60713292" target="_blank" rel="noopener">8. 带您进入内核开发的大门 | 内核中的等待队列</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/20/illustrated-TCP-protocol/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/09/20/illustrated-TCP-protocol/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">图解TCP协议</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-09-20 16:58:48" itemprop="dateCreated datePublished" datetime="2020-09-20T16:58:48+08:00">2020-09-20</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-07-31 17:17:10" itemprop="dateModified" datetime="2021-07-31T17:17:10+08:00">2021-07-31</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/网络协议/" itemprop="url" rel="index"><span itemprop="name">网络协议</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">17k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">15 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇文章讲述网络报文从网卡 NIC （network interface controller）接收，再到操作系统网络协议栈处理，最后到用户程序接收报文处理报文的简化过程，希望能对TCP协议进行一个整体、概括性的总结。</p>
<h2 id="1-网络子系统"><a href="#1-网络子系统" class="headerlink" title="1. 网络子系统"></a>1. 网络子系统</h2><p>从网络中发送过来的网络报文首先到达网卡 NIC，使用 DMA 技术将报文拷贝到内存中，再发起中断请求 CPU 进行中断处理，CPU 调用驱动中的方法处理网络报文，处理完毕之后传给网络协议栈处理，如流程如下图所示：</p>
<p><img src="/images/tcp/data-received.jpg" alt="data-received" title="data-received"></p>
<ol>
<li>网卡 NIC 从外部网络收到报文；</li>
<li>网卡 NIC 通过 DMA 技术直接将报文拷贝到 RAM 中，以 SKB(Socket Buffer)结构存储。NIC 一般都会在 RAM 中申请一个环形的接收队列，代表了接收的能力（同时也会发送环形队列，用于报文的发送）；</li>
<li>网卡 NIC 向 CPU 触发一次硬件中断，通知有报文需要处理，如果只有一个 CPU，没有其它选择；如果是多 CPU 的情况，会涉及到 CPU 的选择，后面我们会进行讲述；</li>
<li>CPU 处理中断，调用 NIC 驱动注册到内核中的的中断处理函数，在这里我们以 NAPI 为例（NAPI 合并 IRQ(Interrupt ReQuest),减少中断次数）；</li>
<li>中断处理函数会关闭中断，后续报文直接由拷贝到内存中，避免后续报文重复触发中断；</li>
<li>触发软中断，进行报文处理，中断处理包含两个阶段：1）硬件中断，响应 NIC 中断信号，触发软件中断；2）软件中断，由专门的内核线程来执行，网络报文的处理是由软件中断来执行。</li>
</ol>
<p>上面的流程是简要的一个流程，有些知识链条是断裂的，下面将补充三个知识点：1）软件中断；2） NIC 与环形队列的关系；3） CPU 的选择问题。</p>
<h3 id="1-1-软件中断"><a href="#1-1-软件中断" class="headerlink" title="1.1 软件中断"></a>1.1 软件中断</h3><p>在设备驱动中，一般通过中断的方式告诉 CPU 数据已经准备好，可以来取数据了。在内核中，中断处理函数优先级非常高，同时会阻塞其它中断处理。所以要求硬件中断处理函数必须尽可能快、效率尽可能高。为了减少中断处理时间，引入了软件中断，将复杂的处理延迟到软件中断中处理，如网络报文的处理，而在硬件中断中触发软件中断。</p>
<p>系统在启动时，会为每一个 CPU 分配一个内核线程 ksoftirqd 线程，专门处理软件中断，目前能够处理的软件中断有6个，其中网络处理的有两个，分别是接收中断 NET_RX_SOFTIRQ 和 发送中断 NET_TX_SOFTIRQ。这两个中断在net_dev_init方法中注册到内核。初始化的流程如下所示：<br><img src="/images/tcp/softirq.jpg" alt="softirq" title="softirq"></p>
<ol>
<li>系统启动时，创建 ksoftirad 内核线程，处理软件中断，每一个 CPU 对应一个线程；</li>
<li>ksoftirqd 内部是一个事件处理处理函数 run_ksoftirqd，不断接收中断处理事件；</li>
<li>驱动为每一个 CPU 生成 poll_list 链表，主要是存放触发中断事件的 NIC设备；</li>
<li>注册软件中断处理函数 net_rx_action, 中断号为 NET_RX_SOFTIRQ(同时也会注册NET_TX_SOFTIRQ)，负责报文接收工作；</li>
<li>收到报文时，驱动为将触发中断的 NIC 加入到 CPU 的 poll_list中；</li>
<li>驱动设置 softirq_pending 中的 NET_RX_SOFTIRQ 标志位，表明需要处理 NET_RX_SOFTIRQ 中断；</li>
<li>run_ksoftirqd 检查到 softirq_pending 标志位，如果有设置标志位，执行 __do_softirq 函数；</li>
<li>__do_softirq 查找到 NET_RX_SOFTIRQ 对应的中断处理函数 net_rx_action，并执行该函数，处理报文的接收。</li>
</ol>
<h3 id="1-2-RSS"><a href="#1-2-RSS" class="headerlink" title="1.2 RSS"></a>1.2 RSS</h3><p>在多核的系统中，为了充分利用多核处理的优势，提高网络处理的吞吐量，NIC 引入了 RSS(Receive Side Scaling) 或 multiqueue 的技术。这种技术将 NIC 接收队列抽象为多个队列，每一个队列分配一个唯一的中断号，再将队列与某个 CPU 建立映射关系。输入的报文根据 NIC中的 hash 函数（根据Src ip, Src port, Dest ip, Dest port, Protocol）负载到指定的接收队列中，再根据对应的中断号触发硬件中断，后续的报文者将由指定的 CPU 来处理，整体的流程如下图所示：<br><img src="/images/tcp/RSS.jpg" alt="RSS" title="RSS"></p>
<ol>
<li>NIC 接收到外部报文；</li>
<li>使用 DMA 技术将报文拷贝到 SKB 双向链表中；</li>
<li>使用 hash 函数，将该报文负载到指定的队列中，将触发中断，每一个接收队列都对应一个环形队列，有大小的限制，超过容量之后，报文会丢弃；</li>
<li>在硬件中断中处理软件中断，与上面的内容一致。</li>
</ol>
<p>如果支持 RSS 的话，NIC 为每个队列分配一个 IRQ，通过 /proc/interrupts 进行查看，如下所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/interrupts</span><br><span class="line">           CPU0       CPU1       CPU2       CPU3</span><br><span class="line"> 56:   20209820    4671909   34469139    1896297   PCI-MSI-edge      ens160-rxtx-0</span><br><span class="line"> 57:    3259205    5165620    2125138    4534929   PCI-MSI-edge      ens160-rxtx-1</span><br><span class="line"> 58:    5883233   10958192    2339523   22326712   PCI-MSI-edge      ens160-rxtx-2</span><br><span class="line"> 59:    4307729    2329793    9003652   25191926   PCI-MSI-edge      ens160-rxtx-3</span><br></pre></td></tr></table></figure></p>
<p>可以看到，中断号 56~59 分别分配给了 4 个队列，通过 /proc/irq/IRQ_NUMBER/smp_affinity 设置某个中断由某个 CPU 触发，我们可以查看中断号 56 的配置情况。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/irq/56/smp_affinity</span><br><span class="line">4</span><br></pre></td></tr></table></figure></p>
<p>0 号 CPU 的掩码是 0x1 (0001)，1 号 CPU 掩码是 0x2 (0010)，2 号 CPU 掩码是 0x4 (0100)，3 号 CPU 掩码是 0x8 (1000) 依此类推。4 表示使用 CPU 2，另外可以查看或配置环形队列的长度。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ ethtool -g ens160</span><br><span class="line">Ring parameters <span class="keyword">for</span> ens160:</span><br><span class="line">Pre-set maximums:</span><br><span class="line">RX:             4096</span><br><span class="line">RX Mini:        0</span><br><span class="line">RX Jumbo:       4096</span><br><span class="line">TX:             4096</span><br><span class="line">Current hardware settings:</span><br><span class="line">RX:             256</span><br><span class="line">RX Mini:        0</span><br><span class="line">RX Jumbo:       128</span><br><span class="line">TX:             512</span><br></pre></td></tr></table></figure></p>
<p>在 NIC 中引入 RSS 技术，有效地提高了网络处理的吞吐量。如果硬件不支持 RSS 技术，内核提供了 RPS(Receive Packet Steering) 技术，通过软件的技术来实现多核处理网络报文。PRS 技术的原理是：硬件中断只由一个 CPU 处理，然后根据报文计算 hash 值并负载到特定的 CPU 上，通过 Inter-processor Interrupt(IPI) 通知特定的 CPU 来进行软件中断处理。 Receive Flow Steering(RFS) 一般和 RPS 配合一起工作。RPS 是将收到的报文分配到不同的 CPU 以实现负载均衡，保证同一个 Flow 的数据包都由一个 CPU 处理，类似会话绑定的技术。</p>
<p><img src="/images/tcp/RPS.jpg" alt="RPS" title="RPS"></p>
<p>可以通过 /proc/sys/net/core/netdev_max_backlog 查看 netdev_max_backlog 的默认值。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/sys/net/core/netdev_max_backlog</span><br><span class="line">1000</span><br></pre></td></tr></table></figure></p>
<h3 id="1-3-报文处理"><a href="#1-3-报文处理" class="headerlink" title="1.3 报文处理"></a>1.3 报文处理</h3><p>上面的内容讲述了硬件中断的相关内容，接下来进入软件中断的处理流程，其流程（以NAPI为例）如下所示：<br><img src="/images/tcp/net-rx-action.jpg" alt="net-rx-action" title="net-rx-action"><br>net_rx_action 函数处理当前 CPU 中设备列表中的设备( NAPI poll structure)，这些设备主要来自两个地方：1）驱动中调用 napi_schedule 方法加入；2）使用 Inter-processor Interrupt 方法加入（RPS），具体流程如下：</p>
<ol>
<li>遍历当前 CPU 的设备列表 poll_list，处理所有的 NAPI 设备；</li>
<li>检查 budget 及软件中断的运行时间，避免处理函数占用过多的 CPU 时间，控制 budget 可以影响执行的时间，它可以通过 net.core.netdev_budget 参数进行配置；</li>
<li>调用驱动中注册的 poll函数，在 igb 驱动中调用的是 igb_poll 函数；</li>
<li>poll 函数读取环形队列中的 packet ；</li>
<li>如果设备支持 GRO，则需要调用 napi_gro_receive 函数，Generic Receive Offloading(GRO) 是 Large receive offload 的一个实现，LRO 就是在收到多个数据包的时候将同一个 Flow 的多个数据包按照一定的规则合并起来交给上层处理，这样就能减少上层需要处理的数据包数量；</li>
<li>报文传给 net_receive_skb，进行下一步处理。</li>
</ol>
<p>在 netif_receive_skb 方法中，会根据是否开启 RPS 来进行不同处理，如果开启了 RPS，会使用 IRI (Inter-processor Interrupt )技术，将报文转给远程 CPU 进行处理，实现类似硬件 RSS 的技术；如果未开启，除了将报文分发给 taps(PCAP), 实现抓包功能，同时将报文传给 IP 协议层，由 IP 协议进行下一步处理，其流程如下所示：<br><img src="/images/tcp/netif-receive-skb.jpg" alt="netif-receive-skb" title="netif-receive-skb"><br>开启 RPS 功能：</p>
<ol>
<li>将报文传给 enqueue_to_backlog 方法；</li>
<li>报文加入到远程 CPU 的输入队列中；</li>
<li>将 NIC 加入到远程 CPU 的设备列表中，使用 IRI, 触发过程 CPU 的软件中断；</li>
<li>远程 CPU 读取输入队列中的报文；</li>
<li>将报文传给 __net_receive_skb_core 方法；</li>
<li>将报文分发给 taps(PCAP), 实现抓包功能；</li>
<li>将报文传给 IP 协议层，进行下一步处理。</li>
</ol>
<p>未开启 RPS 功能：</p>
<ol>
<li>将报文传给 __net_receive_skb_core 方法；</li>
<li>将报文分发给 taps(PCAP), 实现抓包功能；</li>
<li>将报文传给 IP 协议层，进行下一步处理。</li>
</ol>
<h2 id="2-IP-协议层"><a href="#2-IP-协议层" class="headerlink" title="2. IP 协议层"></a>2. IP 协议层</h2><p>IP 协议层主要是实现路由功能，结合 netfilter 定义的钩子函数，可以通过 iptables 配置 ip 路由功能，流程如下所示：<br><img src="/images/tcp/ip-rcv.jpg" alt="ip-rcv" title="ip-rcv"><br>在这里有三个 netfilter 钩子函数：</p>
<ol>
<li>NF_INET_PRE_ROUTING：可以在路由前对数据包进行修改或丢弃；</li>
<li>NF_INET_FORWARD：实现转发功能；</li>
<li>NF_INET_LOCAL_IN：本地 IP 的入口，触发相应的配置。</li>
</ol>
<h2 id="3-TCP-协议层"><a href="#3-TCP-协议层" class="headerlink" title="3. TCP 协议层"></a>3. TCP 协议层</h2><p>报文到了 TCP 协议层，会根据 socket 锁被占用的状态，将报文发送到不同的接收队列，在这里有 4 个队列，分别是：receive queue, out_of_order queue, prequeue queue, backlog queue。通过接收队列，内核软件中断线程与 socket 线程实现了数据的交换。<br><img src="/images/tcp/tcp-v4-rcv.jpg" alt="tcp-v4-rcv" title="tcp-v4-rcv"></p>
<p>4 个队列使用场景：</p>
<ol>
<li>receive queue ：当 socket 没有被线程占用的时候，报文会加入到该队列；</li>
<li>out_of_order queue ：临时存放乱序的报文；</li>
<li>prequeue queue ：当 socket 被占用且 tcp_low_latency 值为 0 时，报文加入该队列；</li>
<li>backlog queue ：当 socket 正在被读取时，新收到的所有报文加入到该队列（如果报文是乱序的，后续还要加入到out_of_order queue）。</li>
</ol>
<p>如果 tcp_low_latency 值为 1 时，报文不加入到 prequeue queue，内核软件中断线程直接将数据复制到用户态。</p>
<blockquote>
<p>接收缓存<br>对收消息过程来说，Socket 占用内存量就是 Receive Queue、Prequeue、Backlog、Out of order 队列内排队的 sk_buff(SKB) 占用内存总数。在内核中可以使用两个参数进行配置：net.core.rmem_max 和 net.core.rmem_default。</p>
</blockquote>
<p>最后数据拷贝到用户态之后，表示用户线程已经接到了数据，至此接收流程结束。</p>
<h2 id="4-报文发送"><a href="#4-报文发送" class="headerlink" title="4. 报文发送"></a>4. 报文发送</h2><p>报文接收流程已经讲述完毕，接下来我们再看下报文的接收流程。</p>
<h3 id="4-1-TCP-协议层"><a href="#4-1-TCP-协议层" class="headerlink" title="4.1 TCP 协议层"></a>4.1 TCP 协议层</h3><p>报文发送流程从 TCP 协议层开始，其主要流程如下所示：<br><img src="/images/tcp/tcp-sendmsg.jpg" alt="tcp-sendmsg" title="tcp-sendmsg"></p>
<ol>
<li>用户线程调用 send 方法发送用户态的数据；</li>
<li>sk_stream_wait_memory：判断发送队列是否有足够的空间发送数据，如果没有则等待一定时间，等待已经发送数据的 ACK 确认信息，如果收到则释放 SKB 数据，腾出空间以便后续数据的发送。TCP 连接分配的发送缓存是有限的，可以通过（ /proc/sys/net/core/wmem_default ）进行配置；</li>
<li>tcp_sendmsg ：将用户态的数据按照 MSS ( Maximum Segment Size ) 进行分片，并封装到 SKB 结构中。为了避免数据链路层进行分片，TCP 层传输的数据应小于该层的最大传输单元（MTU）,以太网 MTU 为 1500 字节，扣除 TCP, IP 头的 40 个字节，MSS 最大的值为 1460 字节；</li>
<li>tcp_push ：根据 Nagle 算法，将发送的队列发送到 IP 协议层，这里会受滑动窗口和拥塞窗口的影响。</li>
</ol>
<blockquote>
<p>滑动窗口<br>TCP 连接上的双方都会通知对方自己的接收窗口大小。而对方的接收窗口大小就是自己的发送窗口大小。tcp_push 在发送数据时需要与发送窗口打交道。发送窗口是一个时刻变化的值，随着 ACK 的到达会变大，随着发出新的数据包会变小。当然，最大也只能到三次握手时对方通告的窗口大小。</p>
</blockquote>
<blockquote>
<p>拥塞窗口<br>拥塞窗主要是根据网络的拥塞情况控制报文发送的数量，从而达到改善网络传输的目的。TCP 连接刚建立时，拥塞窗口的大小远小于发送窗口，它实际上是一个 MSS。每收到一个 ACK，拥塞窗口扩大一个 MSS 大小，当然，拥塞窗口最大只能到对方通告的接收窗口大小。当然，为了避免指数式增长，拥塞窗口大小的增长会更慢一些，是线性的平滑的增长过程。所以，在tcp_push发送消息时，还会检查拥塞窗口，飞行中的报文数要小于拥塞窗口个数，而发送数据的长度也要小于拥塞窗口的长度。</p>
</blockquote>
<h3 id="4-2-IP-协议层"><a href="#4-2-IP-协议层" class="headerlink" title="4.2 IP 协议层"></a>4.2 IP 协议层</h3><p>IP 协议层将 IP 转换为 MAC 地址，进行下一跳数据的发送。在发送前，可以对 IP 地址进行重写，重写进行路由，实现 SNAT 功能。<br><img src="/images/tcp/ip_send_skb.jpg" alt="ip_send_skb" title="ip_send_skb"></p>
<p>在发送阶段，同样涉及到 netfilter 钩子函数，包括：</p>
<ol>
<li>NF_INET_LOCAL_OUT ：从本机发出的数据包，在查询路由成功之后，会调用__ip_local_out_sk 函数,首先进行必要字段设置和校验和计算，然后经过 NF_INET_LOCAL_OUT 钩子点，之后会调用 dst_output_sk 继续完成数据包输出的其他工作；</li>
<li>NF_INET_POST_ROUTING ：转发的数据包或者是本地输出的数据包，最后都会经过 ip_output 进行输出，设置设备和协议之后，经过NF_INET_POST_ROUTING 钩子点，之后调用 ip_finish_output 进行后续输出操作，其中包括了分片等</li>
</ol>
<h3 id="4-3-网络子系统"><a href="#4-3-网络子系统" class="headerlink" title="4.3 网络子系统"></a>4.3 网络子系统</h3><p><img src="/images/tcp/dev_queue_xmit.jpg" alt="dev_queue_xmit" title="dev_queue_xmit"></p>
<ol>
<li>dev_queue_xmit：在该函数中，会先获取设备对应的qdisc，如果没有的话（如loopback或者IP tunnels），就直接调用dev_hard_start_xmit，否则数据包将经过 Traffic Control 模块进行处理；</li>
<li>Traffic Control: 进行一些过滤和优先级处理，在这里，如果队列满了的话，数据包会被丢掉；</li>
<li>dev_hard_start_xmit： 该函数中，首先是拷贝一份 SKB 给 “packet taps” ，tcpdump 就是从这里得到数据的，然后调用 ndo_start_xmit。如果 dev_hard_start_xmit 返回错误的话，则触发软件中断 NET_TX_SOFTIRQ，交给软件中断处理程序 net_tx_action 稍后重试。</li>
<li>ndo_start_xmit：会调用驱动中的函数进行数据的发送。</li>
</ol>
<h3 id="4-4-驱动"><a href="#4-4-驱动" class="headerlink" title="4.4 驱动"></a>4.4 驱动</h3><p>ndo_start_xmit 调用驱动中的函数，进行数据的发送，其大概的流程如下：</p>
<ol>
<li>将 SKB 放入网卡自己的发送队列 （环形队列）；</li>
<li>通知网卡发送数据包；</li>
<li>网卡发送完成后发送中断给CPU；</li>
<li>收到中断后进行 SKB 的清理工作。</li>
</ol>
<h2 id="5-其它"><a href="#5-其它" class="headerlink" title="5. 其它"></a>5. 其它</h2><p>在上面的内容中提到每一个 CPU 都会关联一个 softnet_data 类型的数据结构，这个数据结构存放了与网络相关的信息，其结构如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">softnet_data</span></span></span><br><span class="line"><span class="class">&#123;</span>           </span><br><span class="line">    <span class="comment">/*throttle用于拥塞控制,当拥塞时被设置,此后来的数据包都被丢弃*/</span></span><br><span class="line">    <span class="keyword">int</span> throttle;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*netif_rx返回的拥塞级别*/</span></span><br><span class="line">    <span class="keyword">int</span> cng_level;</span><br><span class="line">    <span class="keyword">int</span> avg_blog;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*input_pkt_queue是skb的队列,接收到的skb全都进入到此队列等待后续处理*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff_head</span> <span class="title">input_pkt_queue</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*poll_list是一个双向链表,链表的成员是有接收数据等待处理的device*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">poll_list</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*net_device链表,成员为有数据报要发送的device*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">output_queue</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*完成发送的数据包等待释放的队列*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">completion_queue</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*注意,backlog_dev不是一个指针,而是一个net_device实体,代表了调用net_rx_action时的device*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> <span class="title">backlog_dev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>这篇文章从整体的维度分析了 TCP 接收和发送报文的流程，这个流程只是一个大概且略显粗糙，如果读完这篇文章，能够对 TCP 有一个系统性的理解，目的也就达到了。</p>
<p><strong>参考：</strong></p>
<hr>
<p><a href="https://segmentfault.com/a/1190000008836467" target="_blank" rel="noopener">1. Linux网络 - 数据包的接收过程</a><br><a href="https://segmentfault.com/a/1190000008926093" target="_blank" rel="noopener">2. Linux网络 - 数据包的发送过程</a><br><a href="https://blog.packagecloud.io/eng/2017/02/06/monitoring-tuning-linux-networking-stack-sending-data/" target="_blank" rel="noopener">3. Monitoring and Tuning the Linux Networking Stack: Sending Data</a><br><a href="https://blog.packagecloud.io/eng/2016/10/11/monitoring-tuning-linux-networking-stack-receiving-data-illustrated/" target="_blank" rel="noopener">4. Illustrated Guide to Monitoring and Tuning the Linux Networking Stack: Receiving Data</a><br><a href="https://ylgrgyq.github.io/2017/08/01/linux-receive-packet-3/" target="_blank" rel="noopener">5. Linux 网络协议栈收消息过程-TCP Protocol Layer</a><br><a href="https://ylgrgyq.github.io/2017/07/23/linux-receive-packet-1/" target="_blank" rel="noopener">6. Linux 网络协议栈收消息过程-Ring Buffer</a><br><a href="https://ylgrgyq.github.io/2017/07/24/linux-receive-packet-2/" target="_blank" rel="noopener">7. Linux 网络协议栈收消息过程-Per CPU Backlog</a><br><a href="https://blog.csdn.net/russell_tao/article/details/9950615" target="_blank" rel="noopener">8. 高性能网络编程3—-TCP消息的接收</a><br><a href="https://blog.csdn.net/russell_tao/article/details/9370109" target="_blank" rel="noopener">9. 高性能网络编程2—-TCP消息的发送</a><br><a href="https://blog.csdn.net/cloudvtech/article/details/80182074" target="_blank" rel="noopener">10. 容器云负载均衡之三：RSS、RPS、RFS和XPS调整</a><br><a href="https://blog.51cto.com/enchen/191923" target="_blank" rel="noopener">11. 数据报的接收过程详解</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Noahsark</p>
              <p class="site-description motion-element" itemprop="description">不畏将来，不念过往</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">44</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">19</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">153</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Noahsark</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数">184k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
    <span title="站点阅读时长">2:47</span>
  
</div>

<div class="BbeiAn-info">
    <a target="_blank" href="https://beian.miit.gov.cn/" rel="nofollow">粤ICP备 2021097726号-1 </a>
	<a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44030702004132" style="text-decoration:none;padding-left:30px;background:url(https://s1.ax1x.com/2018/09/29/ilmwIH.png) no-repeat left center" rel="nofollow">粤公网安备 44030702004132号</a>
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v6.5.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.5.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.5.0"></script>



  



  










  





  

  

  

  

  

  
  

  

  

  

  

  

  

</body>
</html>
