<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.5.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.5.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.5.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.5.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="不畏将来，不念过往">
<meta name="keywords" content="Java">
<meta property="og:type" content="website">
<meta property="og:title" content="以太格">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="以太格">
<meta property="og:description" content="不畏将来，不念过往">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="以太格">
<meta name="twitter:description" content="不畏将来，不念过往">






  <link rel="canonical" href="http://yoursite.com/page/2/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>以太格</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">以太格</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-commonweal">

    
    
    
      
    

    

    <a href="/404/" rel="section"><i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>公益 404</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于我</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/02/deep-understanding-of-high-concurrency/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/08/02/deep-understanding-of-high-concurrency/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">思维导图-高并发</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-08-02 15:28:15" itemprop="dateCreated datePublished" datetime="2020-08-02T15:28:15+08:00">2020-08-02</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-07-31 17:17:10" itemprop="dateModified" datetime="2021-07-31T17:17:10+08:00">2021-07-31</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/思维导图/" itemprop="url" rel="index"><span itemprop="name">思维导图</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇文章是对《高并发，你真的理解透彻了吗？》的记录及整理。</p>
<p><img src="/images/high-concurrency/high-concurrency.jpeg" alt="high-concurrency" title="high-concurrency"></p>
<p><strong>参考：</strong></p>
<hr>
<p><a href="https://mp.weixin.qq.com/s/lc0a8eIRL94gqeb9R1kQzg" target="_blank" rel="noopener">1. 高并发，你真的理解透彻了吗？</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/19/garbage-collecton/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/07/19/garbage-collecton/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">垃圾回收之回收算法</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-07-19 16:57:52" itemprop="dateCreated datePublished" datetime="2020-07-19T16:57:52+08:00">2020-07-19</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-07-31 17:17:10" itemprop="dateModified" datetime="2021-07-31T17:17:10+08:00">2021-07-31</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java基础/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>几乎所有的现代编程语言都使用动态内存分配，即允许进程在运行时分配或释放无法在编译期确定大小的对象，这些对象的存活时间有可能超出创建者的生存周期。动态分配的对象存在于堆（heap）中而不是栈（stack）或者静态区（statically）中。在内存的管理方式上，有两种方式：1）显示内存释放，由开发人员显示的创建或释放对象；2）自动动态内存管理，由编程语言的运行时系统（虚拟机）负责内存的回收。自动动态内存管理可以显著地降低开发成本，提供程序的健壮性。我们这篇文章主要便是讲述内存管理中常用垃圾回收算法，并结合 java来分析内部的实现。</p>
<p>垃圾回收的目的是回收程序不再使用的对象所占用的空间，任何具备自动内存管理系统的语言都要有三个功能：</p>
<ol>
<li>为新对象分配空间；</li>
<li>确定存活对象；</li>
<li>回收死亡对象所占用的空间。</li>
</ol>
<p>内存分配与回收是相关性比较强的两个功能，内存管理系统都要具备这两个功能；在实现中，使用指针的可达性来近似对象的存活：只有当堆中存在一条从根出发的指针链能最终到达某个对象时，才能认定该对象存活，更进一步，如果不存在这一条指针链，则认为对象死亡，其空间可以得到回收。回收死亡对象包括两种方式：1）直接释放该对象，有可能会与前后的空闲对象进行合并；2）将存活对象进行移动或整理，减少内存碎片的问题。</p>
<h2 id="1-标记-清扫"><a href="#1-标记-清扫" class="headerlink" title="1. 标记 - 清扫"></a>1. 标记 - 清扫</h2><p>标记 - 清除算法分为两个阶段：1）追踪（trace）阶段，即回收器（回收程序）从根集合（寄存器、线程栈、全局变量）开始遍历对象图，并标记（mark）所遇到的每一个对象；2）清扫（sweep）阶段，即回收器检查堆中每一个对象，并将所有未标记的对象当作垃圾进行回收。其算法如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">New():  // 新建对象</span><br><span class="line">    ref = allocate()</span><br><span class="line">    if ref == null    // 堆中没有可用空间</span><br><span class="line">        collect()     // 进行一次内存回收</span><br><span class="line">        ref = allocate()</span><br><span class="line">        if ref == null // 堆中仍然没有可用空间</span><br><span class="line">            error &quot;Out of memory&quot;</span><br><span class="line"></span><br><span class="line">collect():  // 回收对象</span><br><span class="line">    markFromRoots()</span><br><span class="line">    sweep(HeapStart, HeapEnd)</span><br></pre></td></tr></table></figure>
<p>在新建对象的方法中，会给对象分配一块内存空间，如果堆中没有足够的可用空间，会进行一次内存回收，回收之后再分配一次内存，如果堆中仍然没有足够的可用空间，则抛出错误。<br>在回收对象的方法中，会从根集合开始，对存活的对象进行标记，然后遍历整个堆，对未标记的对象执行回收操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">markFromRoots():</span><br><span class="line">    initialise(worklist)</span><br><span class="line">    for each fld in Roots</span><br><span class="line">        ref = *fld</span><br><span class="line">        if ref != null &amp;&amp; not isMarked(ref)</span><br><span class="line">            setMarked(ref)</span><br><span class="line">            add(wokrklist,ref)</span><br><span class="line">            mark()</span><br><span class="line"></span><br><span class="line">initialise(worklist) </span><br><span class="line">    worklist = empty</span><br><span class="line"></span><br><span class="line">mark():</span><br><span class="line">    while not isEmpty(worklist)</span><br><span class="line">        ref = remove(worklist)</span><br><span class="line">        for each fld in (Pointers(ref))</span><br><span class="line">            child = *fld</span><br><span class="line">            if ref != null &amp;&amp; not isMarked(ref)</span><br><span class="line">                setMarked(child)</span><br><span class="line">                add(worklist,child)</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong><br>1) Roots：表示根集合，包含指针扫描的起点，主要是指寄存器、线程栈和全局变量；<br>2）Pointers(ref)：表示ref指针指向的对象中包含的指针集合；</p>
<p><strong>如何得到根集合和对象中的指针集合，我们会在后面的文章再讲解，现在假定我们已经知道这些值。</strong></p>
<p>我们可以将堆看作是一个图的结构，对象是结点，结点间的指针（引用）是边，根便是图的起始结点。对堆对象进行标记就是对对象图进行遍历操作，在上面的算法中使用的深度优先遍历算法。在算法中使用栈来实现工作列表，先从根结点开始，将标记过的对象放入工作列表中，然后取出对象对其所指向的对象进行标记，直到工作列表为空。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sweep(start,end):</span><br><span class="line">    scan = start</span><br><span class="line">    while scan &lt; end</span><br><span class="line">        if (isMarked(scan))</span><br><span class="line">            unsetMarked(scan)</span><br><span class="line">        else </span><br><span class="line">            free(scan)</span><br><span class="line">        scan = nextObject(scan)</span><br></pre></td></tr></table></figure>
<p>清除操作将堆中的所有对象看作一个对象列表，可以从堆的起始地址遍历所有对象，如果对象被标记则取消标记，进行下一轮的回收，如果未标记，则说明是一个死对象，则进行回收，回收的策略取决于具体的实现。如何对堆中的对象进行遍历，我们将在后面的文章进行讲解。一个完整的标记-清扫算法如下所示：<br><img src="/images/mark-sweep.gif" alt="mark-sweep" title="mark-sweep"></p>
<h3 id="1-1-三色遍历"><a href="#1-1-三色遍历" class="headerlink" title="1.1 三色遍历"></a>1.1 三色遍历</h3><p>标记的核心操作之一就是从给定的根集合出发去遍历对象图。遍历它有两种典型顺序：深度优先（DFS）和广度优先（BFS）。</p>
<p>广度优先遍历的典型实现思路是三色遍历：给对象赋予白、灰、黑三种颜色以标记其遍历状态：<br>1）白色：未遍历到的对象，所有对象的初始状态都是白色；<br>2）灰色：已遍历到但还未处理完的对象，即还有出边没有遍历；<br>3）黑色：已遍历完的对象，所有出边已经遍历。</p>
<p><img src="/images/tricolour-abstraction.gif" alt="tricolour-abstraction" title="tricolour-abstraction"></p>
<p>算法的步骤如下：<br>1）算法开始，所有的对象标记为白色；<br>2）从根集合开始，将引用到的对象标记为灰色；<br>3）从灰色集合中取出对象，遍历其所有出边，将遍历到的对象标记为灰色，遍历结束，将该对象标记为黑色；<br>4）重复第三步，直到没有灰色对象，最后未被遍历到白色对象即为死亡对象。</p>
<h2 id="2-标记-整理"><a href="#2-标记-整理" class="headerlink" title="2. 标记 - 整理"></a>2. 标记 - 整理</h2><p>标记-清扫算法只是对不再存活的对象进行释放，不会对存活的对象进行移动，这会造成碎片的问题，即使可用内存大于对象分配所需的内存，由于这些内存不是连续的，最终会导致分配失败。为了解决这个问题，引入了标记-整理算法。该算法在标记-清除算法的基础上，会将存活的对象统一移动到某一端，让它们连续存储在一起，从而得到较大的可用内存。根据移动前后的位置，有三种移动的顺序：</p>
<ol>
<li>任意顺序：对象的移动顺序与它们的原始排列顺序和引用没有关系；</li>
<li>线性顺序：将具有关联关系的对象排列在一一起，如对象之间的引用关系或同一个数据结构中相邻的对象；</li>
<li>滑动顺序：将对象滑动到堆的一端，保持对象在堆中原有的分配顺序。</li>
</ol>
<p>这里会分别介绍四种整理算法：1）双指针整理算法；2）Lisp 2算法；3）引线整理算法；4）单次遍历算法。其中除了双指针整理算法是按照任意顺序移动对象，其它算法都是滑动顺序。所有的整理算法都遵循下面的范式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">collect():</span><br><span class="line">    markFromRoots();</span><br><span class="line">    compact()</span><br></pre></td></tr></table></figure></p>
<h3 id="2-1-双指针整理算法"><a href="#2-1-双指针整理算法" class="headerlink" title="2.1 双指针整理算法"></a>2.1 双指针整理算法</h3><p>双指针整理算法需要遍历两次堆，适用于只包含固定大小对象的区域。该算法流程如下：</p>
<ol>
<li>计算出“高水位标记”，地址大于该阈值的存活对象都被移动该阈值之下；</li>
<li>设置两个指针，free 指针指向区域始端，scan 指针指向区域末端；</li>
<li>第一次遍历，free 指针向后移动，找到空闲区域为止，scan 指针向前移动，找到存活对象为止；</li>
<li>将 scan 指针指向的存活对象移动到 free 指向的空闲区域，并将scan对象中的“转发指针”设置为 free ，方便下次做指针的更新；</li>
<li>重新移动 free 及 scan 指针，直到 free &gt; scan 为止；</li>
<li>第二次遍历，更新指针存活对象中的指针，如果指针指向的地址中存在“转发指针”则直接更新该转发地址，算法结束。</li>
</ol>
<p>算法过程如下所示：<br><img src="/images/gc/two-points-init.jpg" alt="two-points-init" title="two-points-init"><br>初始状态下:1）有A, B, C, D 4个存活对象，其中 C 对象中有两个指针分别指向 A 和 B 两个对象。</p>
<p><img src="/images/gc/two-points-first.jpg" alt="two-points-first" title="two-points-first"><br>第一次遍历，将 A 和 B 两个对象移动到低地址区域，同时将移动后的地址写入到之前的对象中。</p>
<p><img src="/images/gc/two-points-second.jpg" alt="two-points-second" title="two-points-second"><br>第二次遍历，根据“转移地址”更新 C 对象中的 A 和 B 两个指针。</p>
<p>在双指针整理算法中，移动前后的存储对象的空闲空间大小最好是相等的，否则寻找匹配大小的空闲空间需要来回移动free指针，这样会降低算法的执行效率，另外，在该算法中，移动的顺序是任意的，会破坏赋值操作的局部性。</p>
<p>整理算法的伪代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">compact():</span><br><span class="line">    relocate(HeapStart, HeapEnd)</span><br><span class="line">    updateReferences(HeapStart, free)</span><br><span class="line"></span><br><span class="line">relocate(start, end):</span><br><span class="line">    free = start</span><br><span class="line">    scan = end</span><br><span class="line"></span><br><span class="line">    while free &lt; scan</span><br><span class="line">        while isMarked(free)</span><br><span class="line">            unsetMarked(free)</span><br><span class="line">            free = free + size(free)    /* 寻找下一个空闲块 */</span><br><span class="line">        </span><br><span class="line">        while not isMarked(scan) &amp;&amp; scan &gt; free</span><br><span class="line">            scan = scan - size(scan)    /* 寻找前一个存活对象 */</span><br><span class="line">        </span><br><span class="line">        if scan &gt; free</span><br><span class="line">            unsetMarked(scan)</span><br><span class="line">            move(scan, free)</span><br><span class="line">            *scan = free    /* 记录转发地址 */</span><br><span class="line">            free = free + size(free)</span><br><span class="line">            scan = scan - size(scan)</span><br><span class="line"></span><br><span class="line">updateReferences(start, end):</span><br><span class="line">    for each fld in Roots   /* 更新指向被移动对象的根 */</span><br><span class="line">        ref = *fld</span><br><span class="line">        if ref &gt;= end</span><br><span class="line">            *fld = *ref     /* 更新转发地址 */</span><br><span class="line">    </span><br><span class="line">    scan = start</span><br><span class="line">    while scan &lt; end</span><br><span class="line">        for each fld in Pointers(scan)</span><br><span class="line">            ref = *fld</span><br><span class="line">            if ref &gt;= end</span><br><span class="line">                *fld = *ref     /* 更新转发地址 */</span><br><span class="line">        scan = scan + size(scan)    /* 下一个对象 */</span><br></pre></td></tr></table></figure></p>
<h3 id="2-2-Lisp-2-算法"><a href="#2-2-Lisp-2-算法" class="headerlink" title="2.2 Lisp 2 算法"></a>2.2 Lisp 2 算法</h3><p>Lisp 2 算法对管理的对象大小没有限制，它可以管理包含多种大小对象的空间，同时移动的时候采用滑动顺序，不会改变对象的相对顺序。不过整理的过程需要遍历三次堆，算法的流程如下：</p>
<ol>
<li>第一次遍历：计算移动的位置。假定需要整理的内存区域起始地址、结束地址分别为 heapStart 、heapEnd，移动后的内存区域起始地址为toRegion，其中 heapStart 和 toRegion 可以是同一个地址；</li>
<li>将 scan 指向 heapStart 地址，free 指针指向 toRegion地址，开始遍历存活对象，找到存活对象之后，将存活对象中的 forwadingAddress 域设置为 free，然后将 scan 和 free 向后移动 size(存活对象) 大小的位置，当 scan 大于 heapEnd 之后，第一次遍历结束；</li>
<li>第二次遍历：更新转发地址的值。遍历根集合和堆中所有的对象，更新对象指针域中指向的地址为 forwadingAddress 中的地址；</li>
<li>第三次遍历：移动对象。遍历堆中所有对象，将对象移动到 forwadingAddress 指向的地址。</li>
</ol>
<p>算法过程如下所示：<br><img src="/images/gc/lisp2-init.jpg" alt="lisp2-init" title="lisp2-init"><br>初始状态下:1）有A, B, C, D 4个存活对象，其中 C 对象中有两个指针分别指向 A 和 B 两个对象。</p>
<p><img src="/images/gc/lisp2-first.jpg" alt="lisp2-first" title="lisp2-first"><br>第一次遍历，在每一个对象中，增加一个forwadingAddress 域，即 FA域，存放移动后的地址，移动后的地址通过遍历可以获得。</p>
<p><img src="/images/gc/lisp2-second.jpg" alt="lisp2-second" title="lisp2-second"><br>第二次遍历，更新堆中所有对象的指针域，重新指向 FA 域指向的地址。</p>
<p><img src="/images/gc/lisp2-third.jpg" alt="lisp2-third" title="lisp2-third"><br>第三次遍历，根据对象中的 FA 域的值，将该对象移动到 FA 域指向的地址。</p>
<p>Lisp 2 算法需要遍历三次堆，同时对象中需要一个 forwadingAddress 域，用来存放“转发的地址”。</p>
<p>Lisp 2 算法的伪代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">compact():</span><br><span class="line">    computeLocations(HeapStart, HeapEnd, HeapStart)     /* 计算转发地址 */</span><br><span class="line">    updateReferences(HeapStart, HeapEnd)    /* 更新转发地址 */</span><br><span class="line">    relocate(HeapStart, HeapEnd)    /* 移动指针 */</span><br><span class="line"></span><br><span class="line">/* 计算转发地址 */</span><br><span class="line">computeLocations(start, end, toRegion)</span><br><span class="line">    scan = start</span><br><span class="line">    free = toRegion</span><br><span class="line"></span><br><span class="line">    while scan &lt; end</span><br><span class="line">        if isMarked(scan)</span><br><span class="line">            forwardingAddress(scan) = free  /* 设置转发地址 */</span><br><span class="line">            free = free + size(scan)</span><br><span class="line">        scan = scan + size(scan)</span><br><span class="line"></span><br><span class="line">/* 更新转发地址 */</span><br><span class="line">updateReferences(start, end)</span><br><span class="line">    for each fld in Roots   /* 更新根 */</span><br><span class="line">        ref = *fld</span><br><span class="line">        if ref != null</span><br><span class="line">            *fld = forwardingAddress(ref)</span><br><span class="line">    </span><br><span class="line">    scan = start</span><br><span class="line">    while scan &lt; end</span><br><span class="line">        if isMarked(scan)</span><br><span class="line">            for each fld in Pointers(scan)</span><br><span class="line">                if *fld != null</span><br><span class="line">                    *fld = forwardingAddress(*fld)</span><br><span class="line">        scan = scan + size(scan)</span><br><span class="line"></span><br><span class="line">/* 移动指针 */</span><br><span class="line">relocate(start, end)</span><br><span class="line">    scan = start</span><br><span class="line">    while scan &lt; end</span><br><span class="line">        if isMarked(scan)</span><br><span class="line">            dest = forwardingAddress(scan)</span><br><span class="line">            move(scan, dest)</span><br><span class="line">            unsetMarked(dest)</span><br><span class="line">        scan = scan + size(scan)</span><br></pre></td></tr></table></figure>
<h3 id="2-3-引线整理算法"><a href="#2-3-引线整理算法" class="headerlink" title="2.3 引线整理算法"></a>2.3 引线整理算法</h3><p>Lisp 2 算法有两个缺陷：1）需要遍历三次堆；2）每一个对象需要额外的空间来记录转发地址。引线整理算法通过一种不同的策略来解决指针更新的问题，该算法不需要额外存储，且支持滑动整理。引线算法要求对象头部存在足够的空间来保存一个地址，引线的目的是通过对象 N 可以找到所有引用了该对象的对象，实现的方法是临时反转指针的方向。</p>
<p><img src="/images/gc/thread-before.jpg" alt="thread-before" title="thread-before"><br>引线之前，三个对象引用了对象N</p>
<p><img src="/images/gc/thread-after.jpg" alt="thread-after" title="thread-after"><br>引线之后，所有指向对象 N 的指针都被“引线”，因此可以通过对象 N 找到引用了对象 N 的对象。在对象 N 中，指向下一个对象的指针保存在其头部的某个值中，该头部以前的值被（临时地）移动到对象 A 中引用了对象 N 的指针域中。</p>
<p>引线整理算法需要两次堆遍历，第一次遍历实现堆中前向指针（从低地址指向高地址的指针）的引线，第二次遍历实现堆中后向指针（从高地址指向低地址的指针），其算法流程如下：</p>
<ol>
<li>第一次遍历，从对根进行引线，然后在堆中从头到尾进行扫描，同时计算转发地址 free，扫描到对象 N 时，根据前向指针，修改引用对象 N 的所有对象（其地址小于对象 N）的指针，将其设置为 free。同时对对象 N 的所有指针进行引线（包括前向指针和后向指针）。</li>
<li>第二次遍历，在堆中从头到尾进行扫描，计算转发地址，扫描到对象 N 时，根据后向指针，修改引用对象 N 的所有对象（其地址大于对象 N）的指针，将其设置为 free，最后将对象移动到 free。</li>
</ol>
<p>算法过程如下所示：<br><img src="/images/gc/threading-init.jpg" alt="threading-init" title="threading-init"><br>初始状态下，有一个根对象指向对象 N, 三个对象 A, B 及 C 指向 对象 N 。</p>
<p><img src="/images/gc/threading-first-1.jpg" alt="threading-first-1" title="threading-first-1"><br>第一次遍历，扫描到对象 A，实现了前向指针的引线。</p>
<p><img src="/images/gc/threading-first-2.jpg" alt="threading-first-2" title="threading-first-2"><br>第一次遍历，扫描到对象 N，根据前向指针的引线，更新根对象及对象 A 的指针域（对象 N 的新地址 free1）。</p>
<p><img src="/images/gc/threading-first-3.jpg" alt="threading-first-3" title="threading-first-3"><br>第一次遍历，扫描到对象 C，实现了后向指针的引线。</p>
<p><img src="/images/gc/threading-second.jpg" alt="threading-second" title="threading-second"><br>第二闪遍历，根据后向指针的引线，更新后向指针，且移动存活对象。</p>
<p>引线整理算法伪代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">compact():</span><br><span class="line">    updateForwardReferences()   /* 更新前向指针 */</span><br><span class="line">    updateBackwardReferences()  /* 更新后向指针 */</span><br><span class="line"></span><br><span class="line">/* 对引用进行引线 */</span><br><span class="line">thread(ref):</span><br><span class="line">    if *ref != null</span><br><span class="line">        *ref = **ref</span><br><span class="line">        **ref = ref</span><br><span class="line"></span><br><span class="line">/* 根据引线，更新转发地址 */</span><br><span class="line">update(ref, addr):</span><br><span class="line">    tmp = *ref</span><br><span class="line">    while isReference(tmp)</span><br><span class="line">        *tmp = addr</span><br><span class="line">        tmp = *tmp</span><br><span class="line">    *ref = tmp</span><br><span class="line"></span><br><span class="line">/* 更新前向指针 */</span><br><span class="line">updateForwardReferences():</span><br><span class="line">    for each fld in Roots</span><br><span class="line">        thread(*fld)</span><br><span class="line">    </span><br><span class="line">    free = HeapStart</span><br><span class="line">    scan = HeapStart</span><br><span class="line">    while scan &lt;= HeapEnd</span><br><span class="line">        if isMarked(scan)</span><br><span class="line">            update(scan, free)  /* 将所有指向 scan 的前向指针都修改为 free */</span><br><span class="line">            for each fld in Pointers(scan)</span><br><span class="line">                thread(fld)</span><br><span class="line">            free = free + size(scan)</span><br><span class="line">        scan = scan + size(scan)</span><br><span class="line"></span><br><span class="line">/* 更新后向指针且移动对象 */</span><br><span class="line">updateBackwardReferences():</span><br><span class="line">    free = HeapStart</span><br><span class="line">    scan = HeapStart</span><br><span class="line">    while scan &lt;= HeapEnd</span><br><span class="line">        if isMarked(scan)</span><br><span class="line">            update(scan, free)  /* 将所有指向 scan 的后向指针都修改为 free */</span><br><span class="line">            move(scan, free)</span><br><span class="line">            free = free + size(scan)</span><br><span class="line">        scan = scan + size(scan)</span><br></pre></td></tr></table></figure></p>
<h3 id="2-4-单次遍历算法"><a href="#2-4-单次遍历算法" class="headerlink" title="2.4 单次遍历算法"></a>2.4 单次遍历算法</h3><p>在上面三种整理算法中，都需要多次遍历堆，有没有只需要遍历一次堆即可完成内存整理？借助额外的数据结构存储对象的“转发地址”，单次遍历算法通过一次堆的遍历便可实现内存的整理，这是典型的“空间换时间”。<br>在单次遍历算法中，使用了两种数据结构：1）标记位向量（mark-bit vector），它的每一位反映了每个存活对象的起始和结束地址；2）偏移向量（offset vector），将堆划分成大小相等的小内存块（分别是 256 字节和 512 字节），偏移向量记录了每一个内存块中第一个存活对象的的转发地址，其他存活对象的转发地址可以通过偏移向量和标记位向量实时计算得出。对于任意给定对象，可以先计算出其所在内存块的索引号，然后再根据该内存块在偏移向量和标记位向量中对应数据计算出该对象的转发地址。回收器不再需要两次遍历来移动对象和更新指针，转而可以通过对标记位向量的一次遍历来构造偏移向量，然后再通过一次堆遍历同时完成对象的移动和指针的更新。</p>
<p>以下图为例，假定每个内存块包含 8 个槽，每一个槽代表一个字，任意一个对象在标记位向量中使用起始和结束地址进行标记，如old对象，在标记位向量中使用第 16 位和第 19 位来标记。<br><img src="/images/gc/compressor.jpg" alt="compressor" title="compressor"><br>在上图中，堆被分成 4 个内存块，分别是 block 0~3，block 0 中的第 2、3、6、7位被设置，block 1 中的第 3、5 位被设置，这表示已经有 7 个内存字在标记位向量中得到了标记，因此 block 2 中的第一个存活对象将被移动到堆中的第 7 个槽中，对应 offset [ 2(block) ] = 7, old 对象在 block 2 中的偏移 offsetInBlock(old) = 3, 那么 old 对象的转发地址就等于 offset[2] +  offsetInBlock(old) = 10。</p>
<p>单次遍历算法的流程如下：</p>
<ol>
<li>根据标记过程中得到的标记位向量，计算偏移向量；</li>
<li>从头到尾遍历堆，根据标记位向量和偏移向量，计算出对象的转发地址，进行对象的移动或指针的更新。</li>
</ol>
<p>单次遍历算法伪代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">compact():</span><br><span class="line">    computeLocations(HeapStart, HeapEnd, HeapStart)     /* 计算偏移向量 */</span><br><span class="line">    updateReferencesRelocate(HeapStart, HeapEnd)        /* 更新转发地址和移动对象 */</span><br><span class="line"></span><br><span class="line">/* 计算偏移向量 */</span><br><span class="line">computeLocations(start, end, toRegion)</span><br><span class="line">    loc = toRegion</span><br><span class="line">    block = getBlockNum(start)  /* 得到指针所在块的索引 */</span><br><span class="line">    for b = 0 to numBits(start, end) - 1    /* 遍历标记位向量 */</span><br><span class="line">        if b % BITS_IN_BLOCK == 0   /* 是否跨越了块边界 */</span><br><span class="line">            offset[block] = loc     /* 存放块中第一个对象的地址 loc */</span><br><span class="line">            block = block + 1</span><br><span class="line">        if bitmap[b] = MARKED</span><br><span class="line">            loc = loc + BYTES_PER_BIT   /* 根据存活对象的大小移动 */</span><br><span class="line"></span><br><span class="line">/* 计算转发地址 */</span><br><span class="line">newAddress(old):</span><br><span class="line">    block = getBlockNum(old)</span><br><span class="line">    return offset[lock] + offsetInBlock(old)    /* 转发地址的公式 */</span><br><span class="line"></span><br><span class="line">updateReferencesRelocate(start, end):</span><br><span class="line">    for each fld in Roots</span><br><span class="line">        ref = *fld</span><br><span class="line">        if ref != null</span><br><span class="line">            *fld = newAddress(ref)</span><br><span class="line">    scan = start</span><br><span class="line">    while scan &lt; end</span><br><span class="line">        scan = nextMarkedObect(scan)    /* 使用位图 */</span><br><span class="line">        for each fld in Pointers(scan)  /* 更新引用 */</span><br><span class="line">            ref = *fld</span><br><span class="line">            if ref != null</span><br><span class="line">                *fld = newAddress(ref)</span><br><span class="line">        dest = newAddress(scan)</span><br><span class="line">        move(scan, dest)</span><br></pre></td></tr></table></figure></p>
<h2 id="3-复制式回收算法"><a href="#3-复制式回收算法" class="headerlink" title="3. 复制式回收算法"></a>3. 复制式回收算法</h2><p>相对于标记 - 整理算法，复制式回收算法，可以有效提供内存分配的效率，同时回收过程只需要遍历堆一次，其缺点是堆的可用空间降低了一半。基本的复制式回收器将堆划分为两个大小相等的半区（semispace），分别是来源空间（fromspace）和目标空间（tospace），为了简化，我们假定堆是一块连续的内存空间。当堆空间足够时，在目标空间中分配新对象的方法是根据对象的大小简单地增加空闲空间，如果可用空间不足，则进行垃圾回收。回收器先两个半区角色进行切换，然后将存活对象从来源空间得到到目标空间。在回收完成之后，所有存活对象将紧密排布在目标空间的一端。在下一轮回收之前，回收器将简单地丢弃来源空间（为了安全起见，可以作清零处理）。</p>
<p>复制式回收算法的流程如下：</p>
<ol>
<li>初始化工作列表（栈结构），将复制完成但未扫描的对象（灰色对象）放入工作列表，列表为空表示结束；</li>
<li>从根集合开始，将根对象复制到目标空间，在原有对象中设置转发地址，即目标空间的新地址，并将根对象放入工作列表中，原对象中是否有转发地址是判断复制是否完成的依据；</li>
<li>从工作列表中取出灰色对象，扫描其指针域，将指针指向的对象复制到目标空间中，设置转发地址，并加入工作列表；</li>
<li>重复第 3 步操作，直到工作列表为空。</li>
</ol>
<p>Cheney 扫描（Cheney scanning）算法是一种十分优雅的算法，该算法复用目标空间中的灰色对象实现栈的结构，它仅需要一个指针 scan 为指向下一个待扫描对象，除此之外不再需要任何额外空间。结束的标志是指针 scan 和指针 free 重合。</p>
<p>下面是一个 Cheney 扫描对象 L 的实例，该对象是链表结构的头结点，它包含指向表头和表尾的指针。<br><img src="/images/gc/cheney-scanning-init.jpg" alt="cheney-scanning-init" title="cheney-scanning-init"><br>初始状态，所有对象都在来源空间。</p>
<p><img src="/images/gc/cheney-scanning-1.jpg" alt="cheney-scanning-1" title="cheney-scanning-1"><br>复制根对象，使用原对象的头部存放转发地址。</p>
<p><img src="/images/gc/cheney-scanning-2.jpg" alt="cheney-scanning-2" title="cheney-scanning-2"><br>扫描根对象副本 L’ 的指针域，复制 A、E 对象到目标空间，扫描结束，根对象副本 L’ 出栈，继续对 A 对副本 A’ 象进行扫描。</p>
<p><img src="/images/gc/cheney-scanning-3.jpg" alt="cheney-scanning-3" title="cheney-scanning-3"><br>扫描对象 C 副本 C’</p>
<p><img src="/images/gc/cheney-scanning-4.jpg" alt="cheney-scanning-4" title="cheney-scanning-4"><br>扫描对象 D 副本 D’，此时 scan = free，说明回收结束。</p>
<p>复制式回收算法伪代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">/* 创建半区 */</span><br><span class="line">createSemispaces():</span><br><span class="line">    tospace = HeapStart</span><br><span class="line">    extent = ( HeapEnd - HeapStart ) / 2</span><br><span class="line">    top = fromspace = HeapStart + extent</span><br><span class="line">    free = tospace</span><br><span class="line"></span><br><span class="line">/* 分配内存 */</span><br><span class="line">allocate(size):</span><br><span class="line">    result = free</span><br><span class="line">    newfree = result + size</span><br><span class="line">    if newfree &gt; top</span><br><span class="line">        return null     /* 内存耗尽 */</span><br><span class="line"></span><br><span class="line">    free = newfree</span><br><span class="line">    return result</span><br><span class="line"></span><br><span class="line">/* 内存整理 */</span><br><span class="line">collect():</span><br><span class="line">    flip()  /* 切换来源空间和目标空间 */</span><br><span class="line">    initialise(worklist)    /* 将工作列表初始化为空 */</span><br><span class="line">    </span><br><span class="line">    for each fld in Roots   /* 复制根 */</span><br><span class="line">        process(fld)</span><br><span class="line">    </span><br><span class="line">    while not isEmpty(worklist)</span><br><span class="line">        ref = remove(worklist)</span><br><span class="line">        scan(ref)</span><br><span class="line"></span><br><span class="line">/* 翻转半区 */</span><br><span class="line">flip():</span><br><span class="line">    tmp = fromsapce</span><br><span class="line">    fromspace = tospace</span><br><span class="line">    tospace - tmp</span><br><span class="line"></span><br><span class="line">    top = tospace + extent</span><br><span class="line">    free = tospace</span><br><span class="line"></span><br><span class="line">scan(ref):</span><br><span class="line">    for each fld in Pointers(ref)</span><br><span class="line">        process(fld)</span><br><span class="line"></span><br><span class="line">/* 使用目标空间中新副本的地址来更新域 */</span><br><span class="line">process(fld):</span><br><span class="line">    fromRef = *fld</span><br><span class="line">    if fromRef != null</span><br><span class="line">        *fld = forward(fromRef)     /* 使用目标空间中新副本的地址来更新 */</span><br><span class="line">    </span><br><span class="line">forward(fromRef):</span><br><span class="line">    toRef = forwardingAddress(fromRef)</span><br><span class="line">    if toRef = null     /* 尚未得到复制（尚未标记） */</span><br><span class="line">        toRef = copy(fromRef)</span><br><span class="line">    </span><br><span class="line">    return toRef</span><br><span class="line"></span><br><span class="line">/* 复制对象，返回转发地址 */</span><br><span class="line">copy(fromRef):</span><br><span class="line">    toRef = free</span><br><span class="line">    free = free + size(fromRef)</span><br><span class="line">    move(fromRef, toRef)</span><br><span class="line">    forwardingAddress(fromRef) = toRef  /* 标记 */</span><br><span class="line">    add(worklist, toRef)</span><br><span class="line">    return toRef</span><br><span class="line"></span><br><span class="line">/* 使用 Cheney 工作列表进行复制 */</span><br><span class="line">initialise(worklist):</span><br><span class="line">    scan = free</span><br><span class="line"></span><br><span class="line">isEmpty(worklist):</span><br><span class="line">    return scan = free</span><br><span class="line"></span><br><span class="line">remove(worklist):</span><br><span class="line">    ref = scan</span><br><span class="line">    scan = scan + size(scan)</span><br><span class="line">    return ref</span><br><span class="line"></span><br><span class="line">add(worklist, ref):</span><br><span class="line">    /* 空 */</span><br></pre></td></tr></table></figure></p>
<h2 id="4-引用计数算法"><a href="#4-引用计数算法" class="headerlink" title="4. 引用计数算法"></a>4. 引用计数算法</h2><p>上面讲到的三种垃圾回收算法都是间接式的，它们需要从已知的根集合出发对存活对象进行遍历，进而才能确定所有的存活对象。而在引用计数算法中，对象的存活性可以通过引用关系的创建或删除直接判定，无须像上面的三种追踪式回收器那样先通过堆遍历找出所有的存活对象，然后再反向确定出未遍历到的垃圾对象。<br>引用计数算法判断一个对象是否回收的依据是：当且仅当指向某个对象的引用数量大于零时，该对象才有可能是存活的。在引用计数算法中，每个对象都需要与一个引用计数相关联，这一计数通常保存在对象头部的某个槽中。下面是一个简单的引用计数算法，Write方法用于增加新目标对象的引用计数，同时减少旧目标对象的引用计数。对象执行读写操作时，需要维护其关联的引用计数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">New():</span><br><span class="line">    ref = allocate()</span><br><span class="line">    if ref = null</span><br><span class="line">        error &quot;Out of memory&quot;</span><br><span class="line">    rc(ref) = 0     /* 初始化计数 */</span><br><span class="line">    return ref</span><br><span class="line"></span><br><span class="line">Write(src, i, ref):</span><br><span class="line">    addReference(ref)</span><br><span class="line">    deleteReference(src[i])</span><br><span class="line">    src[i] = ref</span><br><span class="line"></span><br><span class="line">addReference(ref):</span><br><span class="line">    if ref != null</span><br><span class="line">        rc(ref) = rc(ref) + 1</span><br><span class="line"></span><br><span class="line">deleteReference(ref):</span><br><span class="line">    if ref != null</span><br><span class="line">        rc(ref) = rc(ref) - 1</span><br><span class="line">    if rc(ref) = 0</span><br><span class="line">        for each fld in Pointers(ref)</span><br><span class="line">            deleteReference(*fld)</span><br><span class="line">        free(ref)</span><br></pre></td></tr></table></figure></p>
<p>引用计数算法将内存管理开销分摊在程序运行过程中，无须停顿程序便可对内存进行整理，也不用为回收器预留一定空间。另外一方面也不需要运行时系统的支持，以库的形式就可以支持内存的回收，如 C++ 的智能指针就是使用引用计数来实现内存的自动管理。除了这些优点，引用计数算法同样存在一些缺陷：1）引用计数给赋值操作带来了额外的时间开销，因为需要维护引用计数；2）引入多线程竞争的问题，引用计数的增减操作以及加载和存储指针的操作必须是原子化的；3）读操作会引发计数器的更新操作，会“污染”高速缓存；4）引用计数无法回收环状引用数据结构；5）引用计数会占用额外的存储空间。</p>
<p>注：环状垃圾回收的问题，一般需要引入停顿程序的方式来解决。</p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>本篇文章分析了四种基本的垃圾回收算法，它们分别有不同的使用场景：</p>
<ol>
<li>标记 - 清扫： 算法简单，适合于分配固定大小对象的场景；</li>
<li>标记 - 整理： 需要遍历堆多次或引入额外的数据结构来记录转发地址，算法较复杂，优势是可以解决内存碎片的问题，内存利用率较高；</li>
<li>复制式回收算法 ： 内存分配速度及效率较高，缺点是堆的可用空间降低了一半；</li>
<li>引用计数：内存管理的开销分摊到程序运行期间，不需要运行时系统的支持，但需要解决环状引用的问题。</li>
</ol>
<p><strong>参考：</strong></p>
<hr>
<p><a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection" target="_blank" rel="noopener">1. Tracing garbage collection</a><br><a href="https://book.douban.com/subject/26740958/" target="_blank" rel="noopener">2. 垃圾回收算法手册——自动内存管理的艺术</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/12/mind-mapping-insurance-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/07/12/mind-mapping-insurance-1/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">思维导图-保险知识-1</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-07-12 10:10:10" itemprop="dateCreated datePublished" datetime="2020-07-12T10:10:10+08:00">2020-07-12</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-07-31 17:17:10" itemprop="dateModified" datetime="2021-07-31T17:17:10+08:00">2021-07-31</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/思维导图/" itemprop="url" rel="index"><span itemprop="name">思维导图</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>之前给小孩和自己买保险走了一些弯路，特意研究了保险的品种及保障的作用，用思维导图做了一个总结，权当是笔记吧。</p>
<p><img src="/images/insurance.jpeg" alt="insurance" title="insurance"></p>
<p><strong>参考：</strong></p>
<hr>
<p><a href="https://book.douban.com/subject/30302000/" target="_blank" rel="noopener">1. 你的第一本保险指南</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/14/java-memory-model/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/06/14/java-memory-model/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">Java 内存模型</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-06-14 20:36:17" itemprop="dateCreated datePublished" datetime="2020-06-14T20:36:17+08:00">2020-06-14</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-07-31 17:17:10" itemprop="dateModified" datetime="2021-07-31T17:17:10+08:00">2021-07-31</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java基础/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>处于优化的目的，在不同的编译器及不同体系架构的cpu 中，会将指令重排，即程序中排在后面的指令有可能比排在前面的指令先执行。同时由于cpu 中存在读写缓冲区，会将指令相关的运行时数据暂存在这些缓冲区中，也会导致指令重排的问题。目前的cpu 都是多核的体系架构，同一个语言编写的程序在不同硬件体系中，在多线程执行环境下，多次执行的结果可能不一致。在Java 中，怎么解决这个问题？为了屏蔽不同硬件架构的差异，给程序员提供一致的运行结果，Java 提出了 JMM(内存模型)的概念。</p>
<p>Java 内存模型（JMM）描述了在Java 语言中线程如何与主内存（Main Memory）进行交互，定义了一套线程对共享变量的访问规则，同时决定一个线程对共享变量的写入何时对另外一个线程可见。</p>
<p>在Java 中，共享变量主要包括实例字段、静态字段和数组元素，这些变量存储在堆内存中，由所有线程共享。而局部变量、方法参数和异常处理参数不会在线程间共享，不存在可见性（一个线程对变量的写入对另外的线程可见）的问题，不受内存模型的的影响。</p>
<p>从抽象的角度来看，JMM 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local memory），本地内存中存储了该线程读/写共享变量的副本。本地内存是JMM 的一个抽象概念，并不真实存在，它涵盖了缓存、写缓存区、寄存器以及其它硬件。JMM 抽象示意图如下所示：<br><img src="/images/JMM.jpg" alt="JMM" title="JMM"></p>
<p>从上图来看，线程A与线程B要进行通过的话，必须要经历两个步骤：</p>
<ol>
<li>首先，线程A将在本地内存中修改的共享变量刷新到主内存中；</li>
<li>最后，线程B重新从主内存加载修改后的共享变量，从而看到被修改后的内容。</li>
</ol>
<p>本质上来说，JMM 通过控制主内存与每个线程的本地内存之间的交互，来提供内存可见性的保证。</p>
<h2 id="2-重排序"><a href="#2-重排序" class="headerlink" title="2. 重排序"></a>2. 重排序</h2><p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：</p>
<ol>
<li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li>
<li>指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>
<li>内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。<br>从java源代码到最终实际执行的指令序列，会分别经历下面三种重排序：<br><img src="/images/java-instruction-reorder.png" alt="java-instruction-reorder" title="java-instruction-reorder"></li>
</ol>
<p>上述的1属于编译器重排序，2和3属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM的处理器重排序规则会要求java编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel称之为memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。<br>JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</p>
<h2 id="3-内存系统重排序"><a href="#3-内存系统重排序" class="headerlink" title="3. 内存系统重排序"></a>3. 内存系统重排序</h2><p>现代处理器与内存存在较大的性能差异，以主频为3GHZ的cpu为例，cpu访问一次内存时间在10~100ns内，但cpu  在100ns内可以执行1200条指令（假定一个时钟周期可以同时执行4条指令，一个时间周期为0.3ns）。因此，现代处理器在内存之间引入了多级的缓存结构，同时为了提高指令的执行效率，在cpu 寄存器与缓存之间引入了读/写缓冲区。写缓冲区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟。同时，通过以批处理的方式刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写，可以减少对内存总线的占用。读缓冲区可以缓存当前指令读取的数据，实现cpu异步读取数据，提高cpu的吞吐率。以Intel x86 CPU （2012 Sandy Bridge）为例，如下图所示：<br><img src="/images/memory-heirarchy.png" alt="memory-heirarchy" title="memory-heirarchy"><br>其内部组成包括：</p>
<ol>
<li>寄存器：在每个cpu 核心上，有160个用于整数和144个用于浮点的寄存器单元。访问这些寄存器只需要一个时钟周期，这构成了对执行核心来说最快的内存。编译器会将本地变量和函数参数分配到这些寄存器上。当使用超线程技术（ hyperthreading ）时，这些寄存器可以在超线程协同下共享。</li>
<li>读写缓冲区：读写缓存区包含64个load 缓冲条目和36个的store 缓冲条目。这些缓冲区用于记录等待缓存子系统时正在执行的操作。store 缓冲区保存将要写到L1 缓存的数据。load 缓冲区保存正要被寄存器读取的数据。由于读/写缓存仅对当前cpu 核心可见，这会造成指令的重排序，需要通过内存屏障来保证其执行顺序。</li>
<li>L1 &amp; L2 缓存：L1和L2 是一个本地核心内的缓存，它们在大小和速度上存在差异。</li>
<li>L3 缓存： 同插槽的所有cpu 核心共享L3缓存。L3缓存被分为多个2MB的段，所有段组成一环形网络。每一个核心都连接到这个环形网络上，地址通过hash的方式映射到段上以达到更大的吞吐量。</li>
<li>主内存：在缓存没命中的情况下，内存的平均延迟为65ns。</li>
<li>NUMA：在一个多插槽的服务器上，会使用非一致性内存访问机制（ non-uniform memory access ）。之所以要使用该方式主要是因为需要的数据在另外一个远程插槽上，需要跨越QPI 总线且额外花费40ns。 </li>
</ol>
<p>在上文讲到的多级缓存系统中，L1,L2,L3级缓存与主内存之间一致性一般是通过Cache Conherence技术来实现的，Intel 使用MESIF协议，AMD 使用 MOESI，在这里不再描述，我们假定：一旦内存数据被推送到L1 缓存，就会有消息协议来确保所有的缓存会对所有的共享数据同步并保持一致。</p>
<p>现在我们来分析引入读写缓冲区带来的问题，先看下两者的作用：</p>
<blockquote>
<p>When a store is issued to the out-of-order core for renaming and scheduling, an entry in the store buffer is allocated (in-order) for the address and the data. The store buffer will hold the address and data until the instruction has retired and the data has been written to the L1 cache.</p>
</blockquote>
<blockquote>
<p>Analogously, when a load is issued, an entry in the load buffer is reserved for the address. However, loads must also compare the load address against the contents of the entire store buffer to check for aliasing with older stores. If the load address matches an older store, then the load must wait for the older store to complete to preserve the dependency. Most x86 processors optimize this further, by allowing the store to forward data to the load without accessing the cache. The load buffer entry can be released, once the instruction has retired and the load data is written into the register file.</p>
</blockquote>
<blockquote>
<p>Because of the strong x86 ordering model, the load buffer is snooped by coherency traffic. A remote store must invalidate all other copies of a cache line. If a cache line is read by a load, and then invalidated by a remote store, the load must be cancelled, since it potentially read invalid data. The x86 memory model does not require snooping the store buffer.</p>
</blockquote>
<p>其要点包括：1）写缓冲区缓存指令的地址及数据信息，直到指令执行完毕且数据写入到L1 缓存中，写入到L1 缓存中之后，会通过MESIF协议通知其它cpu 核心失效相关的缓存行；2）读缓冲区按照地址缓存数据，直到指令执行完毕且数据被读到寄存器中；2）读缓冲区缓存了来自L1 缓存的数据，所以受MESIF协议的侦测，如果数据被其它远程的写缓冲区修改，根据MESIF协议，它会失效所有的数据拷贝，包括读缓冲区中的数据。</p>
<p>由于读写缓冲区只对当前cpu 核心有效，会造成指令重排的问题，要解决这个问题，需要引入“内存屏障”的技术。内存屏障提供了两个功能。首先，它们通过确保从另一个cpu 来看屏障的两边的所有指令都是正确的程序顺序，而保持程序顺序的外部可见性；其次它们可以实现内存数据可见性，确保内存数据会同步到cpu L1。</p>
<p><strong>Store Barrier</strong><br>Store 屏障，是x86的”sfence“ 指令，强制所有在store 屏障指令之前的store 指令，都在该store 屏障指令执行之前被执行，并把store 缓冲区的数据都刷到L1 ，这会使得程序状态对其它cpu 可见。</p>
<p><strong>Load Barrier</strong><br>Load 屏障，是x86 上的”ifence“ 指令，强制所有在load 屏障指令之后的load 指令，都在该load 屏障指令执行之后被执行，并且一直等到load 缓冲区被该cpu 读完才能执行之后的load 指令。这使得从其它cpu 暴露出来的程序状态对该cpu 可见，这之后cpu 可以进行后续处理。</p>
<p><strong>Full Barrier</strong><br>Full 屏障，是x86 上的”mfence“ 指令，复合了load 和save 屏障的功能。</p>
<h2 id="4-编译器重排序"><a href="#4-编译器重排序" class="headerlink" title="4. 编译器重排序"></a>4. 编译器重排序</h2><p><strong>数据依赖性</strong><br>如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。数据依赖分下列三种类型：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>代码示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>写后读</td>
<td>a = 1;b = a;</td>
<td>写一个变量之后，再读这个位置</td>
</tr>
<tr>
<td>写后写</td>
<td>a = 1;a = 2;</td>
<td>写一个变量之后，再写这个变量</td>
</tr>
<tr>
<td>读后写</td>
<td>a = b;b = 1;</td>
<td>读一个变量之后，再写这个变量</td>
</tr>
</tbody>
</table>
<p>上面三种情况，只要重排序两个操作的执行顺序，程序的执行结果将会被改变。</p>
<p>前面提到过，编译器和处理器可能会对操作做重排序。编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序</p>
<p><strong>as-if-serial 语义</strong><br>as-if-serial 语义的意思指：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守 as-if-serial 语义。</p>
<p>为了遵守 as-if-serial 语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作可能被编译器和处理器重排序。</p>
<h2 id="5-JMM内存屏障"><a href="#5-JMM内存屏障" class="headerlink" title="5. JMM内存屏障"></a>5. JMM内存屏障</h2><p>为了保证内存可见性，Java 编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。JMM把内存屏障指令分为下列四类：</p>
<table>
<thead>
<tr>
<th>屏障类型</th>
<th>指令示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>LoadLoad Barriers</td>
<td>Load1; LoadLoad; Load2</td>
<td>确保Load1数据的装载，之前于Load2及所有后续装载指令的装载。</td>
</tr>
<tr>
<td>StoreStore Barriers</td>
<td>Store1; StoreStore; Store2</td>
<td>确保Store1数据对其他处理器可见（刷新到内存），<br>之前于Store2及所有后续存储指令的存储。</td>
</tr>
<tr>
<td>LoadStore Barriers</td>
<td>Load1; LoadStore; Store2</td>
<td>确保Load1数据装载，之前于Store2及所有后续<br>的存储指令刷新到内存。</td>
</tr>
<tr>
<td>StoreLoad Barriers</td>
<td>Store1; StoreLoad; Load2</td>
<td>确保Store1数据对其他处理器变得可见（指刷新到内存），<br>之前于Load2及所有后续装载指令的装载。StoreLoad Barriers <br>会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，<br>才执行该屏障之后的内存访问指令。</td>
</tr>
</tbody>
</table>
<p>StoreLoad Barriers是一个“全能型”的屏障，它同时具有其他三个屏障的效果。现代的多处理器大都支持该屏障（其他类型的屏障不一定被所有处理器支持）。执行该屏障开销会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中（buffer fully flush）。</p>
<p><strong>JMM 内存屏障与cpu 内存屏障的映射</strong><br>在不同cpu 架构中，实现的内存屏障是不同的，如上面的X86体系中，只允许StoreLoad指令重排，所以只用实现StoreLoad Barriers，而其它cpu 体系则有所不同，其对应关系如下图所示：<br><img src="/images/cpu-barriers-map-jmm.png" alt="cpu-barriers-map-jmm" title="cpu-barriers-map-jmm"></p>
<p>由于常见的cpu 内存屏障比 JMM 要弱，java 编译器在生成字节码时，会在执行指令序列的适当位置插入内存屏障来限制处理器的重排序。同时，由于各种处理器内存屏障的强弱并不相同，为了在不同的处理器平台向程序员展示一个一致的内存模型，JMM 在不同的处理器中需要插入的内存屏障的数量和种类也不相同。</p>
<h2 id="6-happen-before"><a href="#6-happen-before" class="headerlink" title="6. happen-before"></a>6. happen-before</h2><p>JMM 使用happens-before 的概念来阐述操作之间的内存可见性，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before 关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。<br>与程序员密切相关的happens-before 规则如下：</p>
<ol>
<li>程序顺序规则：一个线程中的每个操作，happens-before 于该线程中的任意后续操作。</li>
<li>监视器锁规则：对一个监视器锁的解锁，happens-before 于随后对这个监视器锁的加锁。</li>
<li>volatile变量规则：对一个volatile域的写，happens-before 于任意后续对这个volatile域的读。</li>
<li>传递性：如果A happens- before B，且B happens- before C，那么A happens- before C。</li>
</ol>
<p>注意，两个操作之间具有happens-before关系，并不意味着前一个操作必须要在后一个操作之前执行！happens-before 仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前（the first is visible to and ordered before the second）。<br>happens-before与JMM的关系如下图所示：<br><img src="/images/happens-before.png" alt="happens-before" title="happens-before"></p>
<h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><p>通过JMM 模型的定义，使得Java语言真正实现了跨平台，在不同平台，多线程的执行总能得到一致的结果，同时定义happens-before 规则，简化了对JMM 理解难度。</p>
<p><strong>参考：</strong></p>
<hr>
<p><a href="https://www.infoq.cn/article/java-memory-model-1/" target="_blank" rel="noopener">1. 深入理解 Java 内存模型（一）——基础</a><br><a href="https://www.infoq.cn/article/java-memory-model-2/" target="_blank" rel="noopener">2. 深入理解 Java 内存模型（二）——重排序</a><br><a href="https://download.oracle.com/otn-pub/jcp/memory_model-1.0-pfd-spec-oth-JSpec/memory_model-1_0-pfd-spec.pdf?AuthParam=1593252270_c3d47e052ce05eb43eb35a8c96217567" target="_blank" rel="noopener">3. SR-133: JavaTM Memory Model and Thread Specification</a><br><a href="https://www.realworldtech.com/haswell-tm-alt/2/" target="_blank" rel="noopener">4. Haswell Transactional Memory Alternatives</a><br><a href="http://ifeve.com/cpu-cache-flushing-fallacy/" target="_blank" rel="noopener">5. CPU Cache Flushing Fallacy</a><br><a href="http://ifeve.com/memory-barriersfences/" target="_blank" rel="noopener">6. Memory Barriers/Fences</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/24/database-transaction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/05/24/database-transaction/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">数据库事务</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-05-24 12:55:17" itemprop="dateCreated datePublished" datetime="2020-05-24T12:55:17+08:00">2020-05-24</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-07-31 17:17:10" itemprop="dateModified" datetime="2021-07-31T17:17:10+08:00">2021-07-31</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据库/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在数据库技术中，事务将应用程序的多个读、写操作捆绑在一起成为一个逻辑操作单元。即事务中的所有读写是一个执行的整体，整个事务要么成功（提交）、要么失败（中止或回滚）。如果失败，应用程序可以安全地重试。这样，由于不需要担心部分失败的情况（无论出于何种原因），应用层的错误处理就变得简单得多。</p>
<h2 id="1-ACID的含义"><a href="#1-ACID的含义" class="headerlink" title="1. ACID的含义"></a>1. ACID的含义</h2><p>事务提供了四个方面的安全保证，即ACID，分别代表原子性（Atomicity），一致性（Consistency），隔离性（Isolation）与持久性（Durability）。</p>
<h3 id="1-1-原子性"><a href="#1-1-原子性" class="headerlink" title="1.1 原子性"></a>1.1 原子性</h3><p>ACID原子性描述了客户端发起一个包含多个写操作的请求时可能发生的情况，例如在完成了一部分写入后，系统发生了故障，包括进程崩溃，网络中断，磁盘变满或者违反了某种完整性约束等；把多个写操作纳入到一个原子事务，万一出现了上述故障而导致没法完成最终提交时，则事务会中止，并且数据库丢弃或撤销那些局部完成的操作。<br>ACID原子性所定义的特征是：在出错时中止事务，并将部分完成的写入全部丢弃。它强调一个可中止性的概念。</p>
<h3 id="1-2-一致性"><a href="#1-2-一致性" class="headerlink" title="1.2 一致性"></a>1.2 一致性</h3><p>ACID中的一致性主要是指对数据有特定的预期状态，任何数据更改必须满足这些状态约束（或者恒等条件）。例如，对于一个账单系统，账户的贷款余额应和借款余额保持平衡。如果某事务从一个有效的状态开始，并且事务中任何更新操作都没有违背约束，那么最后的结果依然符合有效状态。<br>这种一致性本质上要求应用层来维护状态一致（或者恒等），应用程序有责任正确地定义事务来保持一致性。这不是数据库可以保证的事情：即如果提供的数据违背了恒等条件，数据库很难检测进而阻止该操作（数据库可以完成针对某些特定类型的恒等约束检查，例如使用外键约束或唯一性约束。但通常主要靠应用程序定义数据的有效/无效状态，数据库主要用于存储）。<br>原子性，隔离性和持久性是数据库自身的属性，而ACID中的一致性更多是应用层的属性。应用程序可能借助数据库提供的原子性和隔离性，以达到一致性，但一致性本身并不源于数据库。因此，也有一种说法，字母C其实并不应该属于ACID。</p>
<h3 id="1-3-隔离性"><a href="#1-3-隔离性" class="headerlink" title="1.3 隔离性"></a>1.3 隔离性</h3><p>ACID语义中的隔离性意味着并发执行的多个事务相互隔离，它们不能互相交叉，主要是指多个事务中对相同记录读写操作进行隔离。</p>
<h3 id="1-4-持久性"><a href="#1-4-持久性" class="headerlink" title="1.4 持久性"></a>1.4 持久性</h3><p>数据库系统本质上是提供一个安全可靠的地方来存储数据而不用担心数据丢失等。持久性它保证一旦事务提交成功，即使存在硬件故障或数据库崩溃，事务所写入的任何数据也不会消失。</p>
<p>在ACID中，原子性，隔离性和持久性是数据库自身的属性，其中原子性和持久性，我们能修改的地方不多，所以后面的内容主要关注隔离性相关的内容。</p>
<h2 id="2-隔离性"><a href="#2-隔离性" class="headerlink" title="2. 隔离性"></a>2. 隔离性</h2><p>隔离性主要是解决多个事务对相同数据或关联数据同时进行读写引发的问题，这些问题包括脏读、脏写、不可重复读及幻读。</p>
<h3 id="2-1-脏读"><a href="#2-1-脏读" class="headerlink" title="2.1 脏读"></a>2.1 脏读</h3><p><strong>定义：一个事务读取了另外一个事务未提交的数据，主要是并发读的问题。</strong></p>
<p>假定某个事务已经完成部分数据写入，但事务尚未提交（或中止），此时另一个事务可以看到尚未提交的数据，如图所示：<br><img src="/images/dirty-read.jpg" alt="dirty-read" title="dirty-read"><br>事务1设置了x=3，在事务1未提交之前，事务2的get x操作返回了3。没有脏读时，事务2只有在事务1的事务提交之后才能看到x的新值。</p>
<p>当有以下需求时，需要防止脏读：</p>
<ul>
<li>如果事务需要更新多个对象，脏读意味着另一个事务可能会看到部分更新，而非全部。</li>
<li>如果事务发生中止，则所有写入操作都需要回滚。如果发生了脏读，这意味着它可能会看到一些稍后被回滚的数据，而这些数据并未实际提交到数据库中。之后所引发的后果可能会变得难以预测。</li>
</ul>
<h3 id="2-2-脏写"><a href="#2-2-脏写" class="headerlink" title="2.2 脏写"></a>2.2 脏写</h3><p><strong>定义：一个事务覆盖了另外一个事务未提交的数据更新，主要是对同一份数据进行并发更新的问题。</strong></p>
<p>如果两个事务同时尝试更新相同的对象，会发生什么情况?我们不清楚写入的顺序，但可以想象后写的操作会覆盖较早的写入。如果先前的写入是尚未提交事务的一部分，是否还会被覆盖？如果是，那就是脏写。<br>如果事务需要更新多个对象，脏写会带来非预期的错误结果，例如Alice和Bob两个人试图购买同一辆车，而购买洗车需要两次数据的写入：商品买主需要更新，同时发票也要更新。如下图所示，车主被改为Bob（他成功更新了商品数据），而Alice成功更新了发票信息，导致了业务数据的不一致。<br><img src="/images/dirty-write.jpg" alt="dirty-write" title="dirty-write"></p>
<h3 id="2-3-隔离级别-读提交"><a href="#2-3-隔离级别-读提交" class="headerlink" title="2.3 隔离级别-读提交"></a>2.3 隔离级别-读提交</h3><p>读-提交是数据库中比较流行的事务隔离级别，它提供以下两个保证：</p>
<ul>
<li>读数据库时，只能看到已成功提交的数据，防止脏读；</li>
<li>写数据库时，只会覆盖已成功提交的数据，防止脏写。</li>
</ul>
<p>数据库通常使用行级锁来防止脏写：当事务想修改某个对象（例如行或文档）时，它必须首先获得该对象的锁；然后一直持有锁直到事务提交（或中止）。给定时刻，只有一个事务可以拿到特定对象的锁，如果有另一个事务尝试更新同一个对象，则必须等待，直到前面的事务完成了提交（或中止）后，才能获得锁并继续。<br>数据库了为防止脏读，一般使用读锁，或者对于每一个待更新的对象，数据库都会维护数据的两个版本：1）旧值的版本；2）当前事务最新的版本。在事务提交之前，所有其它读操作都读取旧值；仅当写事务提交之后，才会切换到读取最新的值。</p>
<h3 id="2-4-不可重复读"><a href="#2-4-不可重复读" class="headerlink" title="2.4 不可重复读"></a>2.4 不可重复读</h3><p><strong>定义：在同一个事务中，同一个查询操作重复多次执行，返回结果不一样，主要是并发读的问题。</strong></p>
<p>不可重复读出现在一个事务中，在同一个查询操作执行多次操作的期间，另外一个事务对相同数据对象进行更新操作并成功提交事务，导致提交前后的数据不同。如下图所示，在读提交隔离级别下不能解决不可重复读的问题。<br><img src="/images/non-repeatable-read.jpg" alt="non-repeatable-read" title="non-repeatable-read"></p>
<p>假设Alice在银行有1000美元的存款，分为两个账户，每个500美元。现在有这样一笔转账交易从账户1转账户2。如果在她提交转账请求之后而数据库系统执行转账的过程中间，来查看两个账户的余额，她有可能会看到账户1在收到转账之前的余额（500美元），和账户2在完成转账之后的敌众余额（400美元）。对于Alice来说，貌似她的账户总共有900美元，而不是1000美元。</p>
<p>在上面的场景中，主要是一个事务跨越了另外一个事务，读取到了另外一个事务前后更新的数据，导致了数据的不一致性。为了解决这个问题，数据库引入了多版本并发控制（Multivesion Concurrency Control,MVCC），这种技术保留了数据对象多个不同的提交版本。</p>
<p>提供MVCC技术的隔离级别称为快照隔离级别，在MYSQL中也叫可重复读隔离级别，我们在这里统一叫快照隔离级别。在快照隔离级别中，脏写也是通过行锁来实现的，而脏读的实现也比较简单，直接基于MVCC来实现。</p>
<p>以PostgreSQL（或Mysql）中的MVCC实现为例。当事务开始时，首先赋予一个唯一的、单调递增的事务ID(txid)。每当事务向数据库写入新内部时，所写的数据都会被标记写入者的事务ID，如下图所示：<br><img src="/images/mvcc.jpg" alt="mvcc" title="mvcc"><br>表中的每一行都有一个created_by字段，其中包含了创建该行的事务ID。每一行还有一个deleted_ty字段，初始为空。如果事务要删除某行，该行实际上并未从数据库中删除，而只是将deleted_ty字段设置为请求删除的事务ID（仅仅标记为删除）。事后，当确定没有其它事务引用该标记删除的行时，数据库的垃圾回收进程才去真正删除并释放存储空间。</p>
<p>一次更新操作在内部会转换为一个删除操作加一个创建操作。例如，事务13从账户2中扣除100元，余额从500美元减为400美元，在account表里会出现现两行：一个余额为500但标记为删除的行（由事务13删除），另一个余额为400，由事务13创建。</p>
<p>当事务读数据库时，通过事务ID可以决定哪些对象可见，哪些不可见。通常情况下，仅当以下两个条件都成立，则该数据对象对事务可见：</p>
<ul>
<li>事务开始的时刻，创建该对象的事务已经完成了提交；</li>
<li>对象没有被标记为删除；或者即使标记了，但删除事务在当前事务开始时还没有完成提交。</li>
</ul>
<p>如事务12只能看到12之前提交的数据，事务13的更改对于事务12来说是不可见的。</p>
<h3 id="2-5-当前读"><a href="#2-5-当前读" class="headerlink" title="2.5 当前读"></a>2.5 当前读</h3><p>在快照隔离级别下，以下的场景会产生问题：</p>
<ol>
<li>首先输入一些匹配条件，即采用SELECT查询所有满足条件的行（例如，至少有两名医生正在值班，同一时刻房间没有预订）。</li>
<li>根据查询的结果，应用层代码来决定下一步的操作（有可能继续，或者报告错误并中止）。</li>
<li>如果应用程序决定继续执行，它将发起数据库写入（INSERT,UPDATE或DELETE）并提交事务。</li>
</ol>
<p>假定在一个医生管理系统中，医院会安排多个医生值班，医生也可以申请调整班次，但前提是确保至少一个医生还在该班次中值班。现在的情况是，Alice和Bob是两位值班医生，两个人碰巧都感到身体不适，因而都决定请假。如果他们几乎同一个时刻执行了调班的操作，如下图所示：<br><img src="/images/write-tilt.jpg" alt="write-tilt" title="write-tilt"></p>
<p>在数据库使用快照级别隔离，两个检查都返回有两名医生，所以两个事务都安全地进入下一下阶段。接下来，两个事务执行更新操作，调班成功。两个事务都成功提交，最后的结果却是没有任何医生在值班，显然违背了至少一个医生值班的业务需求。</p>
<p>为了解决这个问题，一种可选的方案是对查询的数据行显示加锁，加上for update，如下所示：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> doctors  <span class="keyword">where</span> on_call=<span class="literal">true</span> <span class="keyword">and</span> shift_id=<span class="number">1234</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> doctors  <span class="keyword">set</span> on_call=<span class="literal">false</span>  <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'Alice'</span>  <span class="keyword">and</span> shift_id=<span class="number">1234</span>;</span><br></pre></td></tr></table></figure></p>
<p>在上面的查询语句中，加入了for update，表示对数据行进行加锁，采用的是“当前读”的模式（Mysql数据库），即当前读会读取当前最新提交的数据，即使当前事务落后于最新事务，也能看到最新事务提交后的数据。</p>
<h3 id="2-6-幻读"><a href="#2-6-幻读" class="headerlink" title="2.6 幻读"></a>2.6 幻读</h3><p><strong>定义：在一个事务中的写入（插入）操作改变了另外一个事务查询的结果。</strong></p>
<p>在Mysql中，在快照读（可重复读）隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。幻读只会在“当前读”下才会出现，同时幻读专指“新插入的行”。</p>
<p>假定有如下的表及初始数据：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`d`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`c`</span> (<span class="string">`c`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>),(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>),(<span class="number">15</span>,<span class="number">15</span>,<span class="number">15</span>),(<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>),(<span class="number">25</span>,<span class="number">25</span>,<span class="number">25</span>);</span><br></pre></td></tr></table></figure></p>
<p>现在对该表执行三个事务，如下图所示：<br><img src="/images/multi-transaction.jpg" alt="multi-transaction" title="multi-transaction"></p>
<p>可以看到，事务A里执行了三次查询，分别是 Q1、Q2 和 Q3。它们的 SQL 语句相同，都是 select * from t where d=5 for update。这个语句查询所有d=5的行，使用当前读，并且加上锁，现在来看它们的返回结果：</p>
<ol>
<li>Q1只返回id=5这一行数据；</li>
<li>在T2时刻，事务B修改了id=0这行数据，所以Q2返回id=0和id=5这两行数据；</li>
<li>在T4时刻，事务C插入了新的一行数据，所以Q3返回id=0,id=1及id=5这三行数据。</li>
</ol>
<p>其中，Q3 读到 id=1 这一行的现象，被称为“幻读”。也就是说，幻读指的是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。</p>
<h4 id="2-6-1-幻读引发的问题"><a href="#2-6-1-幻读引发的问题" class="headerlink" title="2.6.1 幻读引发的问题"></a>2.6.1 幻读引发的问题</h4><p>幻读会引入两个问题，一是语义上的问题，事务A已经对d=5的行加了锁，其它事务仍然还可以对d=5的行进行操作，如将其它行的d字段改为5或新插入d=5的行；另外一个问题，会导致数据库数据和日志的不一致，如下图所示：<br><img src="/images/phantom-read-problem.jpg" alt="phantom-read-problemn" title="phantom-read-problem"><br>在数据库中id=5的行，d字段修改为100；id=1的行，d=5,c=5。我们再来看binlog的日志：</p>
<ol>
<li><p>T2时刻，事务C提交之后，写入两行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> c=<span class="number">5</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>T4时刻，事务A提交之后，写入三行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> d=<span class="number">100</span> <span class="keyword">where</span> d=<span class="number">5</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>合在一起之后，日志内容如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> c=<span class="number">5</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> d=<span class="number">100</span> <span class="keyword">where</span> d=<span class="number">5</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure></p>
<p>从执行的语句来看，事务A的update最后执行，导致所有d=5的行，d字段都修改为100，与数据库中的数据不一致。如果使用这个binlog日志进行恢复数据或进行主从备份，会导致数据的前后不一致。</p>
<h4 id="2-6-2-解决的办法"><a href="#2-6-2-解决的办法" class="headerlink" title="2.6.2 解决的办法"></a>2.6.2 解决的办法</h4><p>事务B中的update操作可以通过行锁来解决，但对于事务C的插入操作，由于该行在插入之前根本不存在，不能使用行锁来解决，因此，为了解决幻读问题，InnoDB 引入新的锁，也就是间隙锁 (Gap Lock)。顾名思义，间隙锁，锁的就是两个值之间的空隙。比如文章开头的表 t，初始化插入了 6 个记录，这就产生了 7 个间隙。如下图所示：<br><img src="/images/gap-lock.jpg" alt="gap-lock" title="gap-lock"><br>这样，当执行 <code>select * from t where d=5 for update</code> 的时候，就不止是给数据库中已有的 6 个记录加上了行锁，还同时加了 7 个间隙锁。这样就确保了无法再插入新的记录。也就是说这时候，在一行行扫描的过程中，不仅将给行加上了行锁，还给行两边的空隙，也加上了间隙锁。<br>间隙锁和行锁合称 next-key lock，每个 next-key lock 是前开后闭区间。也就是说，我们的表 t 初始化以后，如果用 <code>select * from t for update</code> 要把整个表所有记录锁起来，就形成了 7 个 next-key lock，分别是 (-∞,0]、(0,5]、(5,10]、(10,15]、(15,20]、(20, 25]、(25, +supremum]，其中supremum是InnoDB为每个索引加的一个不存在的最大值。</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>除了上面提到的两种隔离级别：读-提交和可重复读（快照读），数据库还提供了另外两种隔离级别：读未提交和串行化，其中读未提交只解决了脏写，没有解决脏读，而串行化则要求事务串行化执行，由于性能的问题，大多数据库一般不会使用该隔离级别。</p>
<p><strong>参考：</strong></p>
<hr>
<p><a href="https://book.douban.com/subject/30329536/" target="_blank" rel="noopener">1. 数据密集型应用系统设计</a><br><a href="https://time.geekbang.org/column/article/75173?utm_source=pinpaizhuanqu&amp;utm_medium=geektime&amp;utm_campaign=guanwang&amp;utm_term=guanwang&amp;utm_content=0511" target="_blank" rel="noopener">2. 幻读是什么，幻读有什么问题？</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/16/mysql-and-ignite-update-operation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/05/16/mysql-and-ignite-update-operation/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">mysql和ignite更新性能对比</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-05-16 16:58:02" itemprop="dateCreated datePublished" datetime="2020-05-16T16:58:02+08:00">2020-05-16</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-07-31 17:17:10" itemprop="dateModified" datetime="2021-07-31T17:17:10+08:00">2021-07-31</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据库/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前段时间，需要对内存数据库ignite进行造型，将mysql与ignite进行了性能测试，这篇文章主要是讲在update操作上两者的差异。我们首先假定数据库表如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_token_info (</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">	token_id <span class="built_in">CHAR</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	state <span class="built_in">TINYINT</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	server_id <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	room_id <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	update_date datetime <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	PRIMARY <span class="keyword">KEY</span> (datetime)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> idx_token_id <span class="keyword">ON</span> t_token_info (token_id);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx_server_id <span class="keyword">ON</span> t_token_info (server_id);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx_room_id <span class="keyword">ON</span> t_token_info (room_id);</span><br></pre></td></tr></table></figure></p>
<p>t_token_info表上有4个索引，其中在字段id上建立主键索引，token_id上建立唯一索引，server_id和room_id上建立B+Tree索引。更新的场景包括两方面：1）在token_id上进行更新，只影响一条件记录；2）批量更新，根据server_id及room_id上进行批量更新，一次server_id操作影响的记录为2000条。下面将对mysql及ignite两种数据库进行分析 ，首先分析update操作背后的逻辑，然后再根据场景进行性能测试，最后得出结论。</p>
<h2 id="1-Mysql"><a href="#1-Mysql" class="headerlink" title="1. Mysql"></a>1. Mysql</h2><h3 id="1-1-单条记录更新"><a href="#1-1-单条记录更新" class="headerlink" title="1.1 单条记录更新"></a>1.1 单条记录更新</h3><p>以下面的更新为例，分析mysql的操作过程：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> t_token_info <span class="keyword">set</span> state=<span class="number">1</span>,update_date=<span class="keyword">now</span>(),server_id=<span class="number">12</span> <span class="keyword">where</span>  token_id=token1;</span><br></pre></td></tr></table></figure></p>
<p><img src="/images/mysql-update.jpg" alt="mysql-update" title="mysql-update"></p>
<p>涉及到的IO操作如下：</p>
<ol>
<li>读取记录：包括B+Tree索引结点及数据的读取，假定索引及数据没有加载到内存，且B+Tree索引深度为2（分支因子为500且结点大小为4K的四级树可以存储256 TB的数据），则需要3次IO操作，两次读取索引结点，一次读取数据；</li>
<li>写入操作：包括预写日志（存储引擎的redo log日志）、binlog日志及写入的数据，至少三次IO操作，如果新写入的数据，导致B+Tree叶子结点进行分裂操作，则需要更多的IO操作；</li>
<li>更新索引操作：因为更新的字段state及activeId是二级索引，更新这两个值，在事务中需要更新索引。更新索引又涉及到读取索引结点，更新索引的内容，等同于多次对数据进行更新操作，索引越多，则IO操作越多。</li>
</ol>
<h3 id="1-2-批量更新"><a href="#1-2-批量更新" class="headerlink" title="1.2 批量更新"></a>1.2 批量更新</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> t_token_info <span class="keyword">set</span> state=<span class="number">1</span>,update_date=<span class="keyword">now</span>() <span class="keyword">where</span> server_id=<span class="number">12</span>;</span><br></pre></td></tr></table></figure>
<p>批量更新操作最终会转换为多次主键更新操作，这个操作由mysql服务器中执行器模块来执行，如下图所示：<br><img src="/images/mysql-batch-update.jpg" alt="mysql-batch-update" title="mysql-batch-update"></p>
<p>批量更新的操作如下：</p>
<ol>
<li>根据activeId的索引找到更新的tokenId列表；</li>
<li>遍历tokenId列表，取到tokenId，再根据主键索引找到token的数据；</li>
<li>执行单个token的执行操作，直到所有的token更新完毕；</li>
<li>批量更新的时间与影响的记录数存在线性的关系，记录数越多，时间越长。</li>
</ol>
<h2 id="2-ignite"><a href="#2-ignite" class="headerlink" title="2. ignite"></a>2. ignite</h2><h3 id="2-1-ignite固化内存模型"><a href="#2-1-ignite固化内存模型" class="headerlink" title="2.1 ignite固化内存模型"></a>2.1 ignite固化内存模型</h3><p><img src="/images/Durable_Memory_Diagram.png" alt="Durable_Memory_Diagram" title="Durable_Memory_Diagram"><br>iginte固化内存模型的层次：</p>
<ul>
<li>内存区域：可以根据业务需要，可以将内存分为不同的大小的段，每一个区域分为不同的页，如存放key-value对（ignite本质是基于key-value的内存数据库）的数据页；B+Tree元数据页，存放每一个索引的根结点及层次信息；索引页面，存放B+Tree结点，根据索引字段进行排序，值存储数据结点的页号及偏移值；空闲页，由多个空闲链表进行维护。</li>
<li>页：分为不同类型，一般为4K，可以进行配置。</li>
</ul>
<h3 id="2-2-B-Tree和索引页面"><a href="#2-2-B-Tree和索引页面" class="headerlink" title="2.2 B+Tree和索引页面"></a>2.2 B+Tree和索引页面</h3><p><img src="/images/page-memory-b-tree.png" alt="page-memory-b-tree" title="page-memory-b-tree"><br>应用定义和使用的SQL索引是以B+Tree数据结构的形式进行维护的。每个唯一索引Ignite会实例化并且管理一个专用的B+Tree实例。<br>整个B+Tree的目的就是链接和排序在固化内存中分配和存储的索引页面。从内部来说，索引页面包括了定位索引值、索引指向的缓存条目在数据页面中的偏移量、还有到其它索引页面的引用（用来遍历树）等所有必要的信息，缓存的键也会存储于B+Tree，它们通过哈希值进行排序。<br>B+树的元页面需要获得特定B+Tree的根和它的层次，以高效地执行范围查询。比如，当执行myCache.get(keyA)时，它会触发下面的操作流程：</p>
<ol>
<li>Ignite会查找myCache属于那个内存区；<br>在该内存区中，会定位持有myCache的键的B+Tree的元页面；</li>
<li>根据keyA的哈希值，然后在B+Tree中检索该键所属的索引页面；</li>
<li>如果对应的索引页面在内存/磁盘中没找到，那么意味着其在myCache中不存在，然后Ignite会返回null；</li>
<li>如果索引页面存在，那么它会包含找到缓存条目keyA所在的数据页面的所有必要信息；</li>
<li>Ignite定位keyA所属的数据页面然后将值返回给应用。</li>
</ol>
<p>3、数据的存储<br> <img src="/images/inginte-data.png" alt="inginte-data" title="inginte-data"><br>上图是一个数据页的内部结构，包括三个部分：1）Page Header；2）Data Header；3）Page Data，数据区，存放key-value对。</p>
<p>4、更新操作流程<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> t_token_info <span class="keyword">set</span> state=<span class="number">1</span>,update_date=<span class="keyword">now</span>(),server_id=<span class="number">12</span> <span class="keyword">where</span>  token_id=token1;</span><br></pre></td></tr></table></figure></p>
<p>在ignite内部中，一次操作为转化为缓存的一次put操作。myCache.put(keyA,valueA)操作的执行流程如下：</p>
<ol>
<li>Ignite会找到myCache所属的内存区；</li>
<li>在该内存区中，会定位持有myCache的键的B+树的元数据页面；</li>
<li>根据keyA的哈希值，然后在B+树中检索该键所属的索引页面；</li>
<li>如果对应的索引页面在内存或者磁盘上都没有找到，那么会从空闲列表中申请一个新的页面，成功之后，它就会被加入B+树；</li>
<li>如果索引页面是空的（即未引用任何数据页面），根据总的缓存条目大小会从空闲列表中分配一个新的数据页面，然后在索引页面中添加到新数据页面的引用；</li>
<li>该缓存条目会加入该数据页面。</li>
</ol>
<p>5、批量更新<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> t_token_info <span class="keyword">set</span> state=<span class="number">1</span>,update_date=<span class="keyword">now</span>() <span class="keyword">where</span> server_id=<span class="number">12</span>;</span><br></pre></td></tr></table></figure></p>
<p>在ignite中，批量更新操作，内部会转化为两个操作：1）select * from tokeninfo where activeId=12，先进行一次select操作，查询出修改的记录；2）再调用cache.invokeAll(…) 修改数据。<br>使用这种方式，批量更新的操作等同于：一次select操作（客户端操作） + n次单条记录的更新操作（客户端批量提交到服务器器），下面就对批量更新的性能进行验证。</p>
<h2 id="3-性能验证"><a href="#3-性能验证" class="headerlink" title="3. 性能验证"></a>3. 性能验证</h2><ol>
<li>场景1：假定有20万token数据，每一个服务器上的token数为2000个；</li>
<li>场景1：假定有20万token数据，每一个服务器上的token数为200个；</li>
<li>场景1：假定有20万token数据，每一个服务器上的token数为20个；</li>
</ol>
<p>分别在三种场景下，执行两种操作：1）按照唯一键token_id更新; 2）按照server_id进行批量更新。</p>
<h2 id="4-结论（ignite使用纯内存）"><a href="#4-结论（ignite使用纯内存）" class="headerlink" title="4. 结论（ignite使用纯内存）"></a>4. 结论（ignite使用纯内存）</h2><ol>
<li>ignite按照主键进行更新，QPS可以达到10,000，响应时间在5~10ms，性能相比mysql，有较大的提升。</li>
<li>ignite中批量更新操作会转换为：一个select操作 + n个token的更新操作。在批量执行token前，客户端需要执行一次select操作，获取影响的记录（获取主键），然后向服务器批量提交更新操作（根据主键进行操作）。客户端执行一次select操作，性能上会有一定的影响；</li>
<li>根据三种场景的测试，按照服务器进行批量更新操作，QPS及响应时间受两个因素影响：1）数据库服务器1S内可更新的缓存数量SC；2）一个操作影响的记录数ST。在SC确定的情况下，ST越大，QPS越小，响应时间越长，ST越小，QPS越大，响应时间越短。目前测试得出，在单台服务上1S可以完成对20，000个缓存的更新操作，如果ST为2000个，QPS只能达到10，受SC影响，如果ST为200个，QPS增大10倍，响应时间减少到10/1。</li>
</ol>
<p><strong>参考：</strong></p>
<hr>
<p><a href="https://www.ignite-service.cn/doc/java/DurableMemory.html#_1-%E5%9B%BA%E5%8C%96%E5%86%85%E5%AD%98" target="_blank" rel="noopener">1. 固化内存</a></p>
<p><a href="https://cwiki.apache.org/confluence/display/IGNITE/Ignite+Durable+Memory+-+under+the+hood" target="_blank" rel="noopener">2. Ignite Durable Memory - under the hood</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/05/storage-model/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/05/05/storage-model/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">存储引擎</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-05-05 16:20:33" itemprop="dateCreated datePublished" datetime="2020-05-05T16:20:33+08:00">2020-05-05</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-07-31 17:17:10" itemprop="dateModified" datetime="2021-07-31T17:17:10+08:00">2021-07-31</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据库/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>概括来讲，存储引擎分为两大类：针对事务处理（OLTP）优化的结构，以及针对分析型（OLAP）的优化结构。它们典型的访问模式存在很大的差异：</p>
<ul>
<li>OLTP系统通常面向用户，这意味着它们可能收到大量的请求。为了处理负载，应用程序通常在每个用户查询中只涉及小量的记录。应用程序基于某种键来请求记录，而存储引擎使用索引来查找所请求的数据。磁盘寻道时间往往是瓶颈。</li>
<li>由于不直接面对最终用户，数据仓库和类似的分析系统相对并不太广为人知，它们主要由业务分析师使用。处理的查询请求数目远低于OLTP系统，但每个查询通常要求非常苛刻，需要在短时间内扫描百万条记录。磁盘带宽（不是寻道时间）通常是瓶颈，而面向列的存储对于这种工作负载成为日益流行的解决方案。<br>在OLTP方面，有两个主要流派的存储引擎：</li>
<li>日志结构流派：它只允许追加方式更新文件和删除过时的文件，但不会修改已写入的文件。BitCask、SSTable、LST-Tree、LevelDB、Cassandra、HBase、Lucence等属于此类；</li>
<li>原地更新流派：将磁盘视为可以覆盖的一组固定大小的页。B-Tree是这个哲学的最典型代表，它已用于所有主要的关系数据库，以及大量的非关系数据库。</li>
</ul>
<p>日志结构的存储引擎是一个相对较新的方案。其关键思想是系统地将磁盘上随机访问写入转为顺序写入，由于硬盘驱动器和SSD的性能特性，可以实现更高的写入吞吐量。下面将针对这两种存储引擎进行分析。</p>
<h2 id="1-LSM-Tree"><a href="#1-LSM-Tree" class="headerlink" title="1. LSM-Tree"></a>1. LSM-Tree</h2><p>LSM-Tree(Log-Structured Merge Tree)广泛用于key-value存储引擎库中，如LevelDB和RocksDB，类似的存储引擎还用于Cassandra和HBase中，它的主要特征包括：1）数据顺序写入，不支持更新（更新及删除通过压缩合并数据段来实现）；2）数据写入操作内存表，数据异步写入磁盘；3）数据以SSTable段的形式写入磁盘，按照key进行排序，定期对数据段进行压缩合并；4）在内存中建立索引，由于数据段已经排序，只需要记录段首的记录即可。其结构如下所示：<br><img src="/images/lsm-tree.jpg" alt="lsm-tree" title="lsm-tree"></p>
<p>LSM-Tree存储引擎数据存储于SSTables中，一个SSTables表示一个数据段，存储的是key-value值，且按照key进行排序，这种格式也称为排序字符串表。SSTables有两种形式，在内存中，采用的数据结构主要是树状数据结构，如红黑树或AVL树，进行内存排序；内存中的SSTables大于某个阈值时，顺序写入到磁盘中的日志文件中。</p>
<p>LSM-Tree存储引擎的工作流程如下：</p>
<ul>
<li>当写入时，将其添加到内存中的平衡树数据结构中（例如红黑树）。这个内存中的树有时也被称为内存表；</li>
<li>当内存表大于某个阈值（通常为几兆字节）时，将其作为SSTable文件写入到磁盘。由于树已经维护了按照key排序的key-value对，写磁盘可以比较高效。新的SSTable文件成为数据库的最新部分。当SSTable写磁盘的同时，写入可以继续添加到一个新的内存表实例；</li>
<li>为了处理读请求，首先尝试在内存表中查找key,然后是最新的磁盘段文件，接下来是次新的磁盘段文件，以此类推，直到找到目标；</li>
<li>后台进程周期性执行段合并及压缩过程，以合并多个段文件，并丢弃那些已经被覆盖或删除的值；</li>
<li>每个写入操作都会立即追加到一个WAL日志文件中，它记录了操作的内容，它的目的是在数据库崩溃之后恢复内存表，每当将内存表写入SSTable时，相应的日志可以被丢弃。</li>
</ul>
<p>数据库运行一段时间之后，磁盘上会生成多个SSTable文件，一个key可以包含在多个SSTable文件中，即一个key可以有多个版本。后台进程使用合并排序算法周期性地合并数据段，如下图所示。并发读取多个输入段文件，比较每个文件的第一个key，把最小的key（根据排序文件）拷贝到输出文件，并重复这个过程，最后会产生一个新的按key排序的合并段文件。当多个段包含相同的key时，可以保留最新段的值，并丢弃旧段中的值。<br>在文件中查找特定的key时，不需要在内存中保存所有key的索引，因为段是排序的，只需要一个内存索引来记录段首的key，可以减少内存的占用，同时可以进行区间查询。由于读请求往往需要扫描请求范围内的多个key-value对，可以考虑将这些记录保存到一个磁盘块中并在写磁盘前将其压缩。然后内存索引的每个条目指向压缩块的开关。除了节省磁盘空间，压缩还减少了I/O带宽的占用。</p>
<p><img src="/images/lsm-tree-combine.jpg" alt="lsm-tree-combine" title="lsm-tree-combine"></p>
<p>查找数据库中某个不存在的key时，LSM-Tree算法可能很慢：在确定key不存在之前，必须先检查内存表，然后将段一直回溯访问到最旧的段文件（可能必须从磁盘多次读取），为了优化这种访问，存储引擎通常使用额外的布隆过滤器。</p>
<h2 id="2-B-Tree"><a href="#2-B-Tree" class="headerlink" title="2. B-Tree"></a>2. B-Tree</h2><p>B-Tree是关系数据库中被广泛使用的索引结构，像SSTable一样，B-Tree留按照key排序的key-value对，这样可以实现高效的key-value查找和区间查询。从本质上来说，B-Tree具有非常不同的设计理念。<br>在LSM-Tree中，日志结构索引将数据库分解为可变大小的段，通常大小为几兆字节或更大，并且始终按顺序写入段。相比之下，B-Tree将数据库分解为固定大小的块或页，传统上大小为4 KB（有时更大），页是内部读/写的最小单元。这种设计更接近底层硬件，因为磁盘也是以固定大小的块排列。<br>每个页面都可以使用地址或位置进行标识，这样可以让一个页面引用另一个页面，类似指针，不过是指向磁盘地址，而不是内存，可以使用这些页面引用来构造一个树状页面，如下所示。<br><img src="/images/b-tree.jpg" alt="b-tree" title="b-tree"><br>某一页被指定为B-Tree的根，每当查找索引中的一个key时，总是从这里开始。该页面包含若干个key和对子页的引用。每个孩子都负责一个连续范围内的key,相邻引用之间的key可以指示这些范围之间的边界。<br>假定正在查找key 251,需要沿着200~300间的页引用，到达类似的页，它进一步将200~300范围分解成子范围。最终到达一个包含单个key的页(叶子页)，该页包含每个内联key的值或包含找到值的页的引用。<br>B-Tree中每一个页所包含的子页引用数量称为分支因子，例如在上图中，分支因子为6，在实际中，分支因子取决于存储页面引用和范围过界所需的空间总量，通常为几百个。<br>在正常情况下，数据库表一般只包含一个主键索引，如上图中以user_id为主键的索引。在主键索引中根据叶子结点中存储记录的内容还是引用，可以分为聚集索引和非聚集索引，而二级索引引用主键，如下图所示，在user_name上建立一个二级索引，它引用的值是主键。<br><img src="/images/b-tree-index.jpg" alt="b-tree-index" title="b-tree-index"></p>
<p>如果更新B-Tree中原有的值，首先搜索包含该key的叶子页，更改该页的值，并将页定回到磁盘（对该页的任何引用仍然有效）。如果要添加新key，则需要找到其范围包含新key的页，并将其添加到该页，如果页中没有足够的可用空间来容纳新key，则将其分裂为两个半满的页，并且父页也需要更新以包含分裂之后的新key范围，如下图所示：<br><img src="/images/b-tree-split.jpg" alt="b-tree-split" title="b-tree-split"><br>该算法确保树保持平衡：具有n个key的B-Tree总是具有O(log n)的深度，大多数数据库可以适合3~4层的B-Tree，因此不需要遍历非常深的页面层次即可找到所需的页（分支因子为500的4 KB页的四级树可以存储高达256 TB）。</p>
<p>为了使数据库能从崩溃中恢复，常见的B-Tree的实现需要支持磁盘上的额外的数据结构：预写日志（Write-ahead log,WAL），也称为重做日志。这是一个仅支持追加修改的文件，每一个B-Tree的修改必须先更新WAL然后再修改树本身的页。当数据库在崩溃后需要恢复时，该日志用于将B-Tree恢复到最近一致的状态。</p>
<h2 id="3-对比B-Tree和LSM-Tree"><a href="#3-对比B-Tree和LSM-Tree" class="headerlink" title="3. 对比B-Tree和LSM-Tree"></a>3. 对比B-Tree和LSM-Tree</h2><p>根据经验，LSM-Tree通常对于写入更快，而B-Tree被认为对于读取更快。读取通常在LSM-Tree上较慢，主要是因为它们必须在不同的压缩阶段检查多个不同的数据结构和SSTable。</p>
<h3 id="3-1-磁盘写入"><a href="#3-1-磁盘写入" class="headerlink" title="3.1 磁盘写入"></a>3.1 磁盘写入</h3><p>B-Tree索引必须至少写两次数据：一个写入预写日志，一次写入树的页本身（还可能发生页分裂）。即使该页中只有几个字节更改，也必须承受整个页的开销。另外，B-Tree存储引擎使用与磁盘类似的分页结构，存在磁盘的碎片化。<br>LSM-Tree数据通常是写入内存表，内存表达到一定阈值的时候再统一写入磁盘，对于磁盘上的SStable段文件由后台线程进行合并压缩，效率更高，同时也会减少磁盘碎片。相对B-Tree来说，具有更高的写入吞吐量。</p>
<h3 id="3-2-事务支持"><a href="#3-2-事务支持" class="headerlink" title="3.2 事务支持"></a>3.2 事务支持</h3><p>B-Tree的优点则是每个键都恰好唯一对应于索引中的某个位置，而日志结构的存储引擎可能在不同的段中具有相同键的多个副本。如果数据库希望提供强大的事务语义，B-Tree显得更具吸引力：在许多关系数据库，事务隔离是通过键范围上的锁来实现的，并且在B-Tree索引中，这些锁可以直接定义到树中。</p>
<p><strong>参考：</strong></p>
<hr>
<p><a href="https://book.douban.com/subject/30329536/" target="_blank" rel="noopener">1. 数据密集型应用系统设计</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/25/non-functional-features-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/04/25/non-functional-features-1/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">系统设计-非功能性特性</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-04-25 20:49:32" itemprop="dateCreated datePublished" datetime="2020-04-25T20:49:32+08:00">2020-04-25</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-07-31 17:17:10" itemprop="dateModified" datetime="2021-07-31T17:17:10+08:00">2021-07-31</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/非功能性特性/" itemprop="url" rel="index"><span itemprop="name">非功能性特性</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在大多数软件系统中，功能特性决定了系统能做什么，而非功能特性决定了系统能走多远，本篇文章专注于非功能特性中三个比较重要的特性：</p>
<ul>
<li>可靠性（Reliability）：当出现意外情况如硬件、软件故障、人为失误等，系统应可以继续正常运转：虽然性能可能有所降低，但确保功能正确。</li>
<li>可扩展性（Scalability）:随着规模的增长，例如数据量、流量或复杂性，系统应以合理的方式来匹配这种增长。</li>
<li>可维护性（Maintainability）：随着时间的推移，许多新的人员参与到系统开发和运维，以维护现有功能或适配新场景等，系统都应高效运转。</li>
</ul>
<h2 id="1-可靠性"><a href="#1-可靠性" class="headerlink" title="1. 可靠性"></a>1. 可靠性</h2><p>可靠性意味着即使发生故障，系统也可以正常工作。故障包括硬件（通常是随机的，不相关的），软件（缺陷通常是系统的，更加难以处理）以及人为（总是很难避免时不时会出错）方面。容错技术可以很好地隐藏某种类型故障，避免影响最终用户。</p>
<h2 id="2-可扩展性"><a href="#2-可扩展性" class="headerlink" title="2. 可扩展性"></a>2. 可扩展性</h2><p>可扩展性是指负载增加时，有效保持系统性能的相关技术策略。即使系统现在工作可靠，并不意味着它将来一定能够可靠运转。发生退化的一常见原因是负载增加：例如并发用户从最初的10 000个增长到100 000个，或从100万到1000万；又或者系统目前要处理的数据量超出之前很多倍。可扩展性是用来描述系统应对负载增加能力的术语，为了讨论可扩展性，首先需要明确如何定量描述负载和性能？</p>
<h3 id="2-1-负载"><a href="#2-1-负载" class="headerlink" title="2.1 负载"></a>2.1 负载</h3><p>负载可以用称为负载参数的若干数字来描述，参数的最佳选择取决于系统的体系结构，它可能是Web服务器的每秒请求处理次数，数据库写入的比例，聊天室的同时活动用户数量，缓存命中率等。有时平均值很重要，有时系统瓶颈来自于少数峰值。</p>
<p>以Twitter为例，使用其2012年11月发布的数据。Twitter的两个典型业务操作是：</p>
<ul>
<li>发布tweet消息：用户可以快速推送新消息到所有的关注者，平均大约4.6k requests/sec，峰值约12k requests/sec。</li>
<li>主页时间线（Home timeline）浏览：平均300k requests/sec 查看关注对象的最新消息。</li>
</ul>
<h3 id="2-2-性能"><a href="#2-2-性能" class="headerlink" title="2.2 性能"></a>2.2 性能</h3><p>如果负载增加将会发生什么，有两种考虑方式：</p>
<ul>
<li>负载增加，但系统资源（如CPU、内存、网络带宽等）保持不变，系统性能会发生什么变化；</li>
<li>负载增加，如果要保持性能不变，需要增加多少资源？</li>
</ul>
<p>这两个问题都会关注性能指标，那如何描述系统性能？</p>
<p>在批处理系统中如Hadoop中，通常关心吞吐量(throughput)，即每秒可处理的记录条数，或者在某指定数据集上运行作业所需的总时间；而在线系统通常更重服务的响应时间(response time)，即客户端从发送请求到接收响应之间的间隔。</p>
<p>服务的响应时间通常是使用服务请求的平均响应时间，即n个请求响应时间的算术平均值。然而，如果想知道多少用户实际经历了多少延迟，最好使用百分位数(percentiles)。如果已经搜集到响应时间信息，将其从最快到最慢排序，中位数(median)就是列表中间的响应时间。例如，如果中位数响应时间为200ms，那意味着有一半的请求响应不到200ms，而另一半请求则需要更长的时间。</p>
<p>中位数指标非常适合描述多少用户需要等待多长时间：一半的用户请求的响应时间少于中位数响应时间，另一半则多于中位数的时间。因此中位数也称为50百分位数，有时也缩写为p50。为了弄清楚异常有多糟糕，需要关注更大的百分位数如常见的第95、99和99.9（缩写为p95、p99和p999）值。作为典型的响应时间阈值，它们分别表示为95%、99%或99.9%的请求响应时间快于阈值。例如95百分位数响应时间为1.5s，这意味着100个请求中的95个请求快于1.5s，而5个请求则需要1.5s或更长的时间。</p>
<h2 id="3-可维护性"><a href="#3-可维护性" class="headerlink" title="3. 可维护性"></a>3. 可维护性</h2><p>可维护性则意味着许多方面，但究其本质是为了让工程和运营团队更为轻松。良好的抽象可以帮助降低复杂性，并使系统更易于修改和适配新场景。良好的可操作性意味着对系统健康状况有良好的可观测性和有效的管理方法。</p>
<p>可运维性在软件设计时就需要开始考虑，尽可能减少维护期间的麻烦，甚至避免造出容易过期的系统。为此，需要特别关注软件系统的三个设计原则：</p>
<ul>
<li>可运维性：方便运营团队来保持系统平衡地运行；</li>
<li>简单性：简化系统复杂性，使新工程师能够轻松理解系统。</li>
<li>可演化性：后续工程师能够轻松对系统进行改进，并根据需求变化将其适配到非典型场景，也称为可延伸性、易修改性或可塑性。</li>
</ul>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>知易行难，使应用程序可靠、可扩展或可维护并不容易，需要结合使用的场景选择不同的策略和技术。</p>
<p><strong>参考：</strong></p>
<hr>
<p><a href="https://book.douban.com/subject/30329536/" target="_blank" rel="noopener">1. 数据密集型应用系统设计</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/20/rocketmq-namesrv-overview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/01/20/rocketmq-namesrv-overview/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">RocketMQ系列：NameServer概览</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-01-20 18:27:30" itemprop="dateCreated datePublished" datetime="2020-01-20T18:27:30+08:00">2020-01-20</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-07-31 17:17:10" itemprop="dateModified" datetime="2021-07-31T17:17:10+08:00">2021-07-31</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/rocketmq系列/" itemprop="url" rel="index"><span itemprop="name">rocketmq系列</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>NameServer 作为消息中间件 RocketMQ 的核心组件之一， 起着注册中心的作用，这篇文章主要是从整体上分析一下NameServer的实现。<br><img src="/images/rocketmq-namesrv-overview.jpg" alt="rocketmq-namesrv-overview" title="rocketmq-namesrv-overview"><br>NameServer可以分为三个层次（暂且这么分，方便理解），1）通信层，使用 Netty 作为底层通信组件，封装统一的网络 IO 事件处理流程，同时用户也可以自定义事件。2）服务层，封装通用的业务逻辑：a）统一请求处理流程；b）定义三种调用方式，如同步调用，异步调用及单向调用（发出请求不需要响应数据）；c）响应超时处理；d）IO事件处理。3）业务层，实现请求处理器及事件监听器注册接口，处理NameServer相关的数据，如broker地址及保活信息、topic队列信息及服务器过滤信息。</p>
<ul>
<li><p>通信层：Netty 使用 Reactors 的多线程模型，MainReactor 负责客户端的连接请求，并将请求转交给 SubReactor，SubReactor 负责相应通道的 IO 读写请求。在这里，BossGroup 承担MainReactor的角色，一般只需要一个线程即可（一个 EventLoop 实质就是一个线程），Work Group 承担 SubReactor 的角色，在RomcketMQ中默认是三个线程。从上面的关系可以看出，EventLoopGroup 包含多个 EventLoop，而一个 EventLoop 代表了一个独立的事件循环，循环等待 IO 事件，一般由一个线程来处理，一个 EventLoop 可以同时处理多个 tcp 连接（Channel），同时一个 Channel 所有事件只能在一个 EventLoop 中处理，一个 Channel 一旦分配给一个 EventLoop 之后将不会改变这种关联关系。在 Netty 中事件处理使用了责任链的模式，将事件处理分为不同的处理单元，让数据以水流的方式在管道中流动处理，每一个阀门都有一个独立的处理逻辑，这些处理单元包括但不限此，如数据的编/解码、数据的转换、空闲连接的检测及数据的消费，在 Netty 中，这些处理单元叫做 Handler 对象。每一个 Handler 对象存储在 ChannelHandlerContext 对象中，再将 ChannelHandlerContext 对象串连起来，形成一个双向链表。根据处理事件的不同，Handler 对象可以分为出站或入站对象，入站代表读事件，出站代表了写事件，所以，访问 ChannelHandlerContext 链表也分为出站和入站两种，入站从链首开始，正向访问，而出站则从链尾开始，反向访问。 在 ChannelPipeline 对象中，存储 ChannelHandlerContext 链表的链首及链尾对象，每一个 Channel 对象都会关联一个 ChannelPipeline 对象，在处理事件的时候，可方便调用相应的 Handler 对象，上层应用只要定义相应的 Handle对象 到Netty中即可。下图是 EventLoop 处理事件的流程。<br><img src="/images/rocketmq-namesrv-netty.jpg" alt="rocketmq-namesrv-netty" title="rocketmq-namesrv-netty"><br>可以看到，EventLoop 主要处理三件事：1）在多路复用器 Selector 上调用 select 方法，监听所有的 Channel的 IO 事件；2）执行 IO 处理流程，调用 ChannelHandlerContext 链表，执行业务处理；3）执行提交的任务，在 EventLoop 中，可以处理定时任务，在处理完业务逻辑之后，会调用已经到期的任务执行。定时任务存放在一个优先级队列（scheduleTaskQueue队列，实现类为PriorityQueue队列）中，按照时间进行排序，执行任务前会将已经到期的任务移到 taskQueue 队列中，然后依次执行 taskQueue 队列中的所有任务。</p>
</li>
<li><p>服务层：定义了四个基本功能，1）统一请求处理流程，每一个命令可以注册一个处理器（Processor对象）及处理线程池，不同业务请求可以由不同的线程池处理，这样有做到业务隔离和提高并发处理能力；2）定义了三种调用方式，分别是同步调用、异步调用及单向调用（发出请求不需要响应数据），同步调用及异步调用都是使用 Future 对象来实现，区别在于：同步调用需要在 Future 对象上等待一个超时时间，而异步调用只需定义一个回调方法即可；3）响应超时处理，在异步调用中，调用结束之后程序已经返回了，响应的数据需要在另外一个线程处理，为了方便响应数据找到对应的请求，需要构造一个 Future 对象存储到响应结果表中，请求及响应数据包含相同的请求序号，可以方便地从表中检索到 Future 对象，调用对应的回调函数。在这里，有一个问题，如果一直没有响应怎么办？这就需要一个线程定时扫描响应结果表，将已经超时的请求移除响应结果表；4）IO事件处理，主要包括连接、空闲、关闭及异常事件，上层应用注册事件监听器（ChannelEventListener）来处理相关的事件。</p>
</li>
<li><p>业务层：业务层维护了 broker 地址及保活信息、topic 队列信息及服务器过滤信息，Broker 定期向 NameServer 发送心跳信息，心跳信息中就包含了这些信息，另外生产者和消费者也会向 NameServer查询Broker及topic的信息，业务层通过向服务层注册请求处理器（Processor对象）及事件监听器（ChannelEventListener对象），来处理心跳、查询等请求。</p>
</li>
</ul>
<p>通过上面的分析可以看出，NameServer 在设计结构比较清晰，在业务处理过程中，使用了异步的处理方式，大大提高了服务器的处理能力。</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/08/java-stream-pipeline/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/12/08/java-stream-pipeline/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">Java Stream Pipeline</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-12-08 20:13:30" itemprop="dateCreated datePublished" datetime="2019-12-08T20:13:30+08:00">2019-12-08</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-07-31 17:17:10" itemprop="dateModified" datetime="2021-07-31T17:17:10+08:00">2021-07-31</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java基础/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><blockquote>
<p>Java 8中的Stream是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作（Aggregate operation），或者大批量数据操作(Bulk data operation)。Stream API借助于同样新出现的Lambda表达式，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用fork/join并行方式来拆分任务和加速处理过程<sup>1</sup>。</p>
</blockquote>
<p>这篇文章重点分析Stream背后的数据结构及执行流程，以下面代码为例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">int</span> sum = list.stream().filter(x -&gt; x % <span class="number">2</span> == <span class="number">0</span>).sorted(Comparator.reverseOrder()).map(x -&gt; x * x).reduce((x, y) -&gt; x + y).get();</span><br></pre></td></tr></table></figure></p>
<p>在这段执行代码之后，将会生成以下的数据结构：</p>
<p><img src="/images/java-stream-pipeline.jpg" alt="java-stream-pipeline" title="java-stream-pipeline"></p>
<ul>
<li>操作的定义：对数据的一次处理，如过滤(filter)，排序(sorted)，映射(map)及规约（reduce）等等。操作有三种类型：1)Head，头结点，没有实际操作，包含了数据源；2)ReferencePipeline，中间操作，代表了一次数据处理；3)TerminalOp，结束操作，代表处理的结束。</li>
<li>ReferencePipeline对象代表了一次中间操作，描述了操作的静态信息，Stream执行的一次中间操作之后都会生成一个ReferencePipeline对象(StatelessOp及StatefulOp)，这些对象在最终操作（reduce）之前会形成一个双向链表，此时只是建立操作的前后关系，还未执行真正的操作。</li>
<li>Sink对象代表了真正的所要执行的操作，执行terminal操作(如reduce)之后，将会从后往前生成一个”操作序列”，如上图所示的wrapedSink对象。每一个ReferencePipeline对象对应一个Sink对象，代表了ReferencePipeline所要执行的操作，前一个Sink对象会持有下一个操作的Sink对象，形成一个单向链表。</li>
<li>Sink对象有四个基本方法：1）begin()，操作的开始；2）end()，代表操作结束；3）accept(E e)，真正的操作,如filter,sorted,map及reduce等数据处理；4）cancellationRequested，是否取消操作，用于断路操作，如anyMatch表示找到第一个匹配的对象，后面的数据不用再执行，直接退出；Sink对象根据需要实现这四个方法，来满足不同的数据处理需求。</li>
<li>ReferencePipeline对象有两种不同的类型：StatelessOp（无状态操作）和StatefulOp（有状态操作），这两种类型的区别就在于数据元素之间是否有依赖，如排序(sotred)操作，是一个有状态操作，需要知道所有数据元素才能进行排序，它会临时生成一个列表存放所有的数据，排序之后，重新迭代处理后面的操作，而对于无状态操作，前一个数据元素的操作与后一个数据元素操作没有关系，可以直接将多个无状态操作合并起来，即前一个操作结束之后，可将操作结果直接传给下一个操作（downstream）,在一次迭代中将所有操作执行完毕，这就是Stream处理数据高效的原因。相对而言，有状态操作会存储临时结果，重起一次迭代，而无状态操作一次迭代即可完成所有操作，如上图所示，因为有sorted操作，所有的数据处理需要两次迭代完成。</li>
<li>上图中的执行流程是一个没有短路操作（后面会讲短路操作的流程）的流程，可以看到，主要分为三个步骤：1）执行begin()，进行初始化操作；2）执行accept()，数据处理；3）执行end()操作，进行数据收尾操作，这三个操作会递归调用，直到碰到有状态操作或结束操作才结束，如果碰到的是有状态操作，如sorted，前一个迭代的end操作将会触发下一个迭代的开始。</li>
</ul>
<p>在文章开始前，先讲述下几个重要概念：<br>1、Stream</p>
<blockquote>
<p>A sequence of elements supporting sequential and parallel aggregate operations.  The following example illustrates an aggregate operation using<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = widgets.stream()</span><br><span class="line">                   .filter(w -&gt; w.getColor() == RED)</span><br><span class="line">                   .mapToInt(w -&gt; w.getWeight())</span><br><span class="line">                   .sum();</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>2、AbstractPipeline</p>
<blockquote>
<p>Abstract base class for “pipeline” classes, which are the core implementations of the Stream interface and its primitive specializations. Manages construction and evaluation of stream pipelines.<br>An AbstractPipelinere presents an initial portion of a stream pipeline, encapsulating a stream source and zero or more intermediate operations. The individual AbstractPipeline objects are often referred to as stages, where each stage describes either the stream source or an intermediate operation.</p>
</blockquote>
<p>3、Sink</p>
<blockquote>
<p>An extension of Consumer used to conduct values through the stages of a stream pipeline, with additional methods to manage size information, control flow, etc.  Before calling the  accept() method on a code Sink for the first time, you must first call the  begin() method to inform it that data is coming (optionally informing the sink how much data is coming), and after all data has been sent, you must call the end() method.  After calling end(), you should not call accept() without again calling begin(). Sink also offers a mechanism by which the sink can cooperatively signal that it does not wish to receive any more data (the cancellationRequested() method), which a source can poll before sending more data to the Sink.</p>
</blockquote>
<h2 id="2-AbstractPipeline"><a href="#2-AbstractPipeline" class="headerlink" title="2. AbstractPipeline"></a>2. AbstractPipeline</h2><p>在Stream中执行的一个数据处理都对应一个操作，最终以双向链表的形式组织起来，而操作的类型分为三种：1）head头结点；2）ReferencePipeline，中间操作；3）TerminalOp，结束操作，实际上head头结点也是ReferencePipeline类型，只是它有点特殊，它没有实际的操作，所以单独把它拿出来。ReferencePipeline中间操作分为两种操作：1）有状态操作(StatefulOp)；2）无状态操作（StatelessOp）,两者的操作在上面内容已经讲述过，在这里不再赘述。TerminalOp结束操作也分为两种操作：1）非短路操作；2）短路操作，这两者之间的区别在短路操作会终止后续的操作，提前返回，关于短路操作在后面的内容重点讲述。这几种分类如下图所示：</p>
<table width="600"><tr><td colspan="3" style="text-align:center" border="0">Stream操作分类</td></tr><tr><td rowspan="2" border="1">中间操作(Intermediate operations)</td><td>无状态(Stateless)</td><td>unordered() filter() map() mapToInt() mapToLong() mapToDouble() flatMap() flatMapToInt() flatMapToLong() flatMapToDouble() peek()</td></tr><tr><td>有状态(Stateful)</td><td>distinct() sorted() sorted() limit() skip() </td></tr><tr><td rowspan="2" border="1">结束操作(Terminal operations)</td><td>非短路操作</td><td>forEach() forEachOrdered() toArray() reduce() collect() max() min() count()</td></tr><tr><td>短路操作(short-circuiting)</td><td>anyMatch() allMatch() noneMatch() findFirst() findAny()</td></tr></table>

<p>中间操作的类图如下所示：<br><img src="/images/ReferencePipeline.jpg" alt="ReferencePipeline" title="ReferencePipeline"><br>Head,Stateful及StatelessOp都继承自ReferencePipeline类，Head相对其它两种类型，没有实际的操作，只是包含了一个数据源。另外，这三个类也实现了Stream接口，每一个操作都可以继续调用下一个操作，实现链式调用。<br>ReferencePipeline类，有两个比较重要的作用：1）将中间操作以双向链表的形式组织起来，方便后面构建”操作序列”（Sink对象链）；2）构建当前操作的Sink对象，该对象是包含了真正的处理流程。以map方法为例介绍这两个作用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R&gt; <span class="function">Stream&lt;R&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> P_OUT, ? extends R&gt; mapper)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(mapper);</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StatelessOp&lt;P_OUT, R&gt;(<span class="keyword">this</span>, StreamShape.REFERENCE,</span><br><span class="line">                                 StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function">Sink&lt;P_OUT&gt; <span class="title">opWrapSink</span><span class="params">(<span class="keyword">int</span> flags, Sink&lt;R&gt; sink)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Sink.ChainedReference&lt;P_OUT, R&gt;(sink) &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(P_OUT u)</span> </span>&#123;</span><br><span class="line">                    downstream.accept(mapper.apply(u));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在map方法调用中，会生成一个StatelessOp对象，在构造函数中将当前的Pipeline对象（this对象）作为参数传递给新生成的对象，该StatelessOp对象继承了AbstractPipeline抽象类，在AbstractPipeline类中通过nextStage、previousStage两个字段将前后两个操作建立起前后的关联关系，代码如下图所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> previousStage 前一个阶段的操作,就是构建函数中传入的this对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> opFlags the operation flags for the new stage 操作的标志</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">AbstractPipeline(AbstractPipeline&lt;?, E_IN, ?&gt; previousStage, <span class="keyword">int</span> opFlags) &#123;</span><br><span class="line">    <span class="keyword">if</span> (previousStage.linkedOrConsumed)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(MSG_STREAM_LINKED);</span><br><span class="line">    previousStage.linkedOrConsumed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 上一个阶段(前一个操作)的nextStage指向当前的StatelessOp对象</span></span><br><span class="line">    previousStage.nextStage = <span class="keyword">this</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前对象的previousStage指向上一个阶段的对象(前一个操作)</span></span><br><span class="line">    <span class="keyword">this</span>.previousStage = previousStage;</span><br><span class="line">    <span class="keyword">this</span>.sourceOrOpFlags = opFlags &amp; StreamOpFlag.OP_MASK;</span><br><span class="line">    <span class="keyword">this</span>.combinedFlags = StreamOpFlag.combineOpFlags(opFlags, previousStage.combinedFlags);</span><br><span class="line">    <span class="keyword">this</span>.sourceStage = previousStage.sourceStage;</span><br><span class="line">    <span class="keyword">if</span> (opIsStateful())</span><br><span class="line">        sourceStage.sourceAnyStateful = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.depth = previousStage.depth + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外，在StatelessOp对象的opWrapSink方法中，构建了一个Sink.ChainedReference对象，该对象包含了map的处理逻辑。这个方法相对比较简单，数据用mapper方法处理完之后，将结果传递给下个操作(downstream)处理，其中mapper对应是Lamdba表达式：x -&gt; x * x。</p>
<p>TerminalOp终止操作的类图如下所示：<br><img src="/images/TerminalOp.jpg" alt="TerminalOp" title="TerminalOp"><br>TerminalOp有四种类型，分别是：1）ForEachOp；2）FindOp；3）MatchOp；4）ReduceOp。表格中提到的所有终止操作都是基于这四种类型来实现的，另外终止类型的操作并没有加入到由ReferencePipeline组成的双向链表中。<br>最后的终止操作是通过调用诸如forEach(), reduce(), collect(), anyMatch()等这些方法来触发的，这些方法最终会调用ReferencePipeline类中的evaluate()方法来完成操作，在evaluate()方法，生成一个TerminalOp对象，且封装了一个统一的处理流程，现在来看下这个evaluate()方法，其流程如下：<br><img src="/images/stream-evaluate.jpg" alt="stream-evaluate" title="stream-evaluate"></p>
<ul>
<li>根据不同的终止操作生成不同的TerminalOp对象，可以是上面四种类型中的任意一种；</li>
<li>构建数据源Spliterator；</li>
<li>执行evaluate()方法的中间操作ReferencePipeline对象合并TerminalOp对象的操作标志位，如是否短路操作等等；</li>
<li>判断执行的模式，并发模式暂不分析，我们主要分析Sequential模式；</li>
<li>从TerminalOp对象中构建TerminalSink对象；</li>
<li>从后往前遍历中间操作（ReferencePipeline）对象，构建每一个中间操作对应的Sink对象，并将这些Sink对象从前往后生成链表，TerminalSink对象在链尾；</li>
<li>根据操作标志位判来触发真正的动作，如短路操作，或者非短路操作，该部分内容在后面讲述；</li>
</ul>
<p>在这里重点看一个步骤：包装Sink对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sink TerminalSink对象,链尾对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 链首Sink对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">final</span> &lt;P_IN&gt; <span class="function">Sink&lt;P_IN&gt; <span class="title">wrapSink</span><span class="params">(Sink&lt;E_OUT&gt; sink)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(sink);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历所有的中间操作</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>) AbstractPipeline p=AbstractPipeline.<span class="keyword">this</span>; p.depth &gt; <span class="number">0</span>; p=p.previousStage) &#123;</span><br><span class="line">        sink = p.opWrapSink(p.previousStage.combinedFlags, sink);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (Sink&lt;P_IN&gt;) sink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过wrapSink方法，从后往前遍历所有的AbstractPipeline对象，生成每个操作对应的Sink对象，并将后一个Sink对象作为参数传入，赋值给dowonstream字段，从而将所有的Sink对象串连起来，通过链首的Sink对象访问所有的Sink对象。</p>
<h2 id="3-Sink"><a href="#3-Sink" class="headerlink" title="3. Sink"></a>3. Sink</h2><p>Sink对象是扩展自Comsumer接口，主要用来处理数据，除了Comsumer接口的accept()方法，还增加了三个方法：begin(),end()及cancellationRequested()。在调用accept()方法之前，先调用begin(int size)方法，告之数据源的大小，调用accept()方法之后，再调用end()方法，通知数据处理已经结束，如果有短路操作（中止后续数据的处理），必须先调用cancellationRequested()方法，这两种处理模式如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非短路操作</span></span><br><span class="line"><span class="keyword">if</span> (!StreamOpFlag.SHORT_CIRCUIT.isKnown(getStreamAndOpFlags())) &#123;</span><br><span class="line">    <span class="comment">// 1、调用begin()方法，告之数据源大小；</span></span><br><span class="line">    wrappedSink.begin(spliterator.getExactSizeIfKnown());</span><br><span class="line">    <span class="comment">// 2、遍历数据源元素，调用wrappedSink.accept()方法处理数据；</span></span><br><span class="line">    spliterator.forEachRemaining(wrappedSink);</span><br><span class="line">    <span class="comment">// 3、处理完数据之后，调用end()方法</span></span><br><span class="line">    wrappedSink.end();</span><br><span class="line">	</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  <span class="comment">// 短路操作</span></span><br><span class="line">    <span class="comment">// 调用begin()方法，告之数据源大小；</span></span><br><span class="line">    wrappedSink.begin(spliterator.getExactSizeIfKnown());</span><br><span class="line">    <span class="comment">// 2、遍历数据源元素，调用wrappedSink.accept()方法处理数据，</span></span><br><span class="line">    <span class="comment">// 如果上一个元素设置了“短路”标志，说明数据已经完毕，则退出遍历；</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!wrappedSink.cancellationRequested() &amp;&amp; spliterator.tryAdvance(wrappedSink));</span><br><span class="line">    <span class="comment">// 3、处理完数据之后，调用end()方法</span></span><br><span class="line">    wrappedSink.end();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面的代码可以看出，所有的操作都是在一次遍历中完成的，对数据的处理操作已经按照书写顺序串连起来，即Sink对象链表，数据源中的每一个元素依次传递给Sink对象，被Sink对象的accept()方法处理，如果是短路操作，则需要设置”短路”标志，在处理下一个数据元素时，调用cancellationRequested()方法便可知道数据已经处理完毕，退出遍历返回即可。这里有两个问题，1）“短路”标志是如何设置的？2）数据的处理是否只需要一次遍历？<br>1) “短路”标志设置<br>在两个地方需要判断“短路”标志，一个是根据“短路”标志，是否执行“短路”操作，另外一个是在遍历数据源的过程中，判断数据处理是否已经被取消，需要中止操作，以anyMatch()方法为例。<br><img src="/images/short_circuit-1.jpg" alt="short_circuit-1" title="short_circuit-1"><br>如上图所示，判断“短路”的逻辑如下：</p>
<ul>
<li><p>在短路操作的TerminalOp对象中设置短路的标志位；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MatchOp.getOpFlags()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOpFlags</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> StreamOpFlag.IS_SHORT_CIRCUIT | StreamOpFlag.NOT_ORDERED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将TerminalOp对象中短路标志位合并到最后一个ReferencePipeline对象的combinedFlags中；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractPipeline.sourceSpliterator()</span></span><br><span class="line"><span class="keyword">if</span> (terminalFlags != <span class="number">0</span>)  &#123;</span><br><span class="line">    <span class="comment">// Apply flags from the terminal operation to last pipeline stage</span></span><br><span class="line">    combinedFlags = StreamOpFlag.combineOpFlags(terminalFlags, combinedFlags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据combinedFlags判断是否执行短路操作；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractPipeline.copyInto()</span></span><br><span class="line"><span class="keyword">if</span> (!StreamOpFlag.SHORT_CIRCUIT.isKnown(getStreamAndOpFlags())) &#123;</span><br><span class="line">    wrappedSink.begin(spliterator.getExactSizeIfKnown());</span><br><span class="line">    spliterator.forEachRemaining(wrappedSink);</span><br><span class="line">    wrappedSink.end();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    copyIntoWithCancel(wrappedSink, spliterator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>中止操作的逻辑如下：<br><img src="/images/short_circuit-2.jpg" alt="short_circuit-2" title="short_circuit-2"><br>在MatchSink中一个stop的字段，如果找到匹配的数据，则设置stop=true，在进行下一个数据匹配之前递归调用cancellationRequested()，取得stop的值，从而中止操作。</p>
<ul>
<li><p>找到匹配的数据并设置stop；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MatchSink.accept()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 条件匹配</span></span><br><span class="line">    <span class="keyword">if</span> (!stop &amp;&amp; predicate.test(t) == matchKind.stopOnPredicateMatches) &#123;</span><br><span class="line">        stop = <span class="keyword">true</span>; <span class="comment">// 设置stop</span></span><br><span class="line">        value = matchKind.shortCircuitResult;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对下一个数据元素进行数据处理前递归调用cancellationRequested()方法，调用到TerminalSink，结束调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReferencePipeline.forEachWithCancel()</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEachWithCancel</span><span class="params">(Spliterator&lt;P_OUT&gt; spliterator, Sink&lt;P_OUT&gt; sink)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理下一个数据之前调用cancellationRequested()方法</span></span><br><span class="line">    <span class="keyword">do</span> &#123; &#125; <span class="keyword">while</span> (!sink.cancellationRequested() &amp;&amp; spliterator.tryAdvance(sink));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ChainedReference.cancellationRequested()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancellationRequested</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归调用一个Sink的cancellationRequested()方法</span></span><br><span class="line">    <span class="keyword">return</span> downstream.cancellationRequested();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BooleanTerminalSink.cancellationRequested</span></span><br><span class="line"><span class="comment">// 调用到TerminalSink，结束调用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancellationRequested</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> stop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>2）遍历次数<br>中间操作ReferencePipeline对象分为两种类型：1）无状态操作StatelessOp；2）有状态操作StatefulOp。这两种操作的区别在于：在无状态操作StatelessOp中数据元素没有依赖关系，每一个数据元素可以独立处理，而有状态操作StatefulOp中数据元素的处理依赖其它元素，每一个元素不能独立处理，以filter()和sorted()两个方法为例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReferencePipeline.filter()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Stream&lt;P_OUT&gt; <span class="title">filter</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> P_OUT&gt; predicate)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(predicate);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StatelessOp&lt;P_OUT, P_OUT&gt;(<span class="keyword">this</span>, StreamShape.REFERENCE,</span><br><span class="line">                                 StreamOpFlag.NOT_SIZED) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function">Sink&lt;P_OUT&gt; <span class="title">opWrapSink</span><span class="params">(<span class="keyword">int</span> flags, Sink&lt;P_OUT&gt; sink)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Sink.ChainedReference&lt;P_OUT, P_OUT&gt;(sink) &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">(<span class="keyword">long</span> size)</span> </span>&#123;</span><br><span class="line">                    downstream.begin(-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(P_OUT u)</span> </span>&#123;</span><br><span class="line">					<span class="comment">// 如果满足过滤条件，则传递给下一个Sink处理</span></span><br><span class="line">                    <span class="keyword">if</span> (predicate.test(u))</span><br><span class="line">                        downstream.accept(u);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在StatelessOp操作中，经过本阶段的Sink处理完毕之后，会将数据元素继续传递给下一个Sink对象处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sorted()方法对应的Sink对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RefSortingSink</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractRefSortingSink</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 临时生成一个列表对象</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;T&gt; list;</span><br><span class="line"></span><br><span class="line">    RefSortingSink(Sink&lt;? <span class="keyword">super</span> T&gt; sink, Comparator&lt;? <span class="keyword">super</span> T&gt; comparator) &#123;</span><br><span class="line">        <span class="keyword">super</span>(sink, comparator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">(<span class="keyword">long</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size &gt;= Nodes.MAX_ARRAY_SIZE)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(Nodes.BAD_SIZE);</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 2. 列表对象初始化，一般生成不限长度的列表</span></span><br><span class="line">        list = (size &gt;= <span class="number">0</span>) ? <span class="keyword">new</span> ArrayList&lt;T&gt;((<span class="keyword">int</span>) size) : <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 4. 进行排序操作</span></span><br><span class="line">        list.sort(comparator);</span><br><span class="line">	</span><br><span class="line">        <span class="comment">// 5. 重新遍历数据列表，处理后续的操作</span></span><br><span class="line">        downstream.begin(list.size()); <span class="comment">// 通知数据处理开始</span></span><br><span class="line">        <span class="comment">// 6. 判断是否进行“短路”操作</span></span><br><span class="line">        <span class="keyword">if</span> (!cancellationWasRequested) &#123;</span><br><span class="line">            <span class="comment">// 7. 执行非短路操作</span></span><br><span class="line">            list.forEach(downstream::accept);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 8. 执行短路操作</span></span><br><span class="line">            <span class="keyword">for</span> (T t : list) &#123;</span><br><span class="line">                <span class="keyword">if</span> (downstream.cancellationRequested()) <span class="keyword">break</span>;</span><br><span class="line">                downstream.accept(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 9. 通知数据处理结束</span></span><br><span class="line">        downstream.end();</span><br><span class="line">        list = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 3. 将数据元素添加到列表中</span></span><br><span class="line">        list.add(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于排序操作而言，需要知道所有的元素才能进行，所以它临时生成了一个新的列表对象，存储完所有的数据元素之后，再进行排序操作。最后遍历列表对象，重新执行短路/非短路操作，完成剩余的操作。</p>
<p>总上所述，在操作序列中只有无状态操作的话，只要遍历一次即可执行完所有操作，如果包含有状态操作，则每一个有状态操作者需要增加一次遍历。</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>通过上面的分析，Stream的实现有以下三个特点：1）通过链表的方式将操作序列串连起来，数据元素在这个链表中依次流动（传递），可以有效减少数据遍历的次数；2）定义了一套“协议”，规范了前后两个不同操作之间的交互方式，遵循了这套协议，不同操作可按不同顺序组合，完成不同的功能；3）借助Fork/Join框架，数据源可并发执行数据处理，显著提高数据处理的效率。</p>
<p><strong>参考：</strong></p>
<hr>
<p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/index.html" target="_blank" rel="noopener">1. Java 8 中的 Streams API 详解</a></p>
<p><a href="https://www.cnblogs.com/CarpenterLee/p/6637118.html" target="_blank" rel="noopener">2. 深入理解Java Stream流水线</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Noahsark</p>
              <p class="site-description motion-element" itemprop="description">不畏将来，不念过往</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">33</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">18</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">118</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Noahsark</span>

  

  
</div>

<div class="BbeiAn-info">
    <a target="_blank" href="https://beian.miit.gov.cn/" rel="nofollow">粤ICP备 2021097726号-1 </a>
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v6.5.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.5.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.5.0"></script>



  



  










  





  

  

  

  

  

  
  

  

  

  

  

  

  

</body>
</html>
