<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.5.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.5.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.5.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.5.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="不畏将来，不念过往">
<meta name="keywords" content="Java">
<meta property="og:type" content="website">
<meta property="og:title" content="以太格">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="以太格">
<meta property="og:description" content="不畏将来，不念过往">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="以太格">
<meta name="twitter:description" content="不畏将来，不念过往">






  <link rel="canonical" href="http://yoursite.com/page/2/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>以太格</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">以太格</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-commonweal">

    
    
    
      
    

    

    <a href="/404/" rel="section"><i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>公益 404</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于我</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/29/gossip-protocol/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/11/29/gossip-protocol/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">Gossip 协议</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-11-29 17:15:14" itemprop="dateCreated datePublished" datetime="2020-11-29T17:15:14+08:00">2020-11-29</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-07-20 19:23:18" itemprop="dateModified" datetime="2021-07-20T19:23:18+08:00">2021-07-20</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/一致性算法/" itemprop="url" rel="index"><span itemprop="name">一致性算法</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">16k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">14 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>在一致性算法中，Raft 及 Paxos 是强一致性的算法，属于 CP（一致性及分区容错性） 的使用场景，为了保证算法的准确性，必须保证大部分节点（服务器）是正常的（三个节点容忍一个节点失败）。但在 AP （可用性及分区容错性）场景中，即使只有少数机器的存在，仍然可以对外提供服务，这些场景包括：失败检测、路由同步、Pub/Sub 及动态负载均衡。而 Gossip 协议就是这样一种支持最终一致性算法的协议。</p>
<h2 id="2-Gossip-协议"><a href="#2-Gossip-协议" class="headerlink" title="2. Gossip 协议"></a>2. Gossip 协议</h2><p>Gossip 协议，顾名思义，就像流言蜚语一样，利用一种随机、带有传染性的方式，将信息传播到整个网络中，并在一定时间内，使得系统内的所有节点数据一致。相对于 Raft 来说，数据的一致性收敛是随机且滞后的，但提高了系统的可用性。</p>
<p>在一些分类中，将 Gossip 协议分为三类，分别是：</p>
<ol>
<li>直接邮寄（Direct Mail）：数据的变更直接由数据源结点复制给目标结点，不通过中间结点；</li>
<li>反熵（Anti-entropy）：反熵指的是集群中的节点，每隔段时间就随机选择某个其他节点，然后通过互相交换自己的所有数据来消除两者之间的差异，实现数据的最终一致性：</li>
<li>谣言传播（Rumor mongering）：它指是当一个节点有了新数据后，这个节点变成活跃状态，并周期性地联系其他节点向其发送新数据，直到所有的节点都存储了该新数据：</li>
</ol>
<p>相比较而言，反熵需要拷贝全量数据进行比对，会消耗较大的网络带宽及性能，优势是数据可以在相对确定的时间内达成一致；而谣言传播周期性地进行部分增量数据的传播，占用网络带宽较少，具备较好的性能，缺点也是显然的，数据的收敛时间不确定。后面我们将 Gossip 协议特指谣言传播，重点说明谣言传播算法。</p>
<h3 id="2-1-基本原理"><a href="#2-1-基本原理" class="headerlink" title="2.1 基本原理"></a>2.1 基本原理</h3><p>Gossip协议 基本思想就是：一个节点想要分享一些信息给网络中的其他的一些节点。于是，它周期性的随机选择一些节点，并把信息传递给这些节点。这些收到信息的节点接下来会做同样的事情，即把这些信息传递给其他一些随机选择的节点。一般而言，信息会周期性的传递给 n 个目标节点，而不只是一个，如下图所示：<br><img src="/images/consensus-algorithm/gosssip.gif" alt="gossip" title="gossip"></p>
<p><strong>容错性</strong><br>Gossip 协议具备失败容错的能力，即使节点之间没有直接相连，也可以通过其它结点传播信息；</p>
<p><strong>收敛时间</strong><br>Gossip 协议周期性随机选择 n 个结点进行消息的广播，集群中所有结点收到广播的时间是不确定的，虽然可以保证数据最终都可以收到，但收到的时候没有办法预估。可以通过另外一种办法来评估收敛的时间，即通过广播的轮数。它的计算方式如下：<br><img src="/images/consensus-algorithm/gossip-convergence.jpg" alt="gossip-convergence.jpg" title="gossip-convergence.jpg"></p>
<p>排除传播过程中有可能重复的结点，20 个结点的集群进行三轮的广播之后就可要以将数据传播到集群中的所有结点。</p>
<h2 id="3-使用场景"><a href="#3-使用场景" class="headerlink" title="3. 使用场景"></a>3. 使用场景</h2><h2 id="4-Gossip-在-Redis-中的使用"><a href="#4-Gossip-在-Redis-中的使用" class="headerlink" title="4. Gossip 在 Redis 中的使用"></a>4. Gossip 在 Redis 中的使用</h2><p>Redis Cluster 在 3.0 版本引入集群功能。为了让让集群中的每个实例都知道其它所有实例的状态信息，Redis 集群规定各个实例之间按照 Gossip 协议来通信传递信息。<br><img src="/images/consensus-algorithm/redis-cluster.jpg" alt="redis-cluster" title="redis-cluster"></p>
<p>Redis Cluster 中的每个节点都维护一份集群相关的信息，主要包括：</p>
<ol>
<li>当前集群状态；</li>
<li>集群中各节点所负责的 slots 信息及其 migrate 状态；</li>
<li>集群中各节点的 master-slave 状态; </li>
<li>集群中各节点的存活状态及怀疑 Fail 状态。</li>
</ol>
<p>Gossip 协议的主要职责就是信息交换，这些信息包括上面所说的内容。信息交换的载体就是节点彼此发送的 Gossip 消息，常用的 Gossip 消息可分为：ping 消息、pong 消息、meet 消息、fail 消息。</p>
<ol>
<li>meet 消息：用于通知新节点加入。消息发送者通知接收者加入到当前集群，meet 消息通信正常完成后，接收节点会加入到集群中并进行周期性的ping、pong 消息交换；</li>
<li>ping 消息：集群内交换最频繁的消息，集群内每个节点每秒向多个其它节点发送 ping 消息，用于检测节点是否在线和交换彼此状态信息。ping 消息发送封装了自身节点和部分其它节点的状态数据；</li>
<li>pong 消息：当接收到 ping、meet 消息时，作为响应消息回复给发送方确认消息正常通信。pong消息内部封装了自身状态数据。节点也可以向集群内广播自身的 pon g消息来通知整个集群对自身状态进行更新；</li>
<li>fail 消息：当节点判定集群内另一个节点下线时，会向集群内广播一个 fail 消息，其他节点接收到 fail 消息之后把对应节点更新为下线状态。</li>
</ol>
<h3 id="4-1-消息体"><a href="#4-1-消息体" class="headerlink" title="4.1 消息体"></a>4.1 消息体</h3><p>一个 Gossip 协议消息常常包括一个 clusterMsg + n 个 clusterMsgData，clusterMsg 当前结点的信息，包括主从信息及本结点的 slots 信息。clusterMsgData 根据消息类型的不同表示为不同的数据结构，后面进到。消息的结构下图所示：<br><img src="/images/consensus-algorithm/redis-clusterMsg.jpg" alt="redis-clusterMsg" title="redis-clusterMsg"></p>
<p>clusterMsg 结构如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> sig[<span class="number">4</span>];        <span class="comment">/* Signature "RCmb" (Redis Cluster message bus). */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> totlen;    <span class="comment">/* Total length of this message */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> ver;       <span class="comment">/* Protocol version, currently set to 1. */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> port;      <span class="comment">/* TCP base port number. */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> type;      <span class="comment">/* Message type */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> count;     <span class="comment">/* Only used for some kind of messages. */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> currentEpoch;  <span class="comment">/* The epoch accordingly to the sending node. */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> configEpoch;   <span class="comment">/* The config epoch if it's a master, or the last</span></span><br><span class="line"><span class="comment">                               epoch advertised by its master if it is a</span></span><br><span class="line"><span class="comment">                               slave. */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> offset;    <span class="comment">/* Master replication offset if node is a master or</span></span><br><span class="line"><span class="comment">                           processed replication offset if node is a slave. */</span></span><br><span class="line">    <span class="keyword">char</span> sender[CLUSTER_NAMELEN]; <span class="comment">/* Name of the sender node */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> myslots[CLUSTER_SLOTS/<span class="number">8</span>];  <span class="comment">/* 本结点的 slot 信息 */</span></span><br><span class="line">    <span class="keyword">char</span> slaveof[CLUSTER_NAMELEN];</span><br><span class="line">    <span class="keyword">char</span> myip[NET_IP_STR_LEN];    <span class="comment">/* Sender IP, if not all zeroed. */</span></span><br><span class="line">    <span class="keyword">char</span> notused1[<span class="number">34</span>];  <span class="comment">/* 34 bytes reserved for future usage. */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> cport;      <span class="comment">/* Sender TCP cluster bus port */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> flags;      <span class="comment">/* Sender node flags */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> state; <span class="comment">/* Cluster state from the POV of the sender */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> mflags[<span class="number">3</span>]; <span class="comment">/* Message flags: CLUSTERMSG_FLAG[012]_... */</span></span><br><span class="line">    <span class="keyword">union</span> clusterMsgData data;</span><br><span class="line">&#125; clusterMsg;</span><br></pre></td></tr></table></figure>
<p>如果是 PING, MEET and PONG 消息的话，clusterMsgData 发送的是一个 clusterMsgDataGossip 数组，clusterMsgDataGossip 描述了一个结点的简要信息，包括了结点的状态，其中就包括疑似下线结点的状态。如果是 FAIL 消息，则发送的是 clusterMsgDataFail 数据，clusterMsgDataFail 只包含一个字段，即下线结点的名字。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> clusterMsgData &#123;</span><br><span class="line">    <span class="comment">/* PING, MEET and PONG */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="comment">/* Array of N clusterMsgDataGossip structures */</span></span><br><span class="line">        clusterMsgDataGossip gossip[<span class="number">1</span>];</span><br><span class="line">    &#125; ping;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* FAIL */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        clusterMsgDataFail about;</span><br><span class="line">    &#125; fail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* PUBLISH */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        clusterMsgDataPublish msg;</span><br><span class="line">    &#125; publish;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* UPDATE */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        clusterMsgDataUpdate nodecfg;</span><br><span class="line">    &#125; update;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* MODULE */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        clusterMsgModule msg;</span><br><span class="line">    &#125; <span class="keyword">module</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>clusterMsgDataGossip 结构体包括了一个结点的基本信息，其中 pong_received 字段记录了该结点最近一次发送 pong 消息的时间，flags 状态记录了结点的状态，疑似下线状态就是由这个标志来记录的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Initially we don't know our "name", but we'll find it once we connect</span></span><br><span class="line"><span class="comment"> * to the first node, using the getsockname() function. Then we'll use this</span></span><br><span class="line"><span class="comment"> * address for all the next messages. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> nodename[CLUSTER_NAMELEN];</span><br><span class="line">    <span class="keyword">uint32_t</span> ping_sent;</span><br><span class="line">    <span class="keyword">uint32_t</span> pong_received;</span><br><span class="line">    <span class="keyword">char</span> ip[NET_IP_STR_LEN];  <span class="comment">/* IP address last time it was seen */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> port;              <span class="comment">/* base port last time it was seen */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> cport;             <span class="comment">/* cluster port last time it was seen */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> flags;             <span class="comment">/* node-&gt;flags copy */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> notused1;</span><br><span class="line">&#125; clusterMsgDataGossip;</span><br></pre></td></tr></table></figure>
<p>clusterMsgDataFail 结构体只包括了结点的名称，相对比较简单。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> nodename[CLUSTER_NAMELEN];</span><br><span class="line">&#125; clusterMsgDataFail;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-消息传播"><a href="#4-2-消息传播" class="headerlink" title="4.2 消息传播"></a>4.2 消息传播</h3><p>Redis cluser 通过以下的方式进行消息的传播：</p>
<ol>
<li>每 1 S 从 5 个随机结点中选择一个最久未发送 Pong 消息的结点发送　Ping 消息。发送的消息中包括当前结点的信息及多个随机结点的简要信息和状态消息；收到消息的结点，回复一个 Pong 消息；</li>
<li>每 100 MS 扫描一遍所有结点，比较结点上次发送 Pong 消息的时间到当前时间的时长，如果这个时长大于集群超时时间的 1/2，则立即发送 Ping 信息，避免在第一步中有结点长期未被选中的情况发生。</li>
</ol>
<p>这个流程如下图代码所示：<br><img src="/images/consensus-algorithm/redis-clusterCron.jpg" alt="redis-clusterCron" title="redis-clusterCron"></p>
<p>一个消息体包括发送结点本身的信息，同时会随机选择多个结点的状态信息，结点的数量小于总结点数的 1/10，这其中包括正常的结点和疑似下线的结点，流程如下所示：<br><img src="/images/consensus-algorithm/redis-clusterSendPing.jpg" alt="redis-clusterSendPing" title="redis-clusterSendPing"></p>
<h3 id="4-2-故障检测"><a href="#4-2-故障检测" class="headerlink" title="4.2 故障检测"></a>4.2 故障检测</h3><ol>
<li>下线检测：集群中的每个节点都会定期向集群中的其它节点发送 Ping 消息，用于检测对方是否在线，如果接收 Ping 消息的节点没有在规定的时间收到响应的 Ping 消息，那么，发送 Ping 消息的节点就会将接收 Ping 消息的节点标注为疑似下线状态（Probable Fail，Pfail）；</li>
<li>状态传递：集群中的各个节点会通过相互发送 Ping 消息的方式来交换自己掌握的集群中各个节点的状态信息，如在线、疑似下线（Pfail）、下线（fail）。如果一个结点检测到另外一结点疑似下线，该结点会将疑似下线结点的状态通过 Ping 消息传播给集群中其它结点，其它结点收到消息会更新其结点的状态；</li>
<li>下线判定：如果在一个集群里，超过半数的持有 slot(槽) 的主节点都将某个主节点 A 报告为疑似下线，那么，主节点 A 将被标记为下线（fail），检测到 A 结点下线的主结点广播一条 A 下线的 Fail 消息，所有收到这条 Fail 消息的节点都会立即将主节点 A 标记为 fail。至此，故障检测完成。</li>
</ol>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>Gossip 协议在 AP 场景及结点数量频繁变化的场景下，具有较大的优势，但是随着结点数量的增加，消息通信的成本也就更高，因此对于Redis集群来说并不是越大越好。</p>
<p><strong>参考：</strong></p>
<hr>
<p><a href="https://time.geekbang.org/" target="_blank" rel="noopener">1. Gossip协议：流言蜚语，原来也可以实现一致性</a><br><a href="https://segmentfault.com/a/1190000022957348" target="_blank" rel="noopener">2. 漫谈 Gossip 协议</a><br><a href="https://www.cnblogs.com/charlieroro/articles/12655967.html" target="_blank" rel="noopener">3. Gossip是什么</a><br><a href="https://blog.csdn.net/Jin_Kwok/article/details/90111631" target="_blank" rel="noopener">4. 第三章：深入浅出理解分布式一致性协议Gossip和Redis集群原理</a><br><a href="https://segmentfault.com/a/1190000038373546" target="_blank" rel="noopener">5. 一万字详解 Redis Cluster Gossip 协议</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/08/paxos-and-raft/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/11/08/paxos-and-raft/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">Paxos 和 Raft 算法</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-11-08 16:31:26" itemprop="dateCreated datePublished" datetime="2020-11-08T16:31:26+08:00">2020-11-08</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-11-30 17:28:32" itemprop="dateModified" datetime="2020-11-30T17:28:32+08:00">2020-11-30</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/一致性算法/" itemprop="url" rel="index"><span itemprop="name">一致性算法</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">23k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">21 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>在分布式系统中，一个核心的问题就是解决数据一致性的问题，即共识问题（多副本共识问题）：</p>
<blockquote>
<p>Consensus Problem : Requires agreement among a number of processes (or agents) for a single data value.</p>
</blockquote>
<p>共识问题简单来说，就是多个进程（代理）就某个单值达成一致，主要的应用场景数据多副本的复制。而 Paxos 及 Raft 算法的提出便是为了解决共识问题，它们在工程实现上得到了广泛的应用，如 Goggle 的 Chubby、Apache 的 ZooKeeper 及 Raft算法实现 Etcd。这些算法都可以统称为一致性算法。</p>
<p><img src="/images/consensus-algorithm/paxos-evolution.jpg" alt="paxos-evolution" title="paxos-evolution"></p>
<p>一致性算法大概可以分为4个类型：</p>
<ol>
<li>Basic-Paxos : 提供就一个提案达成一致的算法，是最基本的算法，在工程实践中很少使用该算法；</li>
<li>Multi-Paxos : 在 Basic-Paxos 算法的基础上，提供了就一批提案达成一致的算法，在工程中有很多类似的实现；</li>
<li>Raft : 针对 Multi-Paxos 算法难于理解及实现复杂，提供了一种简化的实现；</li>
<li>Multi-Raft : 为了提供更大的并发请求量，可以将单个 Raft 集群进行分区，提供更大的集群规模。</li>
</ol>
<p>这篇文章就四种类型的算法进行一个概要的分析，更多的是逻辑概念层面，不会对细节及实现过多讨论，那也超出本人的认知。</p>
<h2 id="2-Paxos"><a href="#2-Paxos" class="headerlink" title="2. Paxos"></a>2. Paxos</h2><p>Paxos 算法解决的问题是一个分布式系统如何就某个值（提案）达成一致。一个典型的场景是，在一个分布式数据库系统中，如果各节点的初始状态一致，每个节点都执行相同的操作序列，那么他们最后能得到一个一致的状态。为保证每个节点执行相同的命令序列，需要在每一条指令上执行一个“一致性算法”以保证每个节点看到的指令一致，是分布式计算中的重要问题。</p>
<h3 id="2-1-Basic-Paxos"><a href="#2-1-Basic-Paxos" class="headerlink" title="2.1 Basic-Paxos"></a>2.1 Basic-Paxos</h3><p>在 Paxos 算法中，节点分为三种角色：</p>
<ol>
<li>Proposers：提案（value）发起者，接收客户端请求；</li>
<li>Acceptors：接收提案（value）进行决策，存储 accept 的提案（value）；</li>
<li>Learners：不参与决策，从 Proposers 和 Acceptors 学习最新达成一致的提案（value）。<br>由于 Learners 不参与决策，暂不讨论。</li>
</ol>
<p>Paxos 算法分为两个阶段，为什么使用两个阶段，可以参考这篇文章：<a href="https://mp.weixin.qq.com/s?__biz=MjM5MDg2NjIyMA==&amp;mid=203607654&amp;idx=1&amp;sn=bfe71374fbca7ec5adf31bd3500ab95a&amp;key=8ea74966bf01cfb6684dc066454e04bb5194d780db67f87b55480b52800238c2dfae323218ee8645f0c094e607ea7e6f&amp;ascene=1&amp;uin=MjA1MDk3Njk1&amp;devicetype=webwx&amp;version=70000001&amp;pass_ticket=2ivcW%2FcENyzkz%2FGjIaPDdMzzf%2Bberd36%2FR3FYecikmo%3D" target="_blank" rel="noopener">一步一步理解Paxos算法</a></p>
<p><strong>Paxos 协议分为两个阶段：</strong></p>
<ol>
<li>第一阶段 Prepare：<ul>
<li>Proposer 生成全局唯一且递增的提案 ID （ProposalId），向 Paxos 集群的所有机器发送 PrepareRequest，这里无需携带提案内容，只携带 ProposalId 即可。Acceptor 收到  PrepareRequest 后，做出“两个承诺，一个应答”。</li>
<li>两个承诺主要是指：<ul>
<li>不再应答 ProposalId 小于等于（注意：这里是 &lt;= ）当前请求的 PrepareRequest；</li>
<li>不再应答 ProposalId 小于（注意：这里是 &lt; ）当前请求的 AcceptRequest。</li>
</ul>
</li>
<li>一个应答主要是指：<br>返回自己已经 Accept 过的提案中 ProposalID 最大的那个提案的内容，如果没有则返回空值;</li>
</ul>
</li>
</ol>
<ol start="2">
<li><p>第二阶段 Accept：</p>
<ul>
<li><p>P2a：Proposer 发送 Accept<br>“提案生成规则”：Proposer 收集到多数派应答的 PrepareResponse 后，从中选择 ProposalId 最大的提案内容，作为要发起 Accept 的提案，如果这个提案为空值，则可以自己随意决定提案内容。然后携带上当前 ProposalId，向 Paxos 集群的所有机器发送 AccpetRequest。</p>
</li>
<li><p>P2b：Acceptor 应答 Accept<br>Accpetor 收到 AccpetRequest 后，检查不违背自己之前作出的“两个承诺”情况下，持久化当前 ProposalId 和提案内容。最后 Proposer 收集到多数派应答的 AcceptResponse 后，形成决议。</p>
</li>
</ul>
</li>
</ol>
<p>在执行上面两个步骤之后，实际上后续还有一个步骤。在实际应用中，如使用 Paxos 算法的 KV 系统，上述两个步骤只是完成了日志在不同系统的提交，对于一个写操作，还需要将写操作提交到背后的存储结构中，这个操作往往是异步操作。</p>
<p>在 Paxos 两个阶段中隐含了两个规则：</p>
<ol>
<li>喜新厌旧：在第一阶段中，更大的 ProposalId 会抢占比它小的提案，前提是还没有 ProposalId 被 Accept；</li>
<li>后者认同前者：在第二阶段中，如果提案还没有被 Accept，则提交自己新的 Proposal，如果已经提案已经被 Accept，则使用旧的提案内容进行提交。</li>
</ol>
<p>在第一个规则中，要保证新的 ProposalId 比之前的 ProposalId 大，包含两层意思，1） 同一个 Proposer 生成的 ProposalId 是自增的；2）不同 Proposer 生成的 ProposalId 要要求是自增。正常会使用如下的方案：<br>假设有 n 个proposer，每个编号为ir (0 &lt;= ir &lt; n)，Proposor 编号的任何值 s 都应该大于它已知的最大值，并且满足：s %n = ir =&gt; s = m*n + ir。</p>
<p>Basic-Paxos 算法如下图所示：<br><img src="/images/consensus-algorithm/paxos-algorithem.jpg" alt="paxos-algorithem" title="paxos-algorithem"></p>
<p>在算法中，必须持久化存储 minProposal, acceptedProposal,和 acceptedValue 三个变量。</p>
<p>Basic-Paxos 实例 1：<br><img src="/images/consensus-algorithm/paxos-example-1.jpg" alt="paxos-example-1" title="paxos-example-1"><br>说明：<br>Proposal ID：round number(3), server id(1)，即 Proposal ID = 3.1 ，其中 3 代表轮数，1 代表 节点编号。<br>P 3.1达成多数派，其 Value(X) 被 Accept，然后P 4.5学习到 Value(X)，并Accept。</p>
<p>实例 2：<br><img src="/images/consensus-algorithm/paxos-example-2.jpg" alt="paxos-example-2" title="paxos-example-2"><br>P 3.1没有被多数派Accept（只有S3 Accept），但是被P 4.5学习到，P 4.5 将自己的Value 由 Y 替换为 X，Accept（X）</p>
<p>实例 3：<br><img src="/images/consensus-algorithm/paxos-example-3.jpg" alt="paxos-example-3" title="paxos-example-3"><br>P 3.1 没有被多数派Accept（只有S1 Accept），同时也没有被 P 4.5学习到。由于P 4.5 Propose的所有应答，均未返回 Value，则 P 4.5 可以Accept 自己的Value（Y）。<br>后续 P 3.1的Accept（X）会失败，已经 Accept 的 S1，会被覆盖。</p>
<p>Basic-Paxos 存在一个活锁的问题，如下图所示：<br><img src="/images/consensus-algorithm/liveness-lock.jpg" alt="liveness-lock" title="liveness-lock"><br>两个Proposers交替Propose成功，Accept失败，形成活锁（Livelock）</p>
<h2 id="3-Multi-Paxos"><a href="#3-Multi-Paxos" class="headerlink" title="3. Multi-Paxos"></a>3. Multi-Paxos</h2><p>如果想确定一个确定，一个值，Basic-Paxos 就可以实现了。如果想确定连续多个提案，确定连续多个值，Basic-Paxos 算法就搞不定了，就要使用 Multi-Paxos。如下图所示：<br><img src="/images/consensus-algorithm/multi-paxos.jpg" alt="multi-paxos" title="multi-paxos"></p>
<p>Multi-Paxos 就是对每一个 Paxos Instance 执行一次 Paxos 算法，确保每一台节点上的数据都是一致的。</p>
<p>Multi-Paxos 有如下一些缺点：</p>
<ol>
<li>比较复杂，难以理解，工程实现难度比较大；</li>
<li>每一个服务器都可以执行写操作，性能较差。</li>
</ol>
<p>为了解决 Multi-Paxos 的缺点，在算法中引入了 Leader 的角色，所有的决议都通过 Leader 来进行，然后同步到其它节点，其结构如下图所示：<br><img src="/images/consensus-algorithm/multi-paxos-2.jpg" alt="multi-paxos-2" title="multi-paxos-2"></p>
<p>通过 Consensus Module， 完成多个连续的提案的确定，通过日志同步到各个节点，保证节点以相同的顺序执行，使得节点的状态保持一致。其中，Raft 算法便是 Multi-Paxos 算法的一个实现版本。</p>
<h2 id="4-Raft"><a href="#4-Raft" class="headerlink" title="4. Raft"></a>4. Raft</h2><p>Raft 通过选举一个 Leader，然后让它负责日志的复制来实现一致性。Leader 从客户端接收日志条目，把日志条目复制到其它节点上，并且当保证安全性的时候告诉其它节点应用日志条目到他们的状态机中。拥有一个 Leader 大大简化了对复制日志的管理。例如，Leader 可以决定新的日志条目需要放在日志中的什么位置而不需要和其他节点商议，并且数据只从 Leader 流向其他节点。一个 Leader 可以宕机，可以和其他节点失去连接，这时一个新的 Leader 会被选举出来。</p>
<p>通过 Leader 的方式，Raft 将一致性问题分解成了三个相对独立的子问题：</p>
<ol>
<li>Leader 选举：当现存的 Leader 宕机的时候，一个新的 Leader 需要被选举出来；</li>
<li>日志复制：Leader 必须从客户端接收日志然后复制到集群中的其他节点，并且强制要求其它节点的日志保持和自己相同；</li>
<li>安全性：如果有任何的节点节点已经应用了一个确定的日志条目到它的状态机中，那么其它节点节点不能在同一个日志索引位置应用一个不同的指令。</li>
</ol>
<h3 id="4-1-基本概念"><a href="#4-1-基本概念" class="headerlink" title="4.1 基本概念"></a>4.1 基本概念</h3><p><strong>Server状态：</strong></p>
<p>在任何时刻，每一个节点节点都处于这三个状态之一：Leader 、Follower 或者 Candidate。在通常情况下，系统中只有一个 Leader 并且其它的节点全部都是 Follower。Follower 都是被动的：它们不会发送任何请求，只是简单的响应来自 Leader 或者 Candidate 的请求。Leader 处理所有的客户端请求（如果一个客户端和 Leader 联系，那么 Follower 会把请求重定向给 Leader）。第三种状态，Candiate，是用来在选举新 Leader 时使用。下图展示了这些状态和它们之间的转换关系。</p>
<p><img src="/images/consensus-algorithm/raft_server_state.png" alt="raft_server_state" title="raft_server_state"></p>
<ul>
<li>Leader : 处理客户端的请求以及日志复制；</li>
<li>Follower : 接收来自 Leader 或者 Canditate 的 Message，并响应；</li>
<li>Candidate : 用于选主的中间状态。</li>
</ul>
<p><strong>Term：</strong><br>Raft 把时间分割成任意长度的任期，如下图所示，任期用连续的整数标记。每一段任期从一次选举开始，一个或者多个 Candidate 尝试成为 Leader。如果一个 Candidate 赢得选举，然后它就在接下来的任期内充当 Leader 的职责。在某些情况下，一次选举过程会造成选票的瓜分。在这种情况下，这一任期会以没有 Leader 结束；一个新的任期（和一次新的选举）会很快重新开始。Raft 保证了在一个给定的任期内，最多只有一个 Leader。<br><img src="/images/consensus-algorithm/raft-term.png" alt="raft_term" title="raft_term"></p>
<p><strong>Message类型：</strong><br>Raft 算法中服务器节点之间通信使用远程过程调用（RPCs），并且基本的一致性算法只需要两种类型的 RPCs。请求投票（RequestVote） RPCs ，由 Candidate 在选举期间发起，然后追加条目（AppendEntries）RPCs 由Leader 发起，用来复制日志和提供一种心跳机制。安装快照 (InstallSnapshot）在新服务器启动时或者 Follower 落后太多日志时使用。</p>
<h3 id="4-2-Leader-选择"><a href="#4-2-Leader-选择" class="headerlink" title="4.2 Leader 选择"></a>4.2 Leader 选择</h3><p>Raft 使用心跳机制来触发 Leader 选举。当服务器程序启动时，他们都是 Follower 身份。只要从 Leader 或者 Candidate 处接收到有效的 AppendEntries RPC， 一个服务器节点继续保持着 Folllowr 状态。Leader 周期性的向所有 Follower 发送心跳包（即不包含日志项内容的追加日志项 RPCs）来维持自己的权威。如果一个 Follower 在一段时间里没有接收到任何消息，也就是选举超时，那么他就会认为系统中没有可用的 Leader,并且发起选举以选出新的 Leader。<br>要开始一次选举过程，Follower 先要增加自己的当前任期号并且转换到 Candidate 状态。然后它会并行的向集群中的其他服务器节点发送请求投票的 RPCs 来给自己投票。如果一个 Candidate 从整个集群的大多数服务器节点获得了针对同一个任期号的选票，那么它就赢得了这次选举并成为 Leader。每一个服务器最多会对一个任期号投出一张选票，按照先来先服务的原则，并且确保 Candidate 的日志比服务器更新。要求大多数选票的规则确保了最多只会有一个 Candidate 赢得此次选举，要求 Candidate 的日志最新，确保日志只从 Leader 流向 Follower。一旦候选人赢得选举，它就立即成为领导人。然后他它会向其他的服务器发送心跳消息来建立自己的权威并且阻止新的 Leader 的产生。</p>
<p><img src="/images/consensus-algorithm/raft-election.jpg" alt="raft-election" title="raft-election"></p>
<p>一个 Candidate 获得集群中多数服务器的选票，并不代表真正获得了 Leader，因为它只完成了类似 Basic-Paxos的 Prepare阶段，此时它还需要向集群中的服务器发送 AppendEntries RPC，阻止其它服务器发起选主请求，其它服务器收到该 RPC 之后，将自己的状态转化为 Follower。<br>在Basic-Paxos 中存在活锁的问题，在 Raft 选主中也同样存在，即多个 Candidate 同时对同一个 Term 发起选主请求，选票会被多个 Candidate 瓜分，为了避免这个问题，Raft 为每一个 Candidate 选择一个随机选主超时时间，可以有效避免这种情况，即使发生这种情况，因为没有一个 Candidate 获得多数选票，等待超时时间之后，将触发下一轮的选主，而下一轮的触发的时间也是随机的。<br>在选主的操作中，只有那些包含更新更多日志的 Candiate 才有机会获得选票，这主要是通过比较 LastLogIndex 和 LastLogTerm 来实现的。通过这种方式，Raft 简化了后续日志复制的过程，保证了日志只会由 Leader 流向 Follower。</p>
<p>通过以上的方式，保证了选主的安全性：<strong style="color:red">对于一个给定的任期号，最多只会有一个领导人被选举出来。</strong></p>
<h3 id="4-3-日志复制"><a href="#4-3-日志复制" class="headerlink" title="4.3 日志复制"></a>4.3 日志复制</h3><p>一旦一个 Leader 被选举出来，它就开始为客户端提供服务。客户端的每一个请求都包含一条被状态机执行的指令。Leader 把这条指令作为一条新的日志条目附加到日志中去，然后并行的发起追加条目 RPCs 给其他的服务器，让它们复制这条日志条目。当这条日志条目被安全的复制并回复 ACK 给Leader ，Leader 会应用这条日志条目到它的状态机中然后把执行的结果返回给客户端。如果少数派的 Follower 崩溃或者运行缓慢，再或者网络丢包，Leader 人会不断的重复尝试追加日志条目 RPCs （尽管已经回复了客户端）直到所有的 Follower 都最终存储了所有的日志条目。<br><img src="/images/consensus-algorithm/raft-log.png" alt="raft-log" title="raft-log"></p>
<p>每一个 Log Entry 由有序序号标记的条目组成。每个条目都包含创建时的任期号，和一个状态机需要执行的指令。当一个条目复制到多数派的服务器上时就被认为已提交 (Committed) 状态了。<br><img src="/images/consensus-algorithm/raft-log-format.jpg" alt="raft-log-format" title="raft-log-format"></p>
<p>当日志被多数派服务器持久化之后就成为 Committed 状态，应用到状态机之后变为 Applied，正常情况下，一旦日志成为 Committed 状态之后，就不允许撤消。一个未被多数派持久化的日志有可能被撤消。<br><img src="/images/consensus-algorithm/raft-log-state.jpg" alt="raft-log-state" title="raft-log-state"></p>
<p>Leader 决定什么时候将日志应用给状态机是安全的，Raft 保证 Committed Entries 持久化，并且最终被其它状态机应用。一个 Log Entry 一旦复制给了大多数节点就成为 Committed。同时还有一种情况，如果当前待提交 Entry 之前有未提交的 Entry，即使是以前过时的 Leader 创建的，只要满足已存储在大多数节点上就一次性按顺序都提交。Leader 要追踪最新的 Committed 的 index，并在每次AppendEntries RPCs（包括心跳）都要带给其它服务器，以使其它服务器知道一个 Log Entry是已提交的，从而在它们本地的状态机上也应用。<br><img src="/images/consensus-algorithm/raft-log-flow.jpg" alt="raft-log-flow" title="raft-log-flow"><br>从上图可以知道，日志的 Commited 状态由 Leader 来决定，并在下一次的 AppendEntries RPC 中由 leaderCommit 字段传递给 Follower。正常情况下，在返回客户端之前，日志会应用到 Leader 的状态机中，而 Follower 什么时候将日志应用到状态机，是一个异步操作，会滞后于 Leader。所以 Leader 状态机中持有最新的数据。</p>
<p><strong>日志修复</strong><br>一个日志只要多数派持久化成功，就会认为是 Committed 的。由于各种原因，总有 Follower 落后于 Leader。Leader 为每个 Follower 维护一个 nextId，标示下一个要发送的 logIndex。Follower 接收到 AppendEntries（传递 prevTermID，prevLogIndex 参数），之后会进行一致性检查，检查 AppendEntries 中指定的 LastLogIndex 是否一致，如果不一致就会向 Leader 返回失败。Leader 接收到失败之后，会将 nextId 减1，重新进行发送，直到成功。这个回溯的过程实际上就是寻找 Follower 上最后一个 CommittedId，然后 Leader 发送其后的 LogEntry。<br><img src="/images/consensus-algorithm/raft_log_recovery.png" alt="raft_log_recovery" title="raft_log_recovery"></p>
<p>重新选主后，新的 Leader 没有之前内存中维护的 nextId，以本地 lastLogIndex + 1 作为每个节点的 nextId。这样根据节点的 AppendEntries应答可以调整 nextId：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nextIndex</span></span><br><span class="line">local.nextIndex = max(min(local.nextIndex-<span class="number">1</span>, resp.LastLogIndex+<span class="number">1</span>), <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="4-4-日志压缩"><a href="#4-4-日志压缩" class="headerlink" title="4.4 日志压缩"></a>4.4 日志压缩</h3><p>Raft 的日志在正常操作中不断的增长，但是在实际的系统中，日志不能无限制的增长。随着日志不断增长，它会占用越来越多的空间，花费越来越多的时间来重置。如果没有一定的机制去清除日志里积累的陈旧的信息，那么会带来可用性问题。</p>
<p>快照是最简单的压缩方法。在快照系统中，整个系统的状态都以快照的形式写入到稳定的持久化存储中，然后到那个时间点之前的日志全部丢弃。在 Chubby 和 ZooKeeper 中同样使用快照技术。<br><img src="/images/consensus-algorithm/raft-log-conpress.png" alt="raft-log-conpress" title="raft-log-conpress"><br>上图展示了 Raft 中快照的基础思想。每个服务器独立的创建快照，只包括已经被提交的日志。主要的工作包括将状态机的状态写入到快照中。Raft 也包含一些少量的元数据到快照中：<strong style="color:red">最后被包含索引（lastIncludedIndex）</strong>指的是被快照取代的最后的条目在日志中的索引值（状态机最后应用的日志），<strong style="color:red">最后被包含的任期（lastIncludedTerm）</strong>指的是该条目的任期号。保留这些数据是为了支持快照后紧接着的第一个条目的追加日志请求时的一致性检查，因为这个条目需要前一日志条目的索引值和任期号。为了支持集群成员更新，快照中也将最后的一次配置作为最后一个条目存下来。一旦服务器完成一次快照，他就可以删除最后索引位置之前的所有日志和快照了。<br>做快照的时机选择，对系统也是有影响的。如果过于频繁的快照，那么将会浪费大量的磁盘带宽；如果过于不频繁的快照，那么 Log 将会占用大量的磁盘空间，启动速度也很慢。一个简单的方式就是当 Log 达到一定大小之后再进行快照，或者是达到一定时间之后再进行快照。<br>快照会花费比较长的时间，如果期望快照不影响正常的 Log Entry同步，可以采用 Copy-On-Write 的技术来实现。例如，选择底层的数据结构支持 COW (Copy-On-Write)、LSM-Tree 类型的存储结构，或者是使用系统的 COW 支持，Linux的fork，或者是 ZFS 的 Snapshot 等。</p>
<h3 id="4-5-集群成员变化"><a href="#4-5-集群成员变化" class="headerlink" title="4.5  集群成员变化"></a>4.5  集群成员变化</h3><p>集群成员变化主要是指集群节点数量的增删，在实际场景中，集群的扩容（副本数的增加）或者节点当机下线都是常见的事情。在不停机的情况下，由于节点不能一次性原子地变更节点的成员配置信息，会导致同一时间，同一个任期出现两个领导者，违背了算法安全性原则，如下图所示：<br><img src="/images/consensus-algorithm/raft-membership.png" alt="raft-membership" title="raft-membership"><br>3 个节点的集群扩展到 5 个节点的集群，直接扩展可能会造成 Server1 和Server2 构成老的多数集合，Server3、Server4 和 Server5 构成新的多数集合，产生两个领导者。</p>
<p><strong>Joint-Consensus</strong><br>Raft 算法采用协同一致性的方式来解决节点的变更，先提交一个包含新老节点结合的 Configuration 命令，当这条消息 Commit 之后再提交一条只包含新节点的 Configuration 命令。新老集合中任何一个节点都可以成为 Leader，这样 Leader 当机之后，如果新的 Leader 没有看到包括新老节点集合的 Configuration 日志，继续以老节点集合组建集群；如果新的 Leader 看到了包括新老节点集合的 Configuration 日志，将未完成的节点变更流程走完。具体流程如下：</p>
<ol>
<li>加入新对节点，从 Leader 中追加数据；</li>
<li>全部新节点完成数据同步之后，向新老集合发送 Cold+new 命令；</li>
<li>如果新节点集合多数和老节点集合多数都应答了 Cold+new，就向新老节点集合发送 Cnew 命令；</li>
<li>如果新老节点集合多数应答了 Cnew，完成节点切换。</li>
</ol>
<p>在这里，我们可以把 Cold+new 理解为包含新老结点地址集合，如果当前集群包括 server1, server2 及 server3, 新加的结点为 server4, server5,那么 Cold+new 等同于集合 [server1, server2, server3, server4, server5], Cold 为 [server1, server2, server3], Cnew 为 [server4, server5]。</p>
<p><img src="/images/consensus-algorithm/raft-member-transmit.png" alt="raft-member-transmit" title="raft-member-transmit"><br>虚线表示已经被创建但是还没有被提交的配置日志条目，实线表示最后被提交的配置日志条目。领导人首先创建了 Cold+new 的配置条目在自己的日志中，并提交到 Cold+new 中（Cold 的大多数和 Cnew 的大多数）。然后它创建 Cnew 条目并提交到 Cnew 中的大多数。这样就不存在 Cnew 和 Cold 可以同时做出决定的时间点。<br>如果 Cold+new 被 Commit 到新老集合多数的话，即使过程终止，新的 Leader 依然能够看到 Cold+new，并继续完成 Cnew 的流程，最终完成节点变更；如果 Cold+new 没有提交到新老集合多数的话，新的Leader可能看到了 Cold+new 也可能没有看到，如果看到了依然可以完成 Cnew 的流程，如果没有看到，说明 Cold+new 在两个集合都没有拿到多数应答，重新按照 Cold 进行集群操作，两阶段过程中选主需要新老两个集合都达到多数同意。</p>
<p>节点配置变更过程中需要满足如下规则：</p>
<ul>
<li>新老集合中的任何节点都可能成为 Leader；</li>
<li>任何决议都需要新老集合的多数通过。</li>
</ul>
<p>在这里有一个关键的点就是：<strong style="color:red">任何决议都需要新老集合的多数通过。</strong>如果不能形成两个多数集合，算法是否就可以简化？单节点变更就是基于这个想法产生的。</p>
<p><strong>Single-Server Change</strong><br>单节点变更是对 Joint-Consensus 的简化， 它每次只增删一个节点，这样就不会出现两个多数集合，不会造成决议冲突的情况，如果需要变更多个节点，那需要执行多次单节点变更。比如将 3 节点集群扩容为 5 节点集群，这时你需要执行 2 次单节点变更，先将 3 节点集群变更为 4 节点集群，然后再将 4 节点集群变更为 5 节点集群，如下图所示：<br><img src="/images/consensus-algorithm/raft-node-new.jpg" alt="raft-node-new" title="raft-node-new"><br>还是以三结点 Raft 集群为例，演示下变更为五结点的过程，假定节点 A 为 Leader。<br><img src="/images/consensus-algorithm/raft-node-evolution-1.jpg" alt="raft-node-evolution-1" title="raft-node-evolution-1"><br>目前的集群配置为[A, B, C]，先向集群中加入节点 D，这意味着新配置为[A, B, C, D]。成员变更，是通过两步实现的：</p>
<ol>
<li>Leader（节点 A）向新节点（节点 D）同步数据；</li>
<li>Leader（节点 A）将新配置 [A, B, C, D] 作为一个日志项，复制到新配置中所有节点（节点 A、B、C、D）上，然后将新配置的日志项应用（Apply）到本地状态机，完成单节点变更。<br><img src="/images/consensus-algorithm/raft-node-evolution-2.jpg" alt="raft-node-evolution-2" title="raft-node-evolution-2"></li>
</ol>
<p>变更完成后，集群的配置变为 [A, B, C, D],接着向集群加入结点 E，即新配置为[A, B, C, D, E]，流程类似:</p>
<ol>
<li>Leader（节点 A）向新节点（节点 E）同步数据；</li>
<li>Leader（节点 A）将新配置 [A, B, C, D, E] 作为一个日志项，复制到新配置中所有节点（节点 A、B、C、D、E）上，然后将新配置的日志项应用（Apply）到本地状态机，完成单节点变更。<br><img src="/images/consensus-algorithm/raft-node-evolution-3.jpg" alt="raft-node-evolution-3" title="raft-node-evolution-3"></li>
</ol>
<p>通过连续执行两次单结点变更，完成了集群结点的扩容。</p>
<p>一次性加入一个结点，重点在于新老配置的结点不会形成两个多数派，新老配置要形成多数派总会有重叠的结点，重叠的结点不会给同一任期的两个结点投两次票，这是由 Raft 算法的安全性保证的。</p>
<p><img src="/images/consensus-algorithm/raft-node-evolution.jpg" alt="raft-node-evolution" title="raft-node-evolution"></p>
<p>不管节点数是偶数还是奇数，增加或减少一个结点都不能形成新老配置的两个多数派，两个集合总会有重叠，从而确保了算法的安全性。</p>
<p>另外，在分区错误、节点故障等情况下，有可能并发执行单节点变更，那么就可能出现一次单节点变更尚未完成，新的单节点变更又在执行，导致集群出现 2 个 Leader 的情况。解决的办法是，可以在 Leader 启时 （选主成功之后）时，创建一个 NO_OP 日志项（也就是空日志项），只有当 Leader将 NO_OP 日志项应用后，再执行成员变更请求。</p>
<h3 id="4-6-线性一致读"><a href="#4-6-线性一致读" class="headerlink" title="4.6 线性一致读"></a>4.6 线性一致读</h3><p>什么是线性一致读? 所谓线性一致读，一个简单的例子是在 t1 的时刻写入了一个值，那么在 t1 之后，一定能读到这个值，不可能读到 t1 之前的旧值(类似 Java 中的 volatile 关键字，即线性一致读就是在分布式系统中实现 Java volatile 语义)。简而言之是需要在分布式环境中实现 Java volatile 语义效果，即当 Client 向集群发起写操作的请求并且获得成功响应之后，该写操作的结果要对所有后来的读请求可见。和 volatile 的区别在于 volatile 是实现线程之间的可见，而线性一致读需要实现 Server 之间的可见。<br><img src="/images/consensus-algorithm/raft-linearizability-read.png" alt="raft-linearizability-read" title="raft-linearizability-read"><br>如上图 Client A、B、C、D 均符合线性一致读，其中 D 看起来是 Stale Read，其实并不是，D 请求横跨 3 个阶段，而 Read 可能发生在任意时刻，所以读到 1 或 2 都行。</p>
<p><strong>Raft Log read</strong><br>实现线性一致读最常规的办法是走 Raft 协议，将读请求同样按照 Log 处理，通过 Log 复制和状态机执行来获取读结果，然后再把读取的结果返回给客户端。因为 Raft 本来就是一个为了实现分布式环境下线性一致性的算法，所以通过 Raft 非常方便的实现线性 Read，也就是将任何的读请求走一次 Raft Log，等此 Log 提交之后在 apply 的时候从状态机里面读取值，一定能够保证这个读取到的值是满足线性要求的。</p>
<p>因为每次 Read 都需要走 Raft 流程，Raft Log 存储、复制带来刷盘开销、存储开销、网络开销，走 Raft Log 不仅仅有日志落盘的开销，还有日志复制的网络开销，另外还有一堆的 Raft “读日志” 造成的磁盘占用开销，导致 Read 操作性能是非常低效的，所以在读操作很多的场景下对性能影响很大，在读比重很大的系统中是无法被接受的，通常都不会使用。</p>
<p>个人理解：<strong style="color:red">Raft Log read 关键点在于提交一次读操作并应用到状态机后，将之前处于 Commited　状态的 log 都应用到状态机，确保状态机的状态是最新的。</strong></p>
<p>在 Raft 算法中，执行一次写操作，由客户端向 Leader 发起，首先 Leader 将本次操作写入本地日志，然后向所有的 Follower 同步日志，Follower 收到日志之后写入本地，并回复给 Leader ； Leader 收到半数以上的回复之后将本次操作应用到本地的状态机，并返回客户端写入成功，最后 Leader 在下次同步日志时再将本次日志 Commited 的信息传递给 Follower , Follower再异步更新本地状机。可见，一次写入操作之后，Leader 状态机拥有最新的状态，而 Follower 状态机的状态有可能落后于 Leader。如果直接从 Follower 读到数据，会读到 Stale 数据。如果从 Leader 读取数据的话，则可以保证线性读取最新的数据。现在关键的问题是：<strong style="color:red">如何确认 Leader 在处理这次 Read 的时候一定是 Leader ? </strong>，在这里，有两种方法：</p>
<ol>
<li>ReadIndex Read;</li>
<li>Lease Read.</li>
</ol>
<p><strong>ReadIndex Read</strong><br>ReadIndex Read 有两个关键点：</p>
<ol>
<li>Leader 向 Follower 发送心跳确认自己仍然是 Leader，避免 Leader 已经过期而不自知；</li>
<li>维护一个 ReadIndex , 初始值等于 Leader 的 CommitIndex , 并将 ReadIndex 指向的所有 Log 都应用到状态机中，确保所有的写操作都已经应用。</li>
</ol>
<p>ReadIndex Read 可以从 Leader 和 Followr 读取，过程如下描述。</p>
<p>从 Leader 读取：</p>
<ol>
<li>Leader 将自己当前 Log 的 commitIndex 记录到一个 Local 变量 ReadIndex 里面；</li>
<li>接着向 Followers 节点发起一轮 Heartbeat，如果半数以上节点返回对应的 Heartbeat Response，那么 Leader就能够确定现在自己仍然是 Leader；</li>
<li>Leader 等待自己的 StateMachine 状态机执行，至少应用到 ReadIndex 记录的 Log，直到 applyIndex 超过 ReadIndex，这样就能够安全提供 Linearizable Read，也不必管读的时刻是否 Leader 已飘走；</li>
<li>Leader 执行 Read 请求，将结果返回给 Client。</li>
</ol>
<p>从 Follower 读取：</p>
<ol>
<li>Follower 节点向 Leader 请求最新的 ReadIndex；</li>
<li>Leader 仍然走一遍之前的流程，执行上面前 3 步的过程(确定自己真的是 Leader)，并且返回 ReadIndex 给 Follower；</li>
<li>Follower 等待当前的状态机的 applyIndex 超过 ReadIndex；</li>
<li>Follower 执行 Read 请求，将结果返回给 Client</li>
</ol>
<p><strong>Lease Read</strong><br>在 ReadIndex Read 中执行一次读操作，Leader 都要向 Follower 发送心跳确认当前自己仍然是 Leader，还是存在网络开销，是否可以优化？ Leader 的选主是通过选择超时时间进行的，在这里引入任期的概念，在下一次选主前，都可以认为当前 Leader 的角色都是不会改变的，在这期间的读操作，可以节省心跳的操作。<br>Raft 论文里面提及一种通过 Clock + Heartbeat 的 Lease Read 优化方法，也就是 Leader 发送 Heartbeat 的时候首先记录一个时间点 Start，当系统大部分节点都回复 Heartbeat Response，由于 Raft 的选举机制，Follower 会在 Election Timeout 的时间之后才重新发生选举，下一个 Leader 选举出来的时间保证大于 Start + Election Timeout/Clock Drift Bound，所以可以认为 Leader 的 Lease 有效期可以到 Start + Election Timeout/Clock Drift Bound 时间点。</p>
<p>Lease Read 基本思路是 Leader 取一个比 Election Timeout 小的租期（最好小一个数量级），在租约期内不会发生选举，确保 Leader 不会变化，所以跳过 ReadIndex 的第二步也就降低延时。由此可见 Lease Read 的正确性和时间是挂钩的，依赖本地时钟的准确性，因此虽然采用 Lease Read 做法非常高效，但是仍然面临风险问题，也就是存在预设的前提即各个服务器的 CPU Clock 的时间是准的，即使有误差，也会在一个非常小的 Bound 范围里面，时间的实现至关重要，如果时钟漂移严重，各个服务器之间 Clock 走的频率不一样，这套 Lease 机制可能出问题。</p>
<p>Lease Read 实现方式包括：</p>
<ol>
<li>定时 Heartbeat 获得多数派响应，确认 Leader 的有效性；</li>
<li>在租约有效时间内，可以认为当前 Leader 是唯一有效 Leader，可忽略 ReadIndex 中的 Heartbeat 确认步骤；</li>
<li>Leader 等待自己的状态机执行，直到 applyIndex 超过 ReadIndex，这样就能够安全的提供 Linearizable Read</li>
</ol>
<h3 id="4-7-安全性"><a href="#4-7-安全性" class="headerlink" title="4.7 安全性"></a>4.7 安全性</h3><p>使用 Raft 算法，需要保证如下的安全性：</p>
<ol>
<li>选举安全特性：对于一个给定的任期号，最多只会有一个领导人被选举出来；</li>
<li>领导人只附加原则：领导人绝对不会删除或者覆盖自己的日志，只会增加；</li>
<li>日志匹配原则：如果两个日志在相同的索引位置的日志条目的任期号相同，那么我们就认为这个日志从头到这个索引位置之间全部完全相同；</li>
<li>领导人完全特性：如果某个日志条目在某个任期号中已经被提交，那么这个条目必然出现在更大任期号的所有领导人中；</li>
<li>状态机安全特性：如果一个领导人已经将给定的索引值位置的日志条目应用到状态机中，那么其他任何的服务器在这个索引位置不会应用一个不同的日志。</li>
</ol>
<h2 id="5-Multi-Raft"><a href="#5-Multi-Raft" class="headerlink" title="5. Multi-Raft"></a>5. Multi-Raft</h2><p>因为 Raft 集群内只有 Leader 提供读写服务，所以读写也会形成单点的瓶颈。因此为了支持水平扩展，可以按某种 Key 进行分片部署，比如用户 ID，让 Group 1 对 [0, 10000) 的 ID 提供服务，让 Group 2 对 [10000, 20000) 的 ID 提供服务，以此类推。如下是 SOFAJRaft 的实现：</p>
<p><img src="/images/consensus-algorithm/multi-raft.png" alt="multi-raft" title="multi-raft"></p>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>这篇文章对主要的一致性算法进行了一个概念上描述，并没有深入到具体实现细节。在工程实践境中，已经有几个 Raft 的实现用于生产环境中，如 GO 语言版本的 Etcd、C++ 语言的 braft 及 Java 语言的 SOFAJRaft 。后面有时间，专门研究分析下 SOFAJRaft 源码，提升对共识算法的理解。</p>
<p><strong>参考：</strong></p>
<hr>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&amp;mid=403582309&amp;idx=1&amp;sn=80c006f4e84a8af35dc8e9654f018ace&amp;scene=1&amp;srcid=0119gtt2MOru0Jz4DHA3Rzqy&amp;key=710a5d99946419d927f6d5cd845dc9a72ff3d652a8e66f0ddf87d91262fd262f61f63660690d2d5da76a44a29e155610&amp;ascene=0&amp;uin=MjA1MDk3Njk1&amp;devicetype=iMac+MacBookPro11%2C4+OSX+OSX+10.11.1+build(15B42)&amp;version=11020201&amp;pass_ticket=bhstP11nRHvorVXvQ4pt9fzB9Vdzj5sSRBe84783gsg%3D" target="_blank" rel="noopener">1. 架构师需要了解的Paxos原理、历程及实战</a><br><a href="https://mp.weixin.qq.com/s?__biz=MjM5MDg2NjIyMA==&amp;mid=203607654&amp;idx=1&amp;sn=bfe71374fbca7ec5adf31bd3500ab95a&amp;key=8ea74966bf01cfb6684dc066454e04bb5194d780db67f87b55480b52800238c2dfae323218ee8645f0c094e607ea7e6f&amp;ascene=1&amp;uin=MjA1MDk3Njk1&amp;devicetype=webwx&amp;version=70000001&amp;pass_ticket=2ivcW%2FcENyzkz%2FGjIaPDdMzzf%2Bberd36%2FR3FYecikmo%3D" target="_blank" rel="noopener">2. 一步一步理解Paxos算法</a><br><a href="https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md" target="_blank" rel="noopener">3. 寻找一种易于理解的一致性算法（扩展版）</a><br><a href="https://www.sofastack.tech/blog/sofa-jraft-election-mechanism/" target="_blank" rel="noopener">4. SOFAJRaft 选举机制剖析 | SOFAJRaft 实现原理</a><br><a href="https://github.com/baidu/braft/blob/master/docs/cn/raft_protocol.md" target="_blank" rel="noopener">5. RAFT介绍</a><br><a href="https://www.sofastack.tech/blog/sofa-jraft-linear-consistent-read-implementation/" target="_blank" rel="noopener">6. SOFAJRaft 线性一致读实现剖析 | SOFAJRaft 实现原理</a><br><a href="https://www.sofastack.tech/blog/sofa-jraft-deep-dive/" target="_blank" rel="noopener">7. 蚂蚁金服开源 SOFAJRaft 详解| 生产级高性能 Java 实现</a><br><a href="https://github.com/hedengcheng/tech/blob/master/distributed/PaxosRaft%20%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E5%8F%8A%E5%85%B6%E5%9C%A8%E5%AE%9E%E6%88%98%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8.pdf" target="_blank" rel="noopener">8. PaxosRaft 分布式一致性算法原理剖析及其在实战中的应用.pdf</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/10/08/select-and-epoll/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/10/08/select-and-epoll/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">Select 和 Epoll实现</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-10-08 18:17:33" itemprop="dateCreated datePublished" datetime="2020-10-08T18:17:33+08:00">2020-10-08</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-11-09 19:56:02" itemprop="dateModified" datetime="2020-11-09T19:56:02+08:00">2020-11-09</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/网络协议/" itemprop="url" rel="index"><span itemprop="name">网络协议</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">41k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">37 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇文章主要讲述 select 和 epoll 的实现原理，包括底层的数据结构、与设备的回调处理机制及两种实现之间的差异。</p>
<h2 id="1-知识储备"><a href="#1-知识储备" class="headerlink" title="1. 知识储备"></a>1. 知识储备</h2><p>在介绍 select 和 epoll 的实现原理前，先介绍两个知识点，分别是 1）文件的 poll 函数；2）linux 的wakeup callback机制。select 和 epoll 很大程度上就是基于这两点构建的。</p>
<h3 id="1-1-poll-函数"><a href="#1-1-poll-函数" class="headerlink" title="1.1 poll 函数"></a>1.1 poll 函数</h3><p>在 linux 中，设备的操作抽象为文件的操作，对网络设备的操作同样也是文件操作。为了实现非阻塞的数据读取，文件提供了 poll 操作，该操作为上层应用提供了探测设备文件是否有数据可读的接口，同时结合文件的等待队列，上层应用可以对感兴趣的事件添加处理函数，这个处理函数通常是向等待队列中添加一个等待结点，这个等待结点会关联一个 callback 函数，当相关事件满足时触发 callback 函数，最后 poll 函数返回当前设备文件的状态，上层应用根据返回状态决定是否阻塞该线程，poll 函数不阻塞线程。通过这种方式，设备文件提供了基于事件处理的回调机制，select/poll/epoll 就是基于这种方式来实现的。 </p>
<p><img src="/images/tcp/poll.jpg" alt="poll" title="poll"></p>
<p>poll 函数分为三个步骤：</p>
<ol>
<li>获取事件对应的等待队列；</li>
<li>初始化一个等待结点，设置 callback 函数，并将等待结点加入到等待队列中，此时并不阻塞调用线程；</li>
<li>获取设备当前的状态并返回。</li>
</ol>
<p>在 poll 函数中，上层应用可以根据业务的不同可以自定义 poll_queue_proc 和 唤醒 callback 函数，从而实现不同的功能，select/poll/epoll 分别实现了这两个函数，它们之间的差异从这两个函数中也可以看出。下面是一个 poll 函数实例。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">scull_p_poll</span><span class="params">(struct file *filp, poll_table *wait)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Scull_Pipe *dev = filp-&gt;private_data;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* The buffer is circular; it is considered full</span></span><br><span class="line"><span class="comment">	* if "wp" is right behind "rp". "left" is 0 if the</span></span><br><span class="line"><span class="comment">	* buffer is empty, and it is "1" if it is completely full.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="comment">// 处理私有业务</span></span><br><span class="line">	<span class="keyword">int</span> left = (dev-&gt;rp + dev-&gt;buffersize - dev-&gt;wp) % dev-&gt;buffersize;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 在不同的等待队列上调用 poll_wait 函数</span></span><br><span class="line">	poll_wait(filp, &amp;dev-&gt;inq, wait);</span><br><span class="line">	poll_wait(filp, &amp;dev-&gt;outq, wait);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* readable */</span></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;rp != dev-&gt;wp) mask |= POLLIN | POLLRDNORM;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* writable */</span></span><br><span class="line">	<span class="keyword">if</span> (left != <span class="number">1</span>) mask |= POLLOUT | POLLWRNORM;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>poll 函数的定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 文件操作  </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供给 poll/select/epoll 使用，获取文件当前状态, 以及就绪通知接口函数</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*poll)</span> <span class="params">(struct file *, struct poll_table_struct *)</span></span>; </span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向文件注册事件及处理函数  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_struct</span> &#123;</span></span><br><span class="line">    <span class="comment">// 处理函数</span></span><br><span class="line">    poll_queue_proc _qproc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事件</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>  _key;  </span><br><span class="line">&#125; poll_table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// poll_queue_proc 函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*poll_queue_proc)</span><span class="params">(struct file *, <span class="keyword">wait_queue_head_t</span> *, struct poll_table_struct *)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="1-2-wakeup-callback机制"><a href="#1-2-wakeup-callback机制" class="headerlink" title="1.2 wakeup callback机制"></a>1.2 wakeup callback机制</h3><p>在上节的 poll 函数中，会检查文件的状态（可读/可写/可连接），同时在事件的等待队列添加一个等待结点，待续结点中注册一个 callback 回调函数，事件触发时，再调用 callback 回调函数，唤醒结点中的 task 来处理事件。这种机制正时使用了 linux 内核 wakeup callback机制。<br>Linux 内核通过睡眠队列来组织所有等待某个事件的 task，而 wakeup 机制则可以异步唤醒整个睡眠队列上的 task，每一个睡眠队列上的节点都拥有一个 callback，wakeup 逻辑在唤醒睡眠队列时，会遍历该队列链表上的每一个节点，调用每一个节点的 callback，如果遍历过程中遇到某个节点是排他节点，则终止遍历，不再继续遍历后面的节点。总体上的逻辑可以用下面的伪代码表示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">define sleep_list;</span><br><span class="line">define wait_entry;</span><br><span class="line">wait_entry.task = current_task;</span><br><span class="line">wait_entry.callback = func1;</span><br><span class="line"><span class="keyword">if</span> (something_not_ready); then</span><br><span class="line">    <span class="comment"># 将任务加入等待队列</span></span><br><span class="line">    add_entry_to_list(wait_entry, sleep_list);</span><br><span class="line">go_on:</span><br><span class="line">    <span class="comment"># 根据情况进行睡眠或唤醒</span></span><br><span class="line">    schedule();</span><br><span class="line">    <span class="keyword">if</span> (something_not_ready); then</span><br><span class="line">        goto go_on;</span><br><span class="line">    endif</span><br><span class="line">    del_entry_from_list(wait_entry, sleep_list);</span><br><span class="line">endif</span><br></pre></td></tr></table></figure></p>
<p>唤醒的流程：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">something_ready;</span><br><span class="line">for_each(sleep_list) <span class="keyword">as</span> wait_entry; do</span><br><span class="line">    wait_entry.callback(...);</span><br><span class="line">    <span class="keyword">if</span>(wait_entry.exclusion); then</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    endif</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<p>callback 函数包含于唤醒的主要逻辑，伪代码如下所示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">common_callback_func(...)</span><br><span class="line">&#123;</span><br><span class="line">    do_something_private;</span><br><span class="line">    wakeup_common;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 poll/select/epoll 中都会定义各自的 callback 函数，该函数一般包括两部分：1）私有逻辑；2）唤醒 task。callback 函数由驱动来调用（在 NIC 中由软件中断调用）。</p>
<h3 id="1-3-I-O-多路复用"><a href="#1-3-I-O-多路复用" class="headerlink" title="1.3 I/O 多路复用"></a>1.3 I/O 多路复用</h3><p>I/O 多路复用是一种优化技术，它是为了避免一个线程处理一个 I/O 设备文件，转而由一个线程来监听多个 I/O 文件，来提供系统的效率。poll/select/epoll 底层使用了这种 I/O 模式。<br><img src="/images/tcp/io-multiplexing.jpg" alt="io-multiplexing" title="io-multiplexing"></p>
<h2 id="2-select"><a href="#2-select" class="headerlink" title="2. select"></a>2. select</h2><h3 id="2-1-整体流程"><a href="#2-1-整体流程" class="headerlink" title="2.1 整体流程"></a>2.1 整体流程</h3><p>select 方法调用：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FD_SETSIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFDBITS (8 * sizeof(unsigned long))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __FDSET_LONGS (FD_SETSIZE/NFDBITS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据结构 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> fds_bits[__FDSET_LONGS];</span><br><span class="line">&#125; fd_set;</span><br><span class="line"></span><br><span class="line"><span class="comment">// select 文件调用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> max_fd,  <span class="comment">/* 最大文件数 */</span></span></span></span><br><span class="line"><span class="function"><span class="params">    fd_set *readset, <span class="comment">/* 读事件文件集合 */</span></span></span></span><br><span class="line"><span class="function"><span class="params">    fd_set *writeset, <span class="comment">/* 写事件文件集合 */</span></span></span></span><br><span class="line"><span class="function"><span class="params">    fd_set *exceptset, </span></span></span><br><span class="line"><span class="function"><span class="params">    struct timeval *timeout</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>; <span class="comment">// 返回值就绪描述符的数目</span></span><br></pre></td></tr></table></figure></p>
<p>从 select 方法定义来看，每次调用都需要将文件集合在用户空间及内核空间进行复制，并且文件最大的数量限制在 1024 个。组合上面的内容，可以知道 select 会定义两个函数 poll_queue_proc 和 唤醒 callback 函数，注册到 poll 函数中，在这里，这两个函数分别对应：__pollwait() 和 pollwake。其整体的流程如下所示：</p>
<p><img src="/images/tcp/select.jpg" alt="select" title="select"></p>
<p>select 调用主要做了三件事情：</p>
<ol>
<li>初始化poll_wqueues结构，包括几个关键函数指针的初始化，用于驱动中进行回调处理；</li>
<li>循环遍历监测的文件描述符，并且调用 f_op-&gt;poll() 函数，如果有监测条件满足，则会跳出循环；</li>
<li>在监测的文件描述符都不满足条件时，会让当前进程进行睡眠，超时唤醒，或者被所属的等待队列唤醒。</li>
</ol>
<p>select 函数的循环退出条件有三个：</p>
<ol>
<li>检测的文件描述符满足条件；</li>
<li>超时；</li>
<li>由等待事件触发。</li>
</ol>
<h3 id="2-2-数据结构"><a href="#2-2-数据结构" class="headerlink" title="2.2 数据结构"></a>2.2 数据结构</h3><p>接下来再看下 select 内部的数据结构：<br><img src="/images/tcp/select_data_struct.jpg" alt="select_data_struct" title="select_data_struct"><br>在 select 方法中，会维护一个 struct poll_wqueues 结构，其中两个关键字段：</p>
<ol>
<li>poll_table：该结构体中的函数指针_qproc指向__pollwait函数；</li>
<li>struct poll_table_entry[]：存放不同文件的 poll_table_entry，这些条目的增加是在驱动调用 __pollwait() 时进行初始化并完成添加的，每一个文件都会添加一个条目。</li>
</ol>
<p>在这个数据结构可以看出，调用 poll 函数之后，会在所有文件的等待队列中加入一个结点，这个结点会持有当前 task 的信息，当事件触发之后，从而可以知道唤醒那一个进程；</p>
<p>从上面的分析可以看出，select 有以下的缺点：</p>
<ol>
<li>每次 select 方法调用都会传入文件集合参数，涉及到用户空间及内核空间的两次复制；</li>
<li>每一次调用都需要遍历所有的文件调用 poll 函数，效率较低（在用户空间中，也需要遍历所有文件查看那些文件有事件触发）；</li>
<li>监听的文件数量有限，最大 1024 个。</li>
</ol>
<h2 id="3-epoll"><a href="#3-epoll" class="headerlink" title="3. epoll"></a>3. epoll</h2><h3 id="3-1-整体流程"><a href="#3-1-整体流程" class="headerlink" title="3.1 整体流程"></a>3.1 整体流程</h3><p>epoll 解决了 select 的缺点，在大并发场景下，epoll 得到了广泛的应用，它从以下几个方面解决了 select 的缺点：</p>
<ol>
<li>生成一个 epoll 文件，将监听的文件描述符加入到这个文件的数据结构（红黑树）中，只用添加一次，避免了数据的来回复制；</li>
<li>epoll 文件中维护了一个可读文件队列，每次只遍历该队列，避免所有文件的遍历；</li>
<li>监听的文件不受限制。</li>
</ol>
<p>下面我们来看下 epoll的实现原理，首先看下调用方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成一个 ep 文件，把所有需要监听的文件都放到 ep 文件中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// epoll_ctl 添加一个监听的文件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">int</span> epfd,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">int</span> op, </span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">int</span> fd, </span></span></span><br><span class="line"><span class="function"><span class="params">	struct epoll_event *event</span></span></span><br><span class="line"><span class="function"><span class="params">	)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// epoll_wait 负责检测可读队列，没有可读的文件则阻塞进程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">int</span> epfd, </span></span></span><br><span class="line"><span class="function"><span class="params">	struct epoll_event * events, </span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">int</span> maxevents, </span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">int</span> timeout</span></span></span><br><span class="line"><span class="function"><span class="params">	)</span></span>;</span><br></pre></td></tr></table></figure>
<p>epoll_create 生成一个 ep 文件，通过 epoll_ctl 方法添加/删除文件，epoll_wait 方法只遍历满足条件的可读队列，提高了效率。这三个方法大概的逻辑如下描述。<br><strong>epoll_ctl 主要逻辑：</strong></p>
<ol>
<li>定义一个 epitem 结构，代表一个监听的文件，并加入到红黑树中；</li>
<li>生成一个等待结点，加入到这文件 （socket 文件）的等待队列中；</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">define epitem</span><br><span class="line">add_epitem_to_rbtree(epitem) </span><br><span class="line"></span><br><span class="line">define wait_entry</span><br><span class="line">wait_entry.socket = this_socket;</span><br><span class="line">wait_entry.callback = epoll_wakecallback;</span><br><span class="line">add_entry_to_list(wait_entry, this_socket.sleep_list);</span><br></pre></td></tr></table></figure>
<p><strong>epoll_wait 主要逻辑：</strong></p>
<ol>
<li>定义一个等待结点，将结点的 task （实际为 private 字段，为了简要描述，定义为 task） 设置为当前 task （调用 epoll_wait的进程），并设置回调函数；</li>
<li>判断当前可读队列是否为空，如果为空则将等待结点加入到 ep 文件的等待队列上，并阻塞该进程；</li>
<li>如果当前可读队列不为空，则遍历准备好的可读队列，返回数据给用户进程；</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">define single_wait_list</span><br><span class="line">define single_wait_entry</span><br><span class="line">single_wait_entry.callback = wakeup_common;</span><br><span class="line">single_wait_entry.task = current_task;</span><br><span class="line"><span class="keyword">if</span> (ready_list_is_empty); then</span><br><span class="line">    <span class="comment"># 等待结点加入到 ep 文件的等待队列中</span></span><br><span class="line">    add_entry_to_list(single_wait_entry, single_wait_list);</span><br><span class="line">go_on:  </span><br><span class="line">    <span class="comment"># 阻塞进程</span></span><br><span class="line">    schedule();</span><br><span class="line">    <span class="keyword">if</span> (sready_list_is_empty); then</span><br><span class="line">        goto go_on;</span><br><span class="line">    endif</span><br><span class="line">    del_entry_from_list(single_wait_entry, single_wait_list);</span><br><span class="line">endif</span><br><span class="line"><span class="comment"># 遍历准备好的可读队列</span></span><br><span class="line">for_each_ready_list <span class="keyword">as</span> sk; do</span><br><span class="line">    event.evt = sk.poll(...);</span><br><span class="line">    event.sk = sk;</span><br><span class="line">    put_event_to_user;</span><br><span class="line">done;</span><br></pre></td></tr></table></figure>
<p>在这里需要注意的是，当前进程不像 select 方法，进程是阻塞在监听文件（socket 文件）的等待队列上，而是阻塞在 ep 文件自己的阻塞队列上，如上面的流程所述。这里有问题，如何唤醒阻塞的进程？答案在注册到监听文件的回调函数上，在 epoll_ctl 中，我们同样在监听文件的等待队列上加入了一个等待结点，当文件可读时，调用该回调函数，借助该函数，再唤醒阻塞在 ep 文件等待队列上的进程，其流程如下所述：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">epoll_wakecallback(...)</span><br><span class="line">&#123;</span><br><span class="line">    add_this_socket_to_ready_list;</span><br><span class="line">    wakeup_single_epoll_waitlist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在唤醒进程之前，会将该文件加入到可读队列中。</p>
<p>epoll_wait 流程如下图所示：<br><img src="/images/tcp/epoll.jpg" alt="epoll" title="epoll"></p>
<h3 id="3-2-数据结构"><a href="#3-2-数据结构" class="headerlink" title="3.2 数据结构"></a>3.2 数据结构</h3><p>数据结构如下所示：<br><img src="/images/tcp/epoll_data_struct.jpg" alt="epoll_data_struct" title="epoll_data_struct"><br>关键点说明：</p>
<ol>
<li>进程阻塞在 epoll 文件的等待队列上，不是监听文件的等待队列上；</li>
<li>epoll 会将满足条件的文件提前放在可读文件队列 rdllist 中，减少文件遍历的数量；</li>
<li>epoll 将监听的文件使用红黑树管理，可有效地进行文件的添加及删除；</li>
<li>唤醒操作由监听文件等待队列中的回调函数触发，然后再唤醒阻塞在 epoll 文件上的进程。</li>
</ol>
<p>对应的数据结构定义为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 每创建一个epoll 文件, 内核就会分配一个eventpoll与之对应 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Protect the this structure access */</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> lock;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This mutex is used to ensure that files are not removed</span></span><br><span class="line"><span class="comment">     * while epoll is using them. This is held during the event</span></span><br><span class="line"><span class="comment">     * collection loop, the file cleanup path, the epoll file exit</span></span><br><span class="line"><span class="comment">     * code and the ctl operations.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mtx</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wait queue used by sys_epoll_wait() */</span></span><br><span class="line">    <span class="comment">/* epoll 文件等待队列，进程就是阻塞在该队列上 */</span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> wq;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wait queue used by file-&gt;poll() */</span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> poll_wait;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* List of ready file descriptors */</span></span><br><span class="line">    <span class="comment">/* 所有已经准备好的可读文件队列 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdllist</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* RB tree root used to store monitored fd structs */</span></span><br><span class="line">    <span class="comment">/* 红黑树，存储所有监听的文件 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">rbr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This is a single linked list that chains all the "struct epitem" that</span></span><br><span class="line"><span class="comment">     * happened while transfering ready events to userspace w/out</span></span><br><span class="line"><span class="comment">     * holding -&gt;lock.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">ovflist</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The user that created the eventpoll descriptor */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Each file descriptor added to the eventpoll interface will</span></span><br><span class="line"><span class="comment"> * have an entry of this type linked to the "rbr" RB tree.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* epitem 表示一个被监听的文件 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> &#123;</span></span><br><span class="line">    <span class="comment">/* RB tree node used to link this structure to the eventpoll RB tree */</span></span><br><span class="line">    <span class="comment">/* 代表在红黑树中的结点 */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="comment">/* RB tree node links this structure to the eventpoll RB tree */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rbn</span>;</span></span><br><span class="line">		<span class="comment">/* Used to free the struct epitem */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* List header used to link this structure to the eventpoll ready list */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdllink</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Works together "struct eventpoll"-&gt;ovflist in keeping the</span></span><br><span class="line"><span class="comment">     * single linked chain of items.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The file descriptor information this item refers to */</span></span><br><span class="line">    <span class="comment">/* epitem对应的文件和 struct file */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_filefd</span> <span class="title">ffd</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Number of active wait queue attached to poll operations */</span></span><br><span class="line">    <span class="keyword">int</span> nwait;</span><br><span class="line">    <span class="comment">/* List containing poll wait queues */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">pwqlist</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The "container" of this item */</span></span><br><span class="line">    <span class="comment">/* 关联的eventpoll结构 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* List header used to link this item to the "struct file" items list */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">fllink</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The structure that describe the interested events and the source fd */</span></span><br><span class="line">    <span class="comment">/* 当前文件关心的事件 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 红黑树结点 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>  __rb_parent_color;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rb_right</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rb_left</span>;</span></span><br><span class="line">&#125; __attribute__((aligned(<span class="keyword">sizeof</span>(<span class="keyword">long</span>))));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 红黑树根结点 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rb_node</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_filefd</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Wait structure used by the poll hooks */</span></span><br><span class="line"><span class="comment">/* 用于构造回调函数的数据结构，在 ep_ptable_queue_proc 中使用 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eppoll_entry</span> &#123;</span></span><br><span class="line">    <span class="comment">/* List header used to link this structure to the "struct epitem" */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">llink</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The "base" pointer is set to the container "struct epitem" */</span></span><br><span class="line">    <span class="comment">/* 关联的 epitem */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">base</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Wait queue item that will be linked to the target file wait</span></span><br><span class="line"><span class="comment">     * queue head.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* 添加到监听文件等待队列中的等待结点 */</span></span><br><span class="line">    <span class="keyword">wait_queue_t</span> wait;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The wait queue head that linked the "wait" wait queue item */</span></span><br><span class="line">    <span class="comment">/* 监听文件等待队列队首结点 */</span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> *whead;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Wrapper struct used by poll queueing */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ep_pqueue</span> &#123;</span></span><br><span class="line">    poll_table pt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Used by the ep_send_events() function as callback private data */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ep_send_events_data</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> maxevents;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> __<span class="title">user</span> *<span class="title">events</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>通过对 select 及 epoll 方法的分析，可以知道，epoll 从各个方面进行了优化，相对 select, 在大部分场景下，性能有了质的飞跃，这也是网络中间件中大部分选用 epoll 的原因。</p>
<p><strong>参考：</strong></p>
<hr>
<p><a href="https://coderbee.net/index.php/linux/20190919/1942" target="_blank" rel="noopener">1. Linux select/poll/epoll 原理（一）实现基础</a><br><a href="https://blog.csdn.net/eZiMu/article/details/54896708" target="_blank" rel="noopener">2. inux驱动—file_operations之poll</a><br><a href="https://mp.weixin.qq.com/s/bjM3uEDg61vhNN8Y661L7w" target="_blank" rel="noopener">3. Linux select/poll机制原理分析</a><br><a href="https://blog.csdn.net/dog250/article/details/50528373" target="_blank" rel="noopener">4. Linux内核中网络数据包的接收-第二部分 select/poll/epoll</a><br><a href="https://my.oschina.net/alchemystar/blog/3008840" target="_blank" rel="noopener">5. 从linux源码看epoll</a><br><a href="https://blog.csdn.net/russell_tao/article/details/17119729" target="_blank" rel="noopener">6. 高性能网络编程5–IO复用与并发编程</a><br><a href="https://blog.nowcoder.net/n/dade4d8c53d144dfa78157887e2cb33e" target="_blank" rel="noopener">7. epoll源码分析</a><br><a href="https://zhuanlan.zhihu.com/p/60713292" target="_blank" rel="noopener">8. 带您进入内核开发的大门 | 内核中的等待队列</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/20/illustrated-TCP-protocol/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/09/20/illustrated-TCP-protocol/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">图解TCP协议</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-09-20 16:58:48" itemprop="dateCreated datePublished" datetime="2020-09-20T16:58:48+08:00">2020-09-20</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-11-09 19:48:48" itemprop="dateModified" datetime="2020-11-09T19:48:48+08:00">2020-11-09</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/网络协议/" itemprop="url" rel="index"><span itemprop="name">网络协议</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">17k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">15 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇文章讲述网络报文从网卡 NIC （network interface controller）接收，再到操作系统网络协议栈处理，最后到用户程序接收报文处理报文的简化过程，希望能对TCP协议进行一个整体、概括性的总结。</p>
<h2 id="1-网络子系统"><a href="#1-网络子系统" class="headerlink" title="1. 网络子系统"></a>1. 网络子系统</h2><p>从网络中发送过来的网络报文首先到达网卡 NIC，使用 DMA 技术将报文拷贝到内存中，再发起中断请求 CPU 进行中断处理，CPU 调用驱动中的方法处理网络报文，处理完毕之后传给网络协议栈处理，如流程如下图所示：</p>
<p><img src="/images/tcp/data-received.jpg" alt="data-received" title="data-received"></p>
<ol>
<li>网卡 NIC 从外部网络收到报文；</li>
<li>网卡 NIC 通过 DMA 技术直接将报文拷贝到 RAM 中，以 SKB(Socket Buffer)结构存储。NIC 一般都会在 RAM 中申请一个环形的接收队列，代表了接收的能力（同时也会发送环形队列，用于报文的发送）；</li>
<li>网卡 NIC 向 CPU 触发一次硬件中断，通知有报文需要处理，如果只有一个 CPU，没有其它选择；如果是多 CPU 的情况，会涉及到 CPU 的选择，后面我们会进行讲述；</li>
<li>CPU 处理中断，调用 NIC 驱动注册到内核中的的中断处理函数，在这里我们以 NAPI 为例（NAPI 合并 IRQ(Interrupt ReQuest),减少中断次数）；</li>
<li>中断处理函数会关闭中断，后续报文直接由拷贝到内存中，避免后续报文重复触发中断；</li>
<li>触发软中断，进行报文处理，中断处理包含两个阶段：1）硬件中断，响应 NIC 中断信号，触发软件中断；2）软件中断，由专门的内核线程来执行，网络报文的处理是由软件中断来执行。</li>
</ol>
<p>上面的流程是简要的一个流程，有些知识链条是断裂的，下面将补充三个知识点：1）软件中断；2） NIC 与环形队列的关系；3） CPU 的选择问题。</p>
<h3 id="1-1-软件中断"><a href="#1-1-软件中断" class="headerlink" title="1.1 软件中断"></a>1.1 软件中断</h3><p>在设备驱动中，一般通过中断的方式告诉 CPU 数据已经准备好，可以来取数据了。在内核中，中断处理函数优先级非常高，同时会阻塞其它中断处理。所以要求硬件中断处理函数必须尽可能快、效率尽可能高。为了减少中断处理时间，引入了软件中断，将复杂的处理延迟到软件中断中处理，如网络报文的处理，而在硬件中断中触发软件中断。</p>
<p>系统在启动时，会为每一个 CPU 分配一个内核线程 ksoftirqd 线程，专门处理软件中断，目前能够处理的软件中断有6个，其中网络处理的有两个，分别是接收中断 NET_RX_SOFTIRQ 和 发送中断 NET_TX_SOFTIRQ。这两个中断在net_dev_init方法中注册到内核。初始化的流程如下所示：<br><img src="/images/tcp/softirq.jpg" alt="softirq" title="softirq"></p>
<ol>
<li>系统启动时，创建 ksoftirad 内核线程，处理软件中断，每一个 CPU 对应一个线程；</li>
<li>ksoftirqd 内部是一个事件处理处理函数 run_ksoftirqd，不断接收中断处理事件；</li>
<li>驱动为每一个 CPU 生成 poll_list 链表，主要是存放触发中断事件的 NIC设备；</li>
<li>注册软件中断处理函数 net_rx_action, 中断号为 NET_RX_SOFTIRQ(同时也会注册NET_TX_SOFTIRQ)，负责报文接收工作；</li>
<li>收到报文时，驱动为将触发中断的 NIC 加入到 CPU 的 poll_list中；</li>
<li>驱动设置 softirq_pending 中的 NET_RX_SOFTIRQ 标志位，表明需要处理 NET_RX_SOFTIRQ 中断；</li>
<li>run_ksoftirqd 检查到 softirq_pending 标志位，如果有设置标志位，执行 __do_softirq 函数；</li>
<li>__do_softirq 查找到 NET_RX_SOFTIRQ 对应的中断处理函数 net_rx_action，并执行该函数，处理报文的接收。</li>
</ol>
<h3 id="1-2-RSS"><a href="#1-2-RSS" class="headerlink" title="1.2 RSS"></a>1.2 RSS</h3><p>在多核的系统中，为了充分利用多核处理的优势，提高网络处理的吞吐量，NIC 引入了 RSS(Receive Side Scaling) 或 multiqueue 的技术。这种技术将 NIC 接收队列抽象为多个队列，每一个队列分配一个唯一的中断号，再将队列与某个 CPU 建立映射关系。输入的报文根据 NIC中的 hash 函数（根据Src ip, Src port, Dest ip, Dest port, Protocol）负载到指定的接收队列中，再根据对应的中断号触发硬件中断，后续的报文者将由指定的 CPU 来处理，整体的流程如下图所示：<br><img src="/images/tcp/RSS.jpg" alt="RSS" title="RSS"></p>
<ol>
<li>NIC 接收到外部报文；</li>
<li>使用 DMA 技术将报文拷贝到 SKB 双向链表中；</li>
<li>使用 hash 函数，将该报文负载到指定的队列中，将触发中断，每一个接收队列都对应一个环形队列，有大小的限制，超过容量之后，报文会丢弃；</li>
<li>在硬件中断中处理软件中断，与上面的内容一致。</li>
</ol>
<p>如果支持 RSS 的话，NIC 为每个队列分配一个 IRQ，通过 /proc/interrupts 进行查看，如下所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/interrupts</span><br><span class="line">           CPU0       CPU1       CPU2       CPU3</span><br><span class="line"> 56:   20209820    4671909   34469139    1896297   PCI-MSI-edge      ens160-rxtx-0</span><br><span class="line"> 57:    3259205    5165620    2125138    4534929   PCI-MSI-edge      ens160-rxtx-1</span><br><span class="line"> 58:    5883233   10958192    2339523   22326712   PCI-MSI-edge      ens160-rxtx-2</span><br><span class="line"> 59:    4307729    2329793    9003652   25191926   PCI-MSI-edge      ens160-rxtx-3</span><br></pre></td></tr></table></figure></p>
<p>可以看到，中断号 56~59 分别分配给了 4 个队列，通过 /proc/irq/IRQ_NUMBER/smp_affinity 设置某个中断由某个 CPU 触发，我们可以查看中断号 56 的配置情况。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/irq/56/smp_affinity</span><br><span class="line">4</span><br></pre></td></tr></table></figure></p>
<p>0 号 CPU 的掩码是 0x1 (0001)，1 号 CPU 掩码是 0x2 (0010)，2 号 CPU 掩码是 0x4 (0100)，3 号 CPU 掩码是 0x8 (1000) 依此类推。4 表示使用 CPU 2，另外可以查看或配置环形队列的长度。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ ethtool -g ens160</span><br><span class="line">Ring parameters <span class="keyword">for</span> ens160:</span><br><span class="line">Pre-set maximums:</span><br><span class="line">RX:             4096</span><br><span class="line">RX Mini:        0</span><br><span class="line">RX Jumbo:       4096</span><br><span class="line">TX:             4096</span><br><span class="line">Current hardware settings:</span><br><span class="line">RX:             256</span><br><span class="line">RX Mini:        0</span><br><span class="line">RX Jumbo:       128</span><br><span class="line">TX:             512</span><br></pre></td></tr></table></figure></p>
<p>在 NIC 中引入 RSS 技术，有效地提高了网络处理的吞吐量。如果硬件不支持 RSS 技术，内核提供了 RPS(Receive Packet Steering) 技术，通过软件的技术来实现多核处理网络报文。PRS 技术的原理是：硬件中断只由一个 CPU 处理，然后根据报文计算 hash 值并负载到特定的 CPU 上，通过 Inter-processor Interrupt(IPI) 通知特定的 CPU 来进行软件中断处理。 Receive Flow Steering(RFS) 一般和 RPS 配合一起工作。RPS 是将收到的报文分配到不同的 CPU 以实现负载均衡，保证同一个 Flow 的数据包都由一个 CPU 处理，类似会话绑定的技术。</p>
<p><img src="/images/tcp/RPS.jpg" alt="RPS" title="RPS"></p>
<p>可以通过 /proc/sys/net/core/netdev_max_backlog 查看 netdev_max_backlog 的默认值。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/sys/net/core/netdev_max_backlog</span><br><span class="line">1000</span><br></pre></td></tr></table></figure></p>
<h3 id="1-3-报文处理"><a href="#1-3-报文处理" class="headerlink" title="1.3 报文处理"></a>1.3 报文处理</h3><p>上面的内容讲述了硬件中断的相关内容，接下来进入软件中断的处理流程，其流程（以NAPI为例）如下所示：<br><img src="/images/tcp/net-rx-action.jpg" alt="net-rx-action" title="net-rx-action"><br>net_rx_action 函数处理当前 CPU 中设备列表中的设备( NAPI poll structure)，这些设备主要来自两个地方：1）驱动中调用 napi_schedule 方法加入；2）使用 Inter-processor Interrupt 方法加入（RPS），具体流程如下：</p>
<ol>
<li>遍历当前 CPU 的设备列表 poll_list，处理所有的 NAPI 设备；</li>
<li>检查 budget 及软件中断的运行时间，避免处理函数占用过多的 CPU 时间，控制 budget 可以影响执行的时间，它可以通过 net.core.netdev_budget 参数进行配置；</li>
<li>调用驱动中注册的 poll函数，在 igb 驱动中调用的是 igb_poll 函数；</li>
<li>poll 函数读取环形队列中的 packet ；</li>
<li>如果设备支持 GRO，则需要调用 napi_gro_receive 函数，Generic Receive Offloading(GRO) 是 Large receive offload 的一个实现，LRO 就是在收到多个数据包的时候将同一个 Flow 的多个数据包按照一定的规则合并起来交给上层处理，这样就能减少上层需要处理的数据包数量；</li>
<li>报文传给 net_receive_skb，进行下一步处理。</li>
</ol>
<p>在 netif_receive_skb 方法中，会根据是否开启 RPS 来进行不同处理，如果开启了 RPS，会使用 IRI (Inter-processor Interrupt )技术，将报文转给远程 CPU 进行处理，实现类似硬件 RSS 的技术；如果未开启，除了将报文分发给 taps(PCAP), 实现抓包功能，同时将报文传给 IP 协议层，由 IP 协议进行下一步处理，其流程如下所示：<br><img src="/images/tcp/netif-receive-skb.jpg" alt="netif-receive-skb" title="netif-receive-skb"><br>开启 RPS 功能：</p>
<ol>
<li>将报文传给 enqueue_to_backlog 方法；</li>
<li>报文加入到远程 CPU 的输入队列中；</li>
<li>将 NIC 加入到远程 CPU 的设备列表中，使用 IRI, 触发过程 CPU 的软件中断；</li>
<li>远程 CPU 读取输入队列中的报文；</li>
<li>将报文传给 __net_receive_skb_core 方法；</li>
<li>将报文分发给 taps(PCAP), 实现抓包功能；</li>
<li>将报文传给 IP 协议层，进行下一步处理。</li>
</ol>
<p>未开启 RPS 功能：</p>
<ol>
<li>将报文传给 __net_receive_skb_core 方法；</li>
<li>将报文分发给 taps(PCAP), 实现抓包功能；</li>
<li>将报文传给 IP 协议层，进行下一步处理。</li>
</ol>
<h2 id="2-IP-协议层"><a href="#2-IP-协议层" class="headerlink" title="2. IP 协议层"></a>2. IP 协议层</h2><p>IP 协议层主要是实现路由功能，结合 netfilter 定义的钩子函数，可以通过 iptables 配置 ip 路由功能，流程如下所示：<br><img src="/images/tcp/ip-rcv.jpg" alt="ip-rcv" title="ip-rcv"><br>在这里有三个 netfilter 钩子函数：</p>
<ol>
<li>NF_INET_PRE_ROUTING：可以在路由前对数据包进行修改或丢弃；</li>
<li>NF_INET_FORWARD：实现转发功能；</li>
<li>NF_INET_LOCAL_IN：本地 IP 的入口，触发相应的配置。</li>
</ol>
<h2 id="3-TCP-协议层"><a href="#3-TCP-协议层" class="headerlink" title="3. TCP 协议层"></a>3. TCP 协议层</h2><p>报文到了 TCP 协议层，会根据 socket 锁被占用的状态，将报文发送到不同的接收队列，在这里有 4 个队列，分别是：receive queue, out_of_order queue, prequeue queue, backlog queue。通过接收队列，内核软件中断线程与 socket 线程实现了数据的交换。<br><img src="/images/tcp/tcp-v4-rcv.jpg" alt="tcp-v4-rcv" title="tcp-v4-rcv"></p>
<p>4 个队列使用场景：</p>
<ol>
<li>receive queue ：当 socket 没有被线程占用的时候，报文会加入到该队列；</li>
<li>out_of_order queue ：临时存放乱序的报文；</li>
<li>prequeue queue ：当 socket 被占用且 tcp_low_latency 值为 0 时，报文加入该队列；</li>
<li>backlog queue ：当 socket 正在被读取时，新收到的所有报文加入到该队列（如果报文是乱序的，后续还要加入到out_of_order queue）。</li>
</ol>
<p>如果 tcp_low_latency 值为 1 时，报文不加入到 prequeue queue，内核软件中断线程直接将数据复制到用户态。</p>
<blockquote>
<p>接收缓存<br>对收消息过程来说，Socket 占用内存量就是 Receive Queue、Prequeue、Backlog、Out of order 队列内排队的 sk_buff(SKB) 占用内存总数。在内核中可以使用两个参数进行配置：net.core.rmem_max 和 net.core.rmem_default。</p>
</blockquote>
<p>最后数据拷贝到用户态之后，表示用户线程已经接到了数据，至此接收流程结束。</p>
<h2 id="4-报文发送"><a href="#4-报文发送" class="headerlink" title="4. 报文发送"></a>4. 报文发送</h2><p>报文接收流程已经讲述完毕，接下来我们再看下报文的接收流程。</p>
<h3 id="4-1-TCP-协议层"><a href="#4-1-TCP-协议层" class="headerlink" title="4.1 TCP 协议层"></a>4.1 TCP 协议层</h3><p>报文发送流程从 TCP 协议层开始，其主要流程如下所示：<br><img src="/images/tcp/tcp-sendmsg.jpg" alt="tcp-sendmsg" title="tcp-sendmsg"></p>
<ol>
<li>用户线程调用 send 方法发送用户态的数据；</li>
<li>sk_stream_wait_memory：判断发送队列是否有足够的空间发送数据，如果没有则等待一定时间，等待已经发送数据的 ACK 确认信息，如果收到则释放 SKB 数据，腾出空间以便后续数据的发送。TCP 连接分配的发送缓存是有限的，可以通过（ /proc/sys/net/core/wmem_default ）进行配置；</li>
<li>tcp_sendmsg ：将用户态的数据按照 MSS ( Maximum Segment Size ) 进行分片，并封装到 SKB 结构中。为了避免数据链路层进行分片，TCP 层传输的数据应小于该层的最大传输单元（MTU）,以太网 MTU 为 1500 字节，扣除 TCP, IP 头的 40 个字节，MSS 最大的值为 1460 字节；</li>
<li>tcp_push ：根据 Nagle 算法，将发送的队列发送到 IP 协议层，这里会受滑动窗口和拥塞窗口的影响。</li>
</ol>
<blockquote>
<p>滑动窗口<br>TCP 连接上的双方都会通知对方自己的接收窗口大小。而对方的接收窗口大小就是自己的发送窗口大小。tcp_push 在发送数据时需要与发送窗口打交道。发送窗口是一个时刻变化的值，随着 ACK 的到达会变大，随着发出新的数据包会变小。当然，最大也只能到三次握手时对方通告的窗口大小。</p>
</blockquote>
<blockquote>
<p>拥塞窗口<br>拥塞窗主要是根据网络的拥塞情况控制报文发送的数量，从而达到改善网络传输的目的。TCP 连接刚建立时，拥塞窗口的大小远小于发送窗口，它实际上是一个 MSS。每收到一个 ACK，拥塞窗口扩大一个 MSS 大小，当然，拥塞窗口最大只能到对方通告的接收窗口大小。当然，为了避免指数式增长，拥塞窗口大小的增长会更慢一些，是线性的平滑的增长过程。所以，在tcp_push发送消息时，还会检查拥塞窗口，飞行中的报文数要小于拥塞窗口个数，而发送数据的长度也要小于拥塞窗口的长度。</p>
</blockquote>
<h3 id="4-2-IP-协议层"><a href="#4-2-IP-协议层" class="headerlink" title="4.2 IP 协议层"></a>4.2 IP 协议层</h3><p>IP 协议层将 IP 转换为 MAC 地址，进行下一跳数据的发送。在发送前，可以对 IP 地址进行重写，重写进行路由，实现 SNAT 功能。<br><img src="/images/tcp/ip_send_skb.jpg" alt="ip_send_skb" title="ip_send_skb"></p>
<p>在发送阶段，同样涉及到 netfilter 钩子函数，包括：</p>
<ol>
<li>NF_INET_LOCAL_OUT ：从本机发出的数据包，在查询路由成功之后，会调用__ip_local_out_sk 函数,首先进行必要字段设置和校验和计算，然后经过 NF_INET_LOCAL_OUT 钩子点，之后会调用 dst_output_sk 继续完成数据包输出的其他工作；</li>
<li>NF_INET_POST_ROUTING ：转发的数据包或者是本地输出的数据包，最后都会经过 ip_output 进行输出，设置设备和协议之后，经过NF_INET_POST_ROUTING 钩子点，之后调用 ip_finish_output 进行后续输出操作，其中包括了分片等</li>
</ol>
<h3 id="4-3-网络子系统"><a href="#4-3-网络子系统" class="headerlink" title="4.3 网络子系统"></a>4.3 网络子系统</h3><p><img src="/images/tcp/dev_queue_xmit.jpg" alt="dev_queue_xmit" title="dev_queue_xmit"></p>
<ol>
<li>dev_queue_xmit：在该函数中，会先获取设备对应的qdisc，如果没有的话（如loopback或者IP tunnels），就直接调用dev_hard_start_xmit，否则数据包将经过 Traffic Control 模块进行处理；</li>
<li>Traffic Control: 进行一些过滤和优先级处理，在这里，如果队列满了的话，数据包会被丢掉；</li>
<li>dev_hard_start_xmit： 该函数中，首先是拷贝一份 SKB 给 “packet taps” ，tcpdump 就是从这里得到数据的，然后调用 ndo_start_xmit。如果 dev_hard_start_xmit 返回错误的话，则触发软件中断 NET_TX_SOFTIRQ，交给软件中断处理程序 net_tx_action 稍后重试。</li>
<li>ndo_start_xmit：会调用驱动中的函数进行数据的发送。</li>
</ol>
<h3 id="4-4-驱动"><a href="#4-4-驱动" class="headerlink" title="4.4 驱动"></a>4.4 驱动</h3><p>ndo_start_xmit 调用驱动中的函数，进行数据的发送，其大概的流程如下：</p>
<ol>
<li>将 SKB 放入网卡自己的发送队列 （环形队列）；</li>
<li>通知网卡发送数据包；</li>
<li>网卡发送完成后发送中断给CPU；</li>
<li>收到中断后进行 SKB 的清理工作。</li>
</ol>
<h2 id="5-其它"><a href="#5-其它" class="headerlink" title="5. 其它"></a>5. 其它</h2><p>在上面的内容中提到每一个 CPU 都会关联一个 softnet_data 类型的数据结构，这个数据结构存放了与网络相关的信息，其结构如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">softnet_data</span></span></span><br><span class="line"><span class="class">&#123;</span>           </span><br><span class="line">    <span class="comment">/*throttle用于拥塞控制,当拥塞时被设置,此后来的数据包都被丢弃*/</span></span><br><span class="line">    <span class="keyword">int</span> throttle;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*netif_rx返回的拥塞级别*/</span></span><br><span class="line">    <span class="keyword">int</span> cng_level;</span><br><span class="line">    <span class="keyword">int</span> avg_blog;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*input_pkt_queue是skb的队列,接收到的skb全都进入到此队列等待后续处理*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff_head</span> <span class="title">input_pkt_queue</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*poll_list是一个双向链表,链表的成员是有接收数据等待处理的device*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">poll_list</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*net_device链表,成员为有数据报要发送的device*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">output_queue</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*完成发送的数据包等待释放的队列*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">completion_queue</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*注意,backlog_dev不是一个指针,而是一个net_device实体,代表了调用net_rx_action时的device*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> <span class="title">backlog_dev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>这篇文章从整体的维度分析了 TCP 接收和发送报文的流程，这个流程只是一个大概且略显粗糙，如果读完这篇文章，能够对 TCP 有一个系统性的理解，目的也就达到了。</p>
<p><strong>参考：</strong></p>
<hr>
<p><a href="https://segmentfault.com/a/1190000008836467" target="_blank" rel="noopener">1. Linux网络 - 数据包的接收过程</a><br><a href="https://segmentfault.com/a/1190000008926093" target="_blank" rel="noopener">2. Linux网络 - 数据包的发送过程</a><br><a href="https://blog.packagecloud.io/eng/2017/02/06/monitoring-tuning-linux-networking-stack-sending-data/" target="_blank" rel="noopener">3. Monitoring and Tuning the Linux Networking Stack: Sending Data</a><br><a href="https://blog.packagecloud.io/eng/2016/10/11/monitoring-tuning-linux-networking-stack-receiving-data-illustrated/" target="_blank" rel="noopener">4. Illustrated Guide to Monitoring and Tuning the Linux Networking Stack: Receiving Data</a><br><a href="https://ylgrgyq.github.io/2017/08/01/linux-receive-packet-3/" target="_blank" rel="noopener">5. Linux 网络协议栈收消息过程-TCP Protocol Layer</a><br><a href="https://ylgrgyq.github.io/2017/07/23/linux-receive-packet-1/" target="_blank" rel="noopener">6. Linux 网络协议栈收消息过程-Ring Buffer</a><br><a href="https://ylgrgyq.github.io/2017/07/24/linux-receive-packet-2/" target="_blank" rel="noopener">7. Linux 网络协议栈收消息过程-Per CPU Backlog</a><br><a href="https://blog.csdn.net/russell_tao/article/details/9950615" target="_blank" rel="noopener">8. 高性能网络编程3—-TCP消息的接收</a><br><a href="https://blog.csdn.net/russell_tao/article/details/9370109" target="_blank" rel="noopener">9. 高性能网络编程2—-TCP消息的发送</a><br><a href="https://blog.csdn.net/cloudvtech/article/details/80182074" target="_blank" rel="noopener">10. 容器云负载均衡之三：RSS、RPS、RFS和XPS调整</a><br><a href="https://blog.51cto.com/enchen/191923" target="_blank" rel="noopener">11. 数据报的接收过程详解</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/09/pointer-determination-and-heap-traversal/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/08/09/pointer-determination-and-heap-traversal/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">垃圾回收之指针判定及堆的遍历</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-08-09 11:03:19" itemprop="dateCreated datePublished" datetime="2020-08-09T11:03:19+08:00">2020-08-09</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-11-09 19:48:48" itemprop="dateModified" datetime="2020-11-09T19:48:48+08:00">2020-11-09</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/Java基础/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">23k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">21 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p> 在 <a href="https://noahsarkzhang-ts.github.io/2020/07/19/garbage-collecton/" target="_blank" rel="noopener">垃圾回收之回收算法</a> 这篇文章中预设了两个前提：</p>
<ol>
<li>根集合及对象中的指针集合已经得到；</li>
<li>堆是可遍历的，即从一个对象可直接定位到下一个对象；</li>
</ol>
<p> 为了描述的方便，在上篇文章中直接得出了结论，而这篇文章的目的就是解释这两个问题。</p>
<h2 id="1-指针的判定"><a href="#1-指针的判定" class="headerlink" title="1. 指针的判定"></a>1. 指针的判定</h2><p>从位置上来说，可以初步将指针分为两类：1）根上指针，主要包括寄存器、线程栈及全局变量上的指针；2）堆内指针，主要是指堆中对象内指向其它对象的指针，正常来说，根上指针需要运行时才能确定，而堆内指针对于静态类型的语言来说在编译时就可以确定。两者的关系如下图所示：<br><img src="/images/gc/pointer.jpg" alt="pointer" title="pointer"></p>
<p>识别出堆上或根上的数据是否是指针，是垃圾回收的前提，根据识别的程度，可以将垃圾回收分为三类：</p>
<ol>
<li>准确式 GC (precise GC) ：能够识别根上指针和堆内指针，明确数据是否是指针类型；</li>
<li>半保守式 GC ：也叫根上保守，它能识别堆内指针，但不能识别根上指针；</li>
<li>保守式GC（conservative GC）: 不能完全识别指针类型，它根据一些规则来排除不是指针，这些规则包含上下边界检查（GC堆的上下界是已知的）、对齐检查（通常分配空间的时候会有对齐要求，假如说是4字节对齐，那么不能被4整除的数字就肯定不是指针）。</li>
</ol>
<h3 id="1-1-堆内指针的判定"><a href="#1-1-堆内指针的判定" class="headerlink" title="1.1 堆内指针的判定"></a>1.1 堆内指针的判定</h3><p>要识别出堆内的指针，一般要求对象上记录对象的类型信息，在扫描堆的时候，可以根据类型信息，来判断对象中的数据是否是指针类型。如果是JVM的话，这些数据可能在类加载器或者对象模型的模块里计算得到，不需要编译器的支持。</p>
<h3 id="1-2-根上指针的判定"><a href="#1-2-根上指针的判定" class="headerlink" title="1.2 根上指针的判定"></a>1.2 根上指针的判定</h3><p>根上的数据，如寄存器和线程栈，是运行时产生的数据，与堆内指针的判定方法不一样，以 JVM 为例，一般有以下几个方法：</p>
<ol>
<li>让数据自身带上标记（tag）；</li>
<li>让编译器为每个方法生成特别的扫描代码；</li>
<li>从外部记录下类型信息，存成映射表。现在三种主流的高性能 JVM 实现，HotSpot、JRockit 和 J9 都是这样做的。其中，HotSpot把这样的数据结构叫做OopMap，JRockit 里叫做livemap，J9 里叫做GC map。Apache Harmony的 DRLVM 也把它叫 GCMap。</li>
</ol>
<p>JVM 中指令的执行会影响寄存器和线程栈中的数据，要实现映射表，需要 JVM 的解释器和 JIT 编译器都有相应的支持，由它们来生成足够的元数据（类型）提供给垃圾回收器。在HotSpot中，如果 JVM 以解释的方式运行代码，映射表（OopMap）可以由解释器来收集；如果使用 JIT 编译器编译后的代码，则需要在一些关键点插入代码来记录映射表（OopMap）。这些关键点也叫做“安全点”（safepoint），之所以要选择一些特定的位置来记录OopMap，是因为如果对每条指令（的位置）都记录 OopMap 的话，这些记录就会比较大，那么空间开销会显得不值得。选用一些比较关键的点来记录就能有效的缩小记录的数据量，这些关键点包括：</p>
<ol>
<li>循环的末尾；</li>
<li>方法临返回前 / 调用方法的call指令后；</li>
<li>可能抛异常的位置。</li>
</ol>
<p>所以说，垃圾回收不是在任意位置都可以进入，只能在 safepoint 处进入。</p>
<p>平时这些 OopMap 都是压缩存在内存里，在垃圾回收的时候才按需解压出来使用，一般有两种使用方式：</p>
<ol>
<li>每次都遍历原始的OopMap，循环的一个个偏移量扫描过去；这种用法也叫“解释式”；</li>
<li>为每个 OopMap生成一块定制的扫描代码，以后每次要用 OopMap 就直接执行生成的扫描代码；这种用法也叫“编译式”。</li>
</ol>
<p>HotSpot 是用“解释式”的方式来使用 OopMap 的，每次都循环变量里面的项来扫描对应的偏移量。</p>
<h3 id="1-3-OopMap"><a href="#1-3-OopMap" class="headerlink" title="1.3 OopMap"></a>1.3 OopMap</h3><p>在 HotSpot 中，对象的类型信息里有记录自己的 OopMap，记录了在该类型的对象内什么偏移量上是什么类型的数据。所以从对象开始向外的扫描可以是准确的，这些数据是在类加载过程中计算得到的。另外，在“安全点”中记录了根上数据类型及偏移量，保证了根上的数据类型也是准确的，通过这两种方法，HotSpot 实现了准确式 GC 。现在我们来看下，在 JVM 中 OopMap 相关的信息。</p>
<blockquote>
<p>Oop maps are bit maps specifying which stack and register locations hold oops for a given pc. During GC, these locations need to be visited since they represent roots for GC. Also, if GC moves objects, pointers must be updated.</p>
</blockquote>
<h4 id="1-3-1-根集合上关联的OopMap"><a href="#1-3-1-根集合上关联的OopMap" class="headerlink" title="1.3.1 根集合上关联的OopMap"></a>1.3.1 根集合上关联的OopMap</h4><p>如果 JVM 使用翻译器，则在翻译器中收集 OopMap 中，如果使用 JIT 编译器，则在指定位置插入特定的代码收集 OopMap，我们以下面的代码为例，反汇编代码，分析 OopMap相关的结构。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DisAssemblyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String name = <span class="string">"test"</span>;</span><br><span class="line">        String newName = name.intern();</span><br><span class="line">        System.out.println(name == newName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> DisAssemblyTest().invoke();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用如下参数，运行代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -Xcomp </span><br><span class="line">-XX:CompileCommand=dontinline,*DisAssemblyTest.invoke </span><br><span class="line">-XX:CompileCommand=compileonly,*DisAssemblyTest.invoke</span><br></pre></td></tr></table></figure></p>
<p>反汇编的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">[Entry Point]</span><br><span class="line">[Constants]</span><br><span class="line">  # &#123;method&#125; &#123;0x0000000057252b68&#125; &apos;invoke&apos; &apos;()V&apos; in &apos;org/noahsrak/jvm/DisAssemblyTest&apos;</span><br><span class="line">  #           [sp+0x40]  (sp of caller)</span><br><span class="line">  0x000000000296baa0: mov    0x8(%rdx),%r10d</span><br><span class="line">  0x000000000296baa4: cmp    %rax,%r10</span><br><span class="line">  ...</span><br><span class="line">[Verified Entry Point]</span><br><span class="line">  0x000000000296bac0: mov    %eax,-0x6000(%rsp)</span><br><span class="line">  ...</span><br><span class="line">  0x000000000296bb9f: callq  0x00000000028a61a0  ; OopMap&#123;[32]=Oop off=260&#125;</span><br><span class="line">                                                ;*invokevirtual intern</span><br><span class="line">                                                ; - org.noahsrak.jvm.DisAssemblyTest::invoke@4 (line 12)</span><br><span class="line">                                                ;   &#123;optimized virtual_call&#125;</span><br><span class="line">  0x000000000296bba4: nopl   0x0(%rax)</span><br><span class="line">  0x000000000296bba8: jmpq   0x000000000296bd3c  ;   &#123;no_reloc&#125;</span><br><span class="line">  0x000000000296bbad: add    %al,(%rax)</span><br><span class="line">  0x000000000296bbaf: add    %al,(%rax)</span><br><span class="line">  0x000000000296bbb1: add    %ah,0xf(%rsi)</span><br><span class="line">  ...</span><br><span class="line">  0x000000000296bcb5: movabs $0xffffffffffffffff,%rax</span><br><span class="line">  0x000000000296bcbf: callq  0x00000000028a63e0  ; OopMap&#123;off=548&#125;</span><br><span class="line">                                                ;*invokevirtual println</span><br><span class="line">                                                ; - org.noahsrak.jvm.DisAssemblyTest::invoke@21 (line 13)</span><br><span class="line">                                                ;   &#123;virtual_call&#125;</span><br><span class="line">  0x000000000296bcc4: add    $0x30,%rsp</span><br><span class="line">  0x000000000296bcc8: pop    %rbp</span><br><span class="line">  0x000000000296bcc9: test   %eax,-0x253bbcf(%rip)        # 0x0000000000430100</span><br><span class="line">                                                ;   &#123;poll_return&#125;</span><br><span class="line">  0x000000000296bccf: retq   </span><br><span class="line">  0x000000000296bcd0: mov    %rsi,0x8(%rsp)</span><br><span class="line">  0x000000000296bcd5: movq   $0xffffffffffffffff,(%rsp)</span><br><span class="line">  0x000000000296bcdd: callq  0x000000000296a460  ; OopMap&#123;rdx=Oop off=578&#125;</span><br><span class="line">                                                ;*synchronization entry</span><br><span class="line">                                                ; - org.noahsrak.jvm.DisAssemblyTest::invoke@-1 (line 11)</span><br><span class="line">                                                ;   &#123;runtime_call&#125;</span><br><span class="line">  0x000000000296bce2: jmpq   0x000000000296bafb</span><br><span class="line">  0x000000000296bce7: movabs $0x0,%r8           ;   &#123;oop(NULL)&#125;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></p>
<p>这段输出含有一条callq指令，用来实现对intern()方法的调用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OopMap&#123;[<span class="number">32</span>]=Oop off=<span class="number">260</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>它的含义是：有一个OopMap与这条callq指令之后的一条指令（nopl）关联在一起，该指令位置上有一个活跃的引用，在离栈顶偏移量为32的位置上。</p>
<p>OopMap记录输出的日志的构成是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OopMap&#123;零到多个“数据位置=内容类型”的记录 off=该OopMap关联的指令的位置&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，[32]表示栈顶指针+偏移量0，这里就是[rsp + 32]，也就是栈顶偏移量为32的位置；右边的”=Oop”说明这个位置存着一个普通对象指针（ordinary object pointer，HotSpot 将指向GC堆中对象开头位置的指针称为Oop）</p>
<p>off=260 就是这个 OopMap 记录关联的指令在方法的指令流中的偏移量，这个数字是十进制的。可以看到，该方法的指令流是从地址0x000000000296baa0开始的；十进制的260就是十六进制的0x104；<code>0x000000000296baa0 + 0x104 = 0x000000000296bba4</code>，正好就是例子中callq指令后的<code>nopl   0x0(%rax)</code>所在的位置。</p>
<h4 id="1-3-2-对象上关联的OopMap"><a href="#1-3-2-对象上关联的OopMap" class="headerlink" title="1.3.2 对象上关联的OopMap"></a>1.3.2 对象上关联的OopMap</h4><p>除了在根集合上收集 OopMap，在对象上也会关联 OopMap，用来描述对象中字段的引用信息，对象中的 OopMap 存放在对象的类信息中，在类进行加载的时候进行初始化。分析 OopMap 之前，我们先了解下 java 中对象与类的关系。<br><img src="/images/gc/klass.png" alt="klass" title="klass"></p>
<p>HotSpot中采用了 OOP-Klass 模型来描述 Java 对象与类的关系：</p>
<ol>
<li>OOP 或 OOPS （Ordinary Object Pointer）指的是普通对象指针，主要职能是表示对象的实例数据，存储在堆里面；</li>
<li>Klass 用来描述对象实例的具体类型，实现语言层面的 Java 的 Class 对象，在 JVM 中用 Klass 表示，存储在元空间（方法区）。</li>
</ol>
<p>在 Java 中，每创建一个 Java 对象，在 JVM 内部也会相应创建一个 OOP 对象来表示 Java 对象。OOP类的共同基类型是oopDesc，它有多个子类，instanceOopDesc 表示对象，arrayOopDesc 表示数组。</p>
<p>其中，instanceOopDesc 和 arrayOopDesc 又称为对象头，instanceOopDesc 对象头包括以下两部分信息：Mark Word 和 元数据指针(Klass*)：</p>
<ol>
<li>Mark Word，主要存储对象运行时记录信息，如hashcode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等;</li>
<li>元数据指针，用来存储 klass 指针，对应的klass 指针指向一个存储类的元数据的 Klass 对象。</li>
</ol>
<p>instanceOopDesc 用于表示 Java 对象，instanceKlass 用于描述 instanceOopDesc，instanceKlassKlass 用来描述 instanceKlass，为了避免无限描述下去，所以有个klassKlass作为这个描述链上的终结符。</p>
<p>对象中的 OopMap 就是在 Klass 对象中存放，其布局如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">InstanceKlass layout:</span><br><span class="line">  [C++ vtbl pointer           ] Klass</span><br><span class="line">  [subtype cache              ] Klass</span><br><span class="line">  [instance size              ] Klass</span><br><span class="line">  [java mirror                ] Klass</span><br><span class="line">  [super                      ] Klass</span><br><span class="line">  [access_flags               ] Klass</span><br><span class="line">  [name                       ] Klass</span><br><span class="line">  [first subklass             ] Klass</span><br><span class="line">  [next sibling               ] Klass</span><br><span class="line">  [<span class="built_in">array</span> klasses              ]</span><br><span class="line">  [methods                    ]</span><br><span class="line">  [local interfaces           ]</span><br><span class="line">  [transitive interfaces      ]</span><br><span class="line">  [fields                     ]</span><br><span class="line">  [constants                  ]</span><br><span class="line">  [<span class="class"><span class="keyword">class</span> <span class="title">loader</span>               ]</span></span><br><span class="line"><span class="class">  [<span class="title">source</span> <span class="title">file</span> <span class="title">name</span>           ]</span></span><br><span class="line"><span class="class">  [<span class="title">inner</span> <span class="title">classes</span>              ]</span></span><br><span class="line"><span class="class">  [<span class="title">static</span> <span class="title">field</span> <span class="title">size</span>          ]</span></span><br><span class="line"><span class="class">  [<span class="title">nonstatic</span> <span class="title">field</span> <span class="title">size</span>       ]</span></span><br><span class="line"><span class="class">  [<span class="title">static</span> <span class="title">oop</span> <span class="title">fields</span> <span class="title">size</span>     ]</span></span><br><span class="line"><span class="class">  [<span class="title">nonstatic</span> <span class="title">oop</span> <span class="title">maps</span> <span class="title">size</span>    ]</span></span><br><span class="line"><span class="class">  [<span class="title">has</span> <span class="title">finalize</span> <span class="title">method</span>        ]</span></span><br><span class="line"><span class="class">  [<span class="title">deoptimization</span> <span class="title">mark</span> <span class="title">bit</span>    ]</span></span><br><span class="line"><span class="class">  [<span class="title">initialization</span> <span class="title">state</span>       ]</span></span><br><span class="line"><span class="class">  [<span class="title">initializing</span> <span class="title">thread</span>        ]</span></span><br><span class="line"><span class="class">  [<span class="title">Java</span> <span class="title">vtable</span> <span class="title">length</span>         ]</span></span><br><span class="line"><span class="class">  [<span class="title">oop</span> <span class="title">map</span> <span class="title">cache</span> (<span class="title">stack</span> <span class="title">maps</span>) ]</span></span><br><span class="line"><span class="class">  [<span class="title">EMBEDDED</span> <span class="title">Java</span> <span class="title">vtable</span>             ] <span class="title">size</span> <span class="title">in</span> <span class="title">words</span> = <span class="title">vtable_len</span></span></span><br><span class="line"><span class="class">  [<span class="title">EMBEDDED</span> <span class="title">nonstatic</span> <span class="title">oop</span>-<span class="title">map</span> <span class="title">blocks</span>] <span class="title">size</span> <span class="title">in</span> <span class="title">words</span> = <span class="title">nonstatic_oop_map_size</span></span></span><br><span class="line"><span class="class">    <span class="title">The</span> <span class="title">embedded</span> <span class="title">nonstatic</span> <span class="title">oop</span>-<span class="title">map</span> <span class="title">blocks</span> <span class="title">are</span> <span class="title">short</span> <span class="title">pairs</span> (<span class="title">offset</span>, <span class="title">length</span>)</span></span><br><span class="line"><span class="class">    <span class="title">indicating</span> <span class="title">where</span> <span class="title">oops</span> <span class="title">are</span> <span class="title">located</span> <span class="title">in</span> <span class="title">instances</span> <span class="title">of</span> <span class="title">this</span> <span class="title">klass</span>.</span></span><br><span class="line"><span class="class">  [<span class="title">EMBEDDED</span> <span class="title">implementor</span> <span class="title">of</span> <span class="title">the</span> <span class="title">interface</span>] <span class="title">only</span> <span class="title">exist</span> <span class="title">for</span> <span class="title">interface</span></span></span><br><span class="line"><span class="class">  [<span class="title">EMBEDDED</span> <span class="title">host</span> <span class="title">klass</span>        ] <span class="title">only</span> <span class="title">exist</span> <span class="title">for</span> <span class="title">an</span> <span class="title">anonymous</span> <span class="title">class</span> (<span class="title">JSR</span> 292 <span class="title">enabled</span>)</span></span><br></pre></td></tr></table></figure></p>
<p>在上面的布局中可以看到有一个 oop map cache 的字段，猜测就是用来存放 OopMap相关的信息。</p>
<h4 id="1-3-3-小结"><a href="#1-3-3-小结" class="headerlink" title="1.3.3 小结"></a>1.3.3 小结</h4><p>用一句话来描述，OopMap 存放了堆、栈及寄存器上指针信息，借助 OopMap 不仅可以准确判定一个数值是否是指针，同时直接扫描 OopMap 集合可以加快标记的速度，从而提高垃圾回收的效率。</p>
<h2 id="2-堆的遍历"><a href="#2-堆的遍历" class="headerlink" title="2. 堆的遍历"></a>2. 堆的遍历</h2><h3 id="2-1-内存分配"><a href="#2-1-内存分配" class="headerlink" title="2.1 内存分配"></a>2.1 内存分配</h3><p>在垃圾回收算法中，需要对堆进行清除及整理操作，这时候就需要对堆从头到尾进行遍历，遍历的方式跟内存的分配方式极为相关，我们先介绍内存的分配方式。内存的分配方式有两种基本的分配策略：1）顺序分配；2）空闲链表分配。</p>
<ol>
<li><p>顺序分配<br>顺序分配使用一个较大的空闲内存块，从一端根据大小顺序分配，它的数据结构比较简单，只需要一个空闲指针（free pointer）和一个界限指针（limit pointer）。根据分配的内存块大小，只要简单移动空闲指针即可。如果存在字节对齐要求，则可能需要额外增加填充字节，分配的逻辑如下图所示：<br><img src="/images/gc/sequence-allocation.jpg" alt="sequence-allocation" title="sequence-allocation"><br>顺序分配的特点是简单、高效，适用于大块内存及内存比较规整的情况下，可以在复制回收及标记整理算法中使用。使用顺序分配的堆中，要实现堆的遍历，每一个分配的内存块需要包含一个头部，描述内存块的信息，如块的大小等等。</p>
</li>
<li><p>空闲链表分配<br>空闲链表使用某种数据结构来记录空闲内存单元（free cell）的位置和大小，该数据结构将所有的空闲内存块串联起来进行统一分配。严格来讲，空闲内存单元的组织方式不一定是链表，也可以采用其它形式。下面是使用双向空闲链表的结构：<br><img src="/images/gc/linklist-allocation.jpg" alt="linklist-allocation" title="linklist-allocation"><br>内存块中都会有一个头部，表明块的大小及是否已分配。另外在每一个空闲块中，都会包含一个pred（前驱）和succ（后继）指针，从而可以对空闲块进行双向遍历。<br>在需要分配内存时，分配器顺序检测每一个空闲内存单元，依照某种策略选择一个并从中进行分配。其算法实现通常是顺序扫描所有空闲内存单元，直到发现第一个符合条件的内存单元为止，因而也叫做顺序适应分配。典型的算法包括首次适应（first-fit）、循环首次适配（next-fit）、最佳适应（best-fit）。<br><strong>1) 首次适应分配</strong><br>对于一次内存分配请求，首次适应分配器将在所发现的第一个满足分配要求的内存单元中进行分配。如果该内存单元的空间大于所需的空间，则会进行分裂操作，将剩余的空间归还到空闲链表中。<br><strong>2) 循环首次适应分配</strong><br>循环首次适应分配是首次适应分配算法的一个变种。在分配内存时，该算法不是每次都从空闲链表头部开始查找，而是从上次成功分配的位置开始。该算法可以有效避免对空闲链表前端较小空间内存单元的遍历。<br><strong>3) 最佳适应分配</strong><br>最佳适应分配是指在空闲链表中找到满足分配要求且空间最小的空闲内存单元，其目的在于减少空间浪费，同时避免不必要的内存单元分裂。</p>
</li>
</ol>
<p>使用空闲链表分配的堆内存，进行堆的遍历相对比较容易，根据内存单元的头部信息可以快速定位到下一个内存单元。</p>
<h3 id="2-2-JVM内存分配"><a href="#2-2-JVM内存分配" class="headerlink" title="2.2 JVM内存分配"></a>2.2 JVM内存分配</h3><h4 id="2-2-1-Java对象布局"><a href="#2-2-1-Java对象布局" class="headerlink" title="2.2.1 Java对象布局"></a>2.2.1 Java对象布局</h4><p>在分析 JVM 内存分配之前，先要理解一个 Java 对象在内存中的布局，Java 对象的布局如下所示：<br><img src="/images/gc/object-layout.jpg" alt="object-layout" title="object-layout"><br>一个Java对象在内存中包括对象头、实例数据和对齐填充3个部分：<br>1、对象头<br>Mark Word：用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，在32位系统占4字节，在64位系统中占8字节；<br>klass：用来指向对象对应的 Klass 对象（其对应的元数据对象）的内存地址，在32位系统占4字节，在64位系统中占8字节；<br>Length：如果是数组对象，还有一个保存数组长度的空间，占4个字节；<br>2、实例数据<br>存储对象各字段的内容。<br>3、对齐填充<br>HotSpot 要求对象起始地址必须是8字节的整数，即对象的大小必须是8字节的整数倍。当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p>
<p>Klass指针指向的元数据对象就是我们上节讲到的InstanceKlass，它存有对象描述信息及OopMap，在垃圾回收算法中起到比较关键的作用。</p>
<h4 id="2-2-2-内存分配"><a href="#2-2-2-内存分配" class="headerlink" title="2.2.2 内存分配"></a>2.2.2 内存分配</h4><p>在 JVM 中要分配一个对象，有两种分配方式：1）指针碰撞；2）空闲列表。这两种方式跟我们在上面讲的分配方式是类似的，可以认为这两种方式是其具体的实现。<br>1、指针碰撞<br><img src="/images/gc/bump-the-pointer.jpg" alt="bump-the-pointer" title="bump-the-pointer"></p>
<p>使用该算法，直接根据分配对象的大小，移动空闲指针即可。在对象头中存放了对象元数据对象的指针，可以方便得到对象的大小，进而定位到下一个对象的位置，实现堆的遍历。</p>
<p>2、空闲列表<br><img src="/images/gc/free-list-before.jpg" alt="free-list-before" title="free-list-before"><br>使用空闲列表算法，已分配的内存块和释放的内存块互相间隔，在遍历堆的时候需要跳过释放的内存块或未分配的内存块，一种可选的做法是用一个“填充对象”覆盖释放的内存块，如下图所示：<br><img src="/images/gc/free-list-after.jpg" alt="free-list-after" title="free-list-after"><br>当释放一个对象时，回收器使用一个“填充对象”覆盖其空间，而“填充对象”内部包含一个表示自身大小的域（可以当作一个字节数组），清扫器（标记-清扫算法）可以据此快速跳过空闲内存单元并找到下一个真正的对象。</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>在这篇文章里，我们分析了垃圾回收中的两个问题：1）指针的判定；2）堆的遍历。在 JVM 中通过维护 OopMap 解决了指针的判定，同时通过对象对象头记录的元数据，可以方便定位对象的位置，从而解决对象的遍历。</p>
<p><strong>参考：</strong></p>
<hr>
<p><a href="https://www.iteye.com/blog/rednaxelafx-1044951" target="_blank" rel="noopener">1. 找出栈上的指针/引用</a><br><a href="https://book.douban.com/subject/26740958/" target="_blank" rel="noopener">2. 垃圾回收算法手册——自动内存管理的艺术</a><br><a href="https://book.douban.com/subject/26912767/" target="_blank" rel="noopener">3. 深入理解计算机系统</a><br><a href="https://www.iteye.com/blog/rednaxelafx-730461" target="_blank" rel="noopener">4. 借助HotSpot SA来一窥PermGen上的对象</a><br><a href="https://blog.csdn.net/jyxmust/article/details/88255594" target="_blank" rel="noopener">5. 浅谈JVM OOP-Klass二分模型</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/02/deep-understanding-of-high-concurrency/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/08/02/deep-understanding-of-high-concurrency/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">思维导图-高并发</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-08-02 15:28:15" itemprop="dateCreated datePublished" datetime="2020-08-02T15:28:15+08:00">2020-08-02</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-08-04 13:53:40" itemprop="dateModified" datetime="2020-08-04T13:53:40+08:00">2020-08-04</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/思维导图/" itemprop="url" rel="index"><span itemprop="name">思维导图</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">304</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">1 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇文章是对《高并发，你真的理解透彻了吗？》的记录及整理。</p>
<p><img src="/images/high-concurrency/high-concurrency.jpeg" alt="high-concurrency" title="high-concurrency"></p>
<p><strong>参考：</strong></p>
<hr>
<p><a href="https://mp.weixin.qq.com/s/lc0a8eIRL94gqeb9R1kQzg" target="_blank" rel="noopener">1. 高并发，你真的理解透彻了吗？</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/19/garbage-collecton/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/07/19/garbage-collecton/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">垃圾回收之回收算法</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-07-19 16:57:52" itemprop="dateCreated datePublished" datetime="2020-07-19T16:57:52+08:00">2020-07-19</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-11-09 19:48:48" itemprop="dateModified" datetime="2020-11-09T19:48:48+08:00">2020-11-09</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/Java基础/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">37k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">34 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>几乎所有的现代编程语言都使用动态内存分配，即允许进程在运行时分配或释放无法在编译期确定大小的对象，这些对象的存活时间有可能超出创建者的生存周期。动态分配的对象存在于堆（heap）中而不是栈（stack）或者静态区（statically）中。在内存的管理方式上，有两种方式：1）显示内存释放，由开发人员显示的创建或释放对象；2）自动动态内存管理，由编程语言的运行时系统（虚拟机）负责内存的回收。自动动态内存管理可以显著地降低开发成本，提供程序的健壮性。我们这篇文章主要便是讲述内存管理中常用垃圾回收算法，并结合 java来分析内部的实现。</p>
<p>垃圾回收的目的是回收程序不再使用的对象所占用的空间，任何具备自动内存管理系统的语言都要有三个功能：</p>
<ol>
<li>为新对象分配空间；</li>
<li>确定存活对象；</li>
<li>回收死亡对象所占用的空间。</li>
</ol>
<p>内存分配与回收是相关性比较强的两个功能，内存管理系统都要具备这两个功能；在实现中，使用指针的可达性来近似对象的存活：只有当堆中存在一条从根出发的指针链能最终到达某个对象时，才能认定该对象存活，更进一步，如果不存在这一条指针链，则认为对象死亡，其空间可以得到回收。回收死亡对象包括两种方式：1）直接释放该对象，有可能会与前后的空闲对象进行合并；2）将存活对象进行移动或整理，减少内存碎片的问题。</p>
<h2 id="1-标记-清扫"><a href="#1-标记-清扫" class="headerlink" title="1. 标记 - 清扫"></a>1. 标记 - 清扫</h2><p>标记 - 清除算法分为两个阶段：1）追踪（trace）阶段，即回收器（回收程序）从根集合（寄存器、线程栈、全局变量）开始遍历对象图，并标记（mark）所遇到的每一个对象；2）清扫（sweep）阶段，即回收器检查堆中每一个对象，并将所有未标记的对象当作垃圾进行回收。其算法如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">New():  // 新建对象</span><br><span class="line">    ref = allocate()</span><br><span class="line">    if ref == null    // 堆中没有可用空间</span><br><span class="line">        collect()     // 进行一次内存回收</span><br><span class="line">        ref = allocate()</span><br><span class="line">        if ref == null // 堆中仍然没有可用空间</span><br><span class="line">            error &quot;Out of memory&quot;</span><br><span class="line"></span><br><span class="line">collect():  // 回收对象</span><br><span class="line">    markFromRoots()</span><br><span class="line">    sweep(HeapStart, HeapEnd)</span><br></pre></td></tr></table></figure>
<p>在新建对象的方法中，会给对象分配一块内存空间，如果堆中没有足够的可用空间，会进行一次内存回收，回收之后再分配一次内存，如果堆中仍然没有足够的可用空间，则抛出错误。<br>在回收对象的方法中，会从根集合开始，对存活的对象进行标记，然后遍历整个堆，对未标记的对象执行回收操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">markFromRoots():</span><br><span class="line">    initialise(worklist)</span><br><span class="line">    for each fld in Roots</span><br><span class="line">        ref = *fld</span><br><span class="line">        if ref != null &amp;&amp; not isMarked(ref)</span><br><span class="line">            setMarked(ref)</span><br><span class="line">            add(wokrklist,ref)</span><br><span class="line">            mark()</span><br><span class="line"></span><br><span class="line">initialise(worklist) </span><br><span class="line">    worklist = empty</span><br><span class="line"></span><br><span class="line">mark():</span><br><span class="line">    while not isEmpty(worklist)</span><br><span class="line">        ref = remove(worklist)</span><br><span class="line">        for each fld in (Pointers(ref))</span><br><span class="line">            child = *fld</span><br><span class="line">            if ref != null &amp;&amp; not isMarked(ref)</span><br><span class="line">                setMarked(child)</span><br><span class="line">                add(worklist,child)</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong><br>1) Roots：表示根集合，包含指针扫描的起点，主要是指寄存器、线程栈和全局变量；<br>2）Pointers(ref)：表示ref指针指向的对象中包含的指针集合；</p>
<p><strong>如何得到根集合和对象中的指针集合，我们会在后面的文章再讲解，现在假定我们已经知道这些值。</strong></p>
<p>我们可以将堆看作是一个图的结构，对象是结点，结点间的指针（引用）是边，根便是图的起始结点。对堆对象进行标记就是对对象图进行遍历操作，在上面的算法中使用的深度优先遍历算法。在算法中使用栈来实现工作列表，先从根结点开始，将标记过的对象放入工作列表中，然后取出对象对其所指向的对象进行标记，直到工作列表为空。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sweep(start,end):</span><br><span class="line">    scan = start</span><br><span class="line">    while scan &lt; end</span><br><span class="line">        if (isMarked(scan))</span><br><span class="line">            unsetMarked(scan)</span><br><span class="line">        else </span><br><span class="line">            free(scan)</span><br><span class="line">        scan = nextObject(scan)</span><br></pre></td></tr></table></figure>
<p>清除操作将堆中的所有对象看作一个对象列表，可以从堆的起始地址遍历所有对象，如果对象被标记则取消标记，进行下一轮的回收，如果未标记，则说明是一个死对象，则进行回收，回收的策略取决于具体的实现。如何对堆中的对象进行遍历，我们将在后面的文章进行讲解。一个完整的标记-清扫算法如下所示：<br><img src="/images/mark-sweep.gif" alt="mark-sweep" title="mark-sweep"></p>
<h3 id="1-1-三色遍历"><a href="#1-1-三色遍历" class="headerlink" title="1.1 三色遍历"></a>1.1 三色遍历</h3><p>标记的核心操作之一就是从给定的根集合出发去遍历对象图。遍历它有两种典型顺序：深度优先（DFS）和广度优先（BFS）。</p>
<p>广度优先遍历的典型实现思路是三色遍历：给对象赋予白、灰、黑三种颜色以标记其遍历状态：<br>1）白色：未遍历到的对象，所有对象的初始状态都是白色；<br>2）灰色：已遍历到但还未处理完的对象，即还有出边没有遍历；<br>3）黑色：已遍历完的对象，所有出边已经遍历。</p>
<p><img src="/images/tricolour-abstraction.gif" alt="tricolour-abstraction" title="tricolour-abstraction"></p>
<p>算法的步骤如下：<br>1）算法开始，所有的对象标记为白色；<br>2）从根集合开始，将引用到的对象标记为灰色；<br>3）从灰色集合中取出对象，遍历其所有出边，将遍历到的对象标记为灰色，遍历结束，将该对象标记为黑色；<br>4）重复第三步，直到没有灰色对象，最后未被遍历到白色对象即为死亡对象。</p>
<h2 id="2-标记-整理"><a href="#2-标记-整理" class="headerlink" title="2. 标记 - 整理"></a>2. 标记 - 整理</h2><p>标记-清扫算法只是对不再存活的对象进行释放，不会对存活的对象进行移动，这会造成碎片的问题，即使可用内存大于对象分配所需的内存，由于这些内存不是连续的，最终会导致分配失败。为了解决这个问题，引入了标记-整理算法。该算法在标记-清除算法的基础上，会将存活的对象统一移动到某一端，让它们连续存储在一起，从而得到较大的可用内存。根据移动前后的位置，有三种移动的顺序：</p>
<ol>
<li>任意顺序：对象的移动顺序与它们的原始排列顺序和引用没有关系；</li>
<li>线性顺序：将具有关联关系的对象排列在一一起，如对象之间的引用关系或同一个数据结构中相邻的对象；</li>
<li>滑动顺序：将对象滑动到堆的一端，保持对象在堆中原有的分配顺序。</li>
</ol>
<p>这里会分别介绍四种整理算法：1）双指针整理算法；2）Lisp 2算法；3）引线整理算法；4）单次遍历算法。其中除了双指针整理算法是按照任意顺序移动对象，其它算法都是滑动顺序。所有的整理算法都遵循下面的范式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">collect():</span><br><span class="line">    markFromRoots();</span><br><span class="line">    compact()</span><br></pre></td></tr></table></figure></p>
<h3 id="2-1-双指针整理算法"><a href="#2-1-双指针整理算法" class="headerlink" title="2.1 双指针整理算法"></a>2.1 双指针整理算法</h3><p>双指针整理算法需要遍历两次堆，适用于只包含固定大小对象的区域。该算法流程如下：</p>
<ol>
<li>计算出“高水位标记”，地址大于该阈值的存活对象都被移动该阈值之下；</li>
<li>设置两个指针，free 指针指向区域始端，scan 指针指向区域末端；</li>
<li>第一次遍历，free 指针向后移动，找到空闲区域为止，scan 指针向前移动，找到存活对象为止；</li>
<li>将 scan 指针指向的存活对象移动到 free 指向的空闲区域，并将scan对象中的“转发指针”设置为 free ，方便下次做指针的更新；</li>
<li>重新移动 free 及 scan 指针，直到 free &gt; scan 为止；</li>
<li>第二次遍历，更新指针存活对象中的指针，如果指针指向的地址中存在“转发指针”则直接更新该转发地址，算法结束。</li>
</ol>
<p>算法过程如下所示：<br><img src="/images/gc/two-points-init.jpg" alt="two-points-init" title="two-points-init"><br>初始状态下:1）有A, B, C, D 4个存活对象，其中 C 对象中有两个指针分别指向 A 和 B 两个对象。</p>
<p><img src="/images/gc/two-points-first.jpg" alt="two-points-first" title="two-points-first"><br>第一次遍历，将 A 和 B 两个对象移动到低地址区域，同时将移动后的地址写入到之前的对象中。</p>
<p><img src="/images/gc/two-points-second.jpg" alt="two-points-second" title="two-points-second"><br>第二次遍历，根据“转移地址”更新 C 对象中的 A 和 B 两个指针。</p>
<p>在双指针整理算法中，移动前后的存储对象的空闲空间大小最好是相等的，否则寻找匹配大小的空闲空间需要来回移动free指针，这样会降低算法的执行效率，另外，在该算法中，移动的顺序是任意的，会破坏赋值操作的局部性。</p>
<p>整理算法的伪代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">compact():</span><br><span class="line">    relocate(HeapStart, HeapEnd)</span><br><span class="line">    updateReferences(HeapStart, free)</span><br><span class="line"></span><br><span class="line">relocate(start, end):</span><br><span class="line">    free = start</span><br><span class="line">    scan = end</span><br><span class="line"></span><br><span class="line">    while free &lt; scan</span><br><span class="line">        while isMarked(free)</span><br><span class="line">            unsetMarked(free)</span><br><span class="line">            free = free + size(free)    /* 寻找下一个空闲块 */</span><br><span class="line">        </span><br><span class="line">        while not isMarked(scan) &amp;&amp; scan &gt; free</span><br><span class="line">            scan = scan - size(scan)    /* 寻找前一个存活对象 */</span><br><span class="line">        </span><br><span class="line">        if scan &gt; free</span><br><span class="line">            unsetMarked(scan)</span><br><span class="line">            move(scan, free)</span><br><span class="line">            *scan = free    /* 记录转发地址 */</span><br><span class="line">            free = free + size(free)</span><br><span class="line">            scan = scan - size(scan)</span><br><span class="line"></span><br><span class="line">updateReferences(start, end):</span><br><span class="line">    for each fld in Roots   /* 更新指向被移动对象的根 */</span><br><span class="line">        ref = *fld</span><br><span class="line">        if ref &gt;= end</span><br><span class="line">            *fld = *ref     /* 更新转发地址 */</span><br><span class="line">    </span><br><span class="line">    scan = start</span><br><span class="line">    while scan &lt; end</span><br><span class="line">        for each fld in Pointers(scan)</span><br><span class="line">            ref = *fld</span><br><span class="line">            if ref &gt;= end</span><br><span class="line">                *fld = *ref     /* 更新转发地址 */</span><br><span class="line">        scan = scan + size(scan)    /* 下一个对象 */</span><br></pre></td></tr></table></figure></p>
<h3 id="2-2-Lisp-2-算法"><a href="#2-2-Lisp-2-算法" class="headerlink" title="2.2 Lisp 2 算法"></a>2.2 Lisp 2 算法</h3><p>Lisp 2 算法对管理的对象大小没有限制，它可以管理包含多种大小对象的空间，同时移动的时候采用滑动顺序，不会改变对象的相对顺序。不过整理的过程需要遍历三次堆，算法的流程如下：</p>
<ol>
<li>第一次遍历：计算移动的位置。假定需要整理的内存区域起始地址、结束地址分别为 heapStart 、heapEnd，移动后的内存区域起始地址为toRegion，其中 heapStart 和 toRegion 可以是同一个地址；</li>
<li>将 scan 指向 heapStart 地址，free 指针指向 toRegion地址，开始遍历存活对象，找到存活对象之后，将存活对象中的 forwadingAddress 域设置为 free，然后将 scan 和 free 向后移动 size(存活对象) 大小的位置，当 scan 大于 heapEnd 之后，第一次遍历结束；</li>
<li>第二次遍历：更新转发地址的值。遍历根集合和堆中所有的对象，更新对象指针域中指向的地址为 forwadingAddress 中的地址；</li>
<li>第三次遍历：移动对象。遍历堆中所有对象，将对象移动到 forwadingAddress 指向的地址。</li>
</ol>
<p>算法过程如下所示：<br><img src="/images/gc/lisp2-init.jpg" alt="lisp2-init" title="lisp2-init"><br>初始状态下:1）有A, B, C, D 4个存活对象，其中 C 对象中有两个指针分别指向 A 和 B 两个对象。</p>
<p><img src="/images/gc/lisp2-first.jpg" alt="lisp2-first" title="lisp2-first"><br>第一次遍历，在每一个对象中，增加一个forwadingAddress 域，即 FA域，存放移动后的地址，移动后的地址通过遍历可以获得。</p>
<p><img src="/images/gc/lisp2-second.jpg" alt="lisp2-second" title="lisp2-second"><br>第二次遍历，更新堆中所有对象的指针域，重新指向 FA 域指向的地址。</p>
<p><img src="/images/gc/lisp2-third.jpg" alt="lisp2-third" title="lisp2-third"><br>第三次遍历，根据对象中的 FA 域的值，将该对象移动到 FA 域指向的地址。</p>
<p>Lisp 2 算法需要遍历三次堆，同时对象中需要一个 forwadingAddress 域，用来存放“转发的地址”。</p>
<p>Lisp 2 算法的伪代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">compact():</span><br><span class="line">    computeLocations(HeapStart, HeapEnd, HeapStart)     /* 计算转发地址 */</span><br><span class="line">    updateReferences(HeapStart, HeapEnd)    /* 更新转发地址 */</span><br><span class="line">    relocate(HeapStart, HeapEnd)    /* 移动指针 */</span><br><span class="line"></span><br><span class="line">/* 计算转发地址 */</span><br><span class="line">computeLocations(start, end, toRegion)</span><br><span class="line">    scan = start</span><br><span class="line">    free = toRegion</span><br><span class="line"></span><br><span class="line">    while scan &lt; end</span><br><span class="line">        if isMarked(scan)</span><br><span class="line">            forwardingAddress(scan) = free  /* 设置转发地址 */</span><br><span class="line">            free = free + size(scan)</span><br><span class="line">        scan = scan + size(scan)</span><br><span class="line"></span><br><span class="line">/* 更新转发地址 */</span><br><span class="line">updateReferences(start, end)</span><br><span class="line">    for each fld in Roots   /* 更新根 */</span><br><span class="line">        ref = *fld</span><br><span class="line">        if ref != null</span><br><span class="line">            *fld = forwardingAddress(ref)</span><br><span class="line">    </span><br><span class="line">    scan = start</span><br><span class="line">    while scan &lt; end</span><br><span class="line">        if isMarked(scan)</span><br><span class="line">            for each fld in Pointers(scan)</span><br><span class="line">                if *fld != null</span><br><span class="line">                    *fld = forwardingAddress(*fld)</span><br><span class="line">        scan = scan + size(scan)</span><br><span class="line"></span><br><span class="line">/* 移动指针 */</span><br><span class="line">relocate(start, end)</span><br><span class="line">    scan = start</span><br><span class="line">    while scan &lt; end</span><br><span class="line">        if isMarked(scan)</span><br><span class="line">            dest = forwardingAddress(scan)</span><br><span class="line">            move(scan, dest)</span><br><span class="line">            unsetMarked(dest)</span><br><span class="line">        scan = scan + size(scan)</span><br></pre></td></tr></table></figure>
<h3 id="2-3-引线整理算法"><a href="#2-3-引线整理算法" class="headerlink" title="2.3 引线整理算法"></a>2.3 引线整理算法</h3><p>Lisp 2 算法有两个缺陷：1）需要遍历三次堆；2）每一个对象需要额外的空间来记录转发地址。引线整理算法通过一种不同的策略来解决指针更新的问题，该算法不需要额外存储，且支持滑动整理。引线算法要求对象头部存在足够的空间来保存一个地址，引线的目的是通过对象 N 可以找到所有引用了该对象的对象，实现的方法是临时反转指针的方向。</p>
<p><img src="/images/gc/thread-before.jpg" alt="thread-before" title="thread-before"><br>引线之前，三个对象引用了对象N</p>
<p><img src="/images/gc/thread-after.jpg" alt="thread-after" title="thread-after"><br>引线之后，所有指向对象 N 的指针都被“引线”，因此可以通过对象 N 找到引用了对象 N 的对象。在对象 N 中，指向下一个对象的指针保存在其头部的某个值中，该头部以前的值被（临时地）移动到对象 A 中引用了对象 N 的指针域中。</p>
<p>引线整理算法需要两次堆遍历，第一次遍历实现堆中前向指针（从低地址指向高地址的指针）的引线，第二次遍历实现堆中后向指针（从高地址指向低地址的指针），其算法流程如下：</p>
<ol>
<li>第一次遍历，从对根进行引线，然后在堆中从头到尾进行扫描，同时计算转发地址 free，扫描到对象 N 时，根据前向指针，修改引用对象 N 的所有对象（其地址小于对象 N）的指针，将其设置为 free。同时对对象 N 的所有指针进行引线（包括前向指针和后向指针）。</li>
<li>第二次遍历，在堆中从头到尾进行扫描，计算转发地址，扫描到对象 N 时，根据后向指针，修改引用对象 N 的所有对象（其地址大于对象 N）的指针，将其设置为 free，最后将对象移动到 free。</li>
</ol>
<p>算法过程如下所示：<br><img src="/images/gc/threading-init.jpg" alt="threading-init" title="threading-init"><br>初始状态下，有一个根对象指向对象 N, 三个对象 A, B 及 C 指向 对象 N 。</p>
<p><img src="/images/gc/threading-first-1.jpg" alt="threading-first-1" title="threading-first-1"><br>第一次遍历，扫描到对象 A，实现了前向指针的引线。</p>
<p><img src="/images/gc/threading-first-2.jpg" alt="threading-first-2" title="threading-first-2"><br>第一次遍历，扫描到对象 N，根据前向指针的引线，更新根对象及对象 A 的指针域（对象 N 的新地址 free1）。</p>
<p><img src="/images/gc/threading-first-3.jpg" alt="threading-first-3" title="threading-first-3"><br>第一次遍历，扫描到对象 C，实现了后向指针的引线。</p>
<p><img src="/images/gc/threading-second.jpg" alt="threading-second" title="threading-second"><br>第二闪遍历，根据后向指针的引线，更新后向指针，且移动存活对象。</p>
<p>引线整理算法伪代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">compact():</span><br><span class="line">    updateForwardReferences()   /* 更新前向指针 */</span><br><span class="line">    updateBackwardReferences()  /* 更新后向指针 */</span><br><span class="line"></span><br><span class="line">/* 对引用进行引线 */</span><br><span class="line">thread(ref):</span><br><span class="line">    if *ref != null</span><br><span class="line">        *ref = **ref</span><br><span class="line">        **ref = ref</span><br><span class="line"></span><br><span class="line">/* 根据引线，更新转发地址 */</span><br><span class="line">update(ref, addr):</span><br><span class="line">    tmp = *ref</span><br><span class="line">    while isReference(tmp)</span><br><span class="line">        *tmp = addr</span><br><span class="line">        tmp = *tmp</span><br><span class="line">    *ref = tmp</span><br><span class="line"></span><br><span class="line">/* 更新前向指针 */</span><br><span class="line">updateForwardReferences():</span><br><span class="line">    for each fld in Roots</span><br><span class="line">        thread(*fld)</span><br><span class="line">    </span><br><span class="line">    free = HeapStart</span><br><span class="line">    scan = HeapStart</span><br><span class="line">    while scan &lt;= HeapEnd</span><br><span class="line">        if isMarked(scan)</span><br><span class="line">            update(scan, free)  /* 将所有指向 scan 的前向指针都修改为 free */</span><br><span class="line">            for each fld in Pointers(scan)</span><br><span class="line">                thread(fld)</span><br><span class="line">            free = free + size(scan)</span><br><span class="line">        scan = scan + size(scan)</span><br><span class="line"></span><br><span class="line">/* 更新后向指针且移动对象 */</span><br><span class="line">updateBackwardReferences():</span><br><span class="line">    free = HeapStart</span><br><span class="line">    scan = HeapStart</span><br><span class="line">    while scan &lt;= HeapEnd</span><br><span class="line">        if isMarked(scan)</span><br><span class="line">            update(scan, free)  /* 将所有指向 scan 的后向指针都修改为 free */</span><br><span class="line">            move(scan, free)</span><br><span class="line">            free = free + size(scan)</span><br><span class="line">        scan = scan + size(scan)</span><br></pre></td></tr></table></figure></p>
<h3 id="2-4-单次遍历算法"><a href="#2-4-单次遍历算法" class="headerlink" title="2.4 单次遍历算法"></a>2.4 单次遍历算法</h3><p>在上面三种整理算法中，都需要多次遍历堆，有没有只需要遍历一次堆即可完成内存整理？借助额外的数据结构存储对象的“转发地址”，单次遍历算法通过一次堆的遍历便可实现内存的整理，这是典型的“空间换时间”。<br>在单次遍历算法中，使用了两种数据结构：1）标记位向量（mark-bit vector），它的每一位反映了每个存活对象的起始和结束地址；2）偏移向量（offset vector），将堆划分成大小相等的小内存块（分别是 256 字节和 512 字节），偏移向量记录了每一个内存块中第一个存活对象的的转发地址，其他存活对象的转发地址可以通过偏移向量和标记位向量实时计算得出。对于任意给定对象，可以先计算出其所在内存块的索引号，然后再根据该内存块在偏移向量和标记位向量中对应数据计算出该对象的转发地址。回收器不再需要两次遍历来移动对象和更新指针，转而可以通过对标记位向量的一次遍历来构造偏移向量，然后再通过一次堆遍历同时完成对象的移动和指针的更新。</p>
<p>以下图为例，假定每个内存块包含 8 个槽，每一个槽代表一个字，任意一个对象在标记位向量中使用起始和结束地址进行标记，如old对象，在标记位向量中使用第 16 位和第 19 位来标记。<br><img src="/images/gc/compressor.jpg" alt="compressor" title="compressor"><br>在上图中，堆被分成 4 个内存块，分别是 block 0~3，block 0 中的第 2、3、6、7位被设置，block 1 中的第 3、5 位被设置，这表示已经有 7 个内存字在标记位向量中得到了标记，因此 block 2 中的第一个存活对象将被移动到堆中的第 7 个槽中，对应 offset [ 2(block) ] = 7, old 对象在 block 2 中的偏移 offsetInBlock(old) = 3, 那么 old 对象的转发地址就等于 offset[2] +  offsetInBlock(old) = 10。</p>
<p>单次遍历算法的流程如下：</p>
<ol>
<li>根据标记过程中得到的标记位向量，计算偏移向量；</li>
<li>从头到尾遍历堆，根据标记位向量和偏移向量，计算出对象的转发地址，进行对象的移动或指针的更新。</li>
</ol>
<p>单次遍历算法伪代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">compact():</span><br><span class="line">    computeLocations(HeapStart, HeapEnd, HeapStart)     /* 计算偏移向量 */</span><br><span class="line">    updateReferencesRelocate(HeapStart, HeapEnd)        /* 更新转发地址和移动对象 */</span><br><span class="line"></span><br><span class="line">/* 计算偏移向量 */</span><br><span class="line">computeLocations(start, end, toRegion)</span><br><span class="line">    loc = toRegion</span><br><span class="line">    block = getBlockNum(start)  /* 得到指针所在块的索引 */</span><br><span class="line">    for b = 0 to numBits(start, end) - 1    /* 遍历标记位向量 */</span><br><span class="line">        if b % BITS_IN_BLOCK == 0   /* 是否跨越了块边界 */</span><br><span class="line">            offset[block] = loc     /* 存放块中第一个对象的地址 loc */</span><br><span class="line">            block = block + 1</span><br><span class="line">        if bitmap[b] = MARKED</span><br><span class="line">            loc = loc + BYTES_PER_BIT   /* 根据存活对象的大小移动 */</span><br><span class="line"></span><br><span class="line">/* 计算转发地址 */</span><br><span class="line">newAddress(old):</span><br><span class="line">    block = getBlockNum(old)</span><br><span class="line">    return offset[lock] + offsetInBlock(old)    /* 转发地址的公式 */</span><br><span class="line"></span><br><span class="line">updateReferencesRelocate(start, end):</span><br><span class="line">    for each fld in Roots</span><br><span class="line">        ref = *fld</span><br><span class="line">        if ref != null</span><br><span class="line">            *fld = newAddress(ref)</span><br><span class="line">    scan = start</span><br><span class="line">    while scan &lt; end</span><br><span class="line">        scan = nextMarkedObect(scan)    /* 使用位图 */</span><br><span class="line">        for each fld in Pointers(scan)  /* 更新引用 */</span><br><span class="line">            ref = *fld</span><br><span class="line">            if ref != null</span><br><span class="line">                *fld = newAddress(ref)</span><br><span class="line">        dest = newAddress(scan)</span><br><span class="line">        move(scan, dest)</span><br></pre></td></tr></table></figure></p>
<h2 id="3-复制式回收算法"><a href="#3-复制式回收算法" class="headerlink" title="3. 复制式回收算法"></a>3. 复制式回收算法</h2><p>相对于标记 - 整理算法，复制式回收算法，可以有效提供内存分配的效率，同时回收过程只需要遍历堆一次，其缺点是堆的可用空间降低了一半。基本的复制式回收器将堆划分为两个大小相等的半区（semispace），分别是来源空间（fromspace）和目标空间（tospace），为了简化，我们假定堆是一块连续的内存空间。当堆空间足够时，在目标空间中分配新对象的方法是根据对象的大小简单地增加空闲空间，如果可用空间不足，则进行垃圾回收。回收器先两个半区角色进行切换，然后将存活对象从来源空间得到到目标空间。在回收完成之后，所有存活对象将紧密排布在目标空间的一端。在下一轮回收之前，回收器将简单地丢弃来源空间（为了安全起见，可以作清零处理）。</p>
<p>复制式回收算法的流程如下：</p>
<ol>
<li>初始化工作列表（栈结构），将复制完成但未扫描的对象（灰色对象）放入工作列表，列表为空表示结束；</li>
<li>从根集合开始，将根对象复制到目标空间，在原有对象中设置转发地址，即目标空间的新地址，并将根对象放入工作列表中，原对象中是否有转发地址是判断复制是否完成的依据；</li>
<li>从工作列表中取出灰色对象，扫描其指针域，将指针指向的对象复制到目标空间中，设置转发地址，并加入工作列表；</li>
<li>重复第 3 步操作，直到工作列表为空。</li>
</ol>
<p>Cheney 扫描（Cheney scanning）算法是一种十分优雅的算法，该算法复用目标空间中的灰色对象实现栈的结构，它仅需要一个指针 scan 为指向下一个待扫描对象，除此之外不再需要任何额外空间。结束的标志是指针 scan 和指针 free 重合。</p>
<p>下面是一个 Cheney 扫描对象 L 的实例，该对象是链表结构的头结点，它包含指向表头和表尾的指针。<br><img src="/images/gc/cheney-scanning-init.jpg" alt="cheney-scanning-init" title="cheney-scanning-init"><br>初始状态，所有对象都在来源空间。</p>
<p><img src="/images/gc/cheney-scanning-1.jpg" alt="cheney-scanning-1" title="cheney-scanning-1"><br>复制根对象，使用原对象的头部存放转发地址。</p>
<p><img src="/images/gc/cheney-scanning-2.jpg" alt="cheney-scanning-2" title="cheney-scanning-2"><br>扫描根对象副本 L’ 的指针域，复制 A、E 对象到目标空间，扫描结束，根对象副本 L’ 出栈，继续对 A 对副本 A’ 象进行扫描。</p>
<p><img src="/images/gc/cheney-scanning-3.jpg" alt="cheney-scanning-3" title="cheney-scanning-3"><br>扫描对象 C 副本 C’</p>
<p><img src="/images/gc/cheney-scanning-4.jpg" alt="cheney-scanning-4" title="cheney-scanning-4"><br>扫描对象 D 副本 D’，此时 scan = free，说明回收结束。</p>
<p>复制式回收算法伪代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">/* 创建半区 */</span><br><span class="line">createSemispaces():</span><br><span class="line">    tospace = HeapStart</span><br><span class="line">    extent = ( HeapEnd - HeapStart ) / 2</span><br><span class="line">    top = fromspace = HeapStart + extent</span><br><span class="line">    free = tospace</span><br><span class="line"></span><br><span class="line">/* 分配内存 */</span><br><span class="line">allocate(size):</span><br><span class="line">    result = free</span><br><span class="line">    newfree = result + size</span><br><span class="line">    if newfree &gt; top</span><br><span class="line">        return null     /* 内存耗尽 */</span><br><span class="line"></span><br><span class="line">    free = newfree</span><br><span class="line">    return result</span><br><span class="line"></span><br><span class="line">/* 内存整理 */</span><br><span class="line">collect():</span><br><span class="line">    flip()  /* 切换来源空间和目标空间 */</span><br><span class="line">    initialise(worklist)    /* 将工作列表初始化为空 */</span><br><span class="line">    </span><br><span class="line">    for each fld in Roots   /* 复制根 */</span><br><span class="line">        process(fld)</span><br><span class="line">    </span><br><span class="line">    while not isEmpty(worklist)</span><br><span class="line">        ref = remove(worklist)</span><br><span class="line">        scan(ref)</span><br><span class="line"></span><br><span class="line">/* 翻转半区 */</span><br><span class="line">flip():</span><br><span class="line">    tmp = fromsapce</span><br><span class="line">    fromspace = tospace</span><br><span class="line">    tospace - tmp</span><br><span class="line"></span><br><span class="line">    top = tospace + extent</span><br><span class="line">    free = tospace</span><br><span class="line"></span><br><span class="line">scan(ref):</span><br><span class="line">    for each fld in Pointers(ref)</span><br><span class="line">        process(fld)</span><br><span class="line"></span><br><span class="line">/* 使用目标空间中新副本的地址来更新域 */</span><br><span class="line">process(fld):</span><br><span class="line">    fromRef = *fld</span><br><span class="line">    if fromRef != null</span><br><span class="line">        *fld = forward(fromRef)     /* 使用目标空间中新副本的地址来更新 */</span><br><span class="line">    </span><br><span class="line">forward(fromRef):</span><br><span class="line">    toRef = forwardingAddress(fromRef)</span><br><span class="line">    if toRef = null     /* 尚未得到复制（尚未标记） */</span><br><span class="line">        toRef = copy(fromRef)</span><br><span class="line">    </span><br><span class="line">    return toRef</span><br><span class="line"></span><br><span class="line">/* 复制对象，返回转发地址 */</span><br><span class="line">copy(fromRef):</span><br><span class="line">    toRef = free</span><br><span class="line">    free = free + size(fromRef)</span><br><span class="line">    move(fromRef, toRef)</span><br><span class="line">    forwardingAddress(fromRef) = toRef  /* 标记 */</span><br><span class="line">    add(worklist, toRef)</span><br><span class="line">    return toRef</span><br><span class="line"></span><br><span class="line">/* 使用 Cheney 工作列表进行复制 */</span><br><span class="line">initialise(worklist):</span><br><span class="line">    scan = free</span><br><span class="line"></span><br><span class="line">isEmpty(worklist):</span><br><span class="line">    return scan = free</span><br><span class="line"></span><br><span class="line">remove(worklist):</span><br><span class="line">    ref = scan</span><br><span class="line">    scan = scan + size(scan)</span><br><span class="line">    return ref</span><br><span class="line"></span><br><span class="line">add(worklist, ref):</span><br><span class="line">    /* 空 */</span><br></pre></td></tr></table></figure></p>
<h2 id="4-引用计数算法"><a href="#4-引用计数算法" class="headerlink" title="4. 引用计数算法"></a>4. 引用计数算法</h2><p>上面讲到的三种垃圾回收算法都是间接式的，它们需要从已知的根集合出发对存活对象进行遍历，进而才能确定所有的存活对象。而在引用计数算法中，对象的存活性可以通过引用关系的创建或删除直接判定，无须像上面的三种追踪式回收器那样先通过堆遍历找出所有的存活对象，然后再反向确定出未遍历到的垃圾对象。<br>引用计数算法判断一个对象是否回收的依据是：当且仅当指向某个对象的引用数量大于零时，该对象才有可能是存活的。在引用计数算法中，每个对象都需要与一个引用计数相关联，这一计数通常保存在对象头部的某个槽中。下面是一个简单的引用计数算法，Write方法用于增加新目标对象的引用计数，同时减少旧目标对象的引用计数。对象执行读写操作时，需要维护其关联的引用计数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">New():</span><br><span class="line">    ref = allocate()</span><br><span class="line">    if ref = null</span><br><span class="line">        error &quot;Out of memory&quot;</span><br><span class="line">    rc(ref) = 0     /* 初始化计数 */</span><br><span class="line">    return ref</span><br><span class="line"></span><br><span class="line">Write(src, i, ref):</span><br><span class="line">    addReference(ref)</span><br><span class="line">    deleteReference(src[i])</span><br><span class="line">    src[i] = ref</span><br><span class="line"></span><br><span class="line">addReference(ref):</span><br><span class="line">    if ref != null</span><br><span class="line">        rc(ref) = rc(ref) + 1</span><br><span class="line"></span><br><span class="line">deleteReference(ref):</span><br><span class="line">    if ref != null</span><br><span class="line">        rc(ref) = rc(ref) - 1</span><br><span class="line">    if rc(ref) = 0</span><br><span class="line">        for each fld in Pointers(ref)</span><br><span class="line">            deleteReference(*fld)</span><br><span class="line">        free(ref)</span><br></pre></td></tr></table></figure></p>
<p>引用计数算法将内存管理开销分摊在程序运行过程中，无须停顿程序便可对内存进行整理，也不用为回收器预留一定空间。另外一方面也不需要运行时系统的支持，以库的形式就可以支持内存的回收，如 C++ 的智能指针就是使用引用计数来实现内存的自动管理。除了这些优点，引用计数算法同样存在一些缺陷：1）引用计数给赋值操作带来了额外的时间开销，因为需要维护引用计数；2）引入多线程竞争的问题，引用计数的增减操作以及加载和存储指针的操作必须是原子化的；3）读操作会引发计数器的更新操作，会“污染”高速缓存；4）引用计数无法回收环状引用数据结构；5）引用计数会占用额外的存储空间。</p>
<p>注：环状垃圾回收的问题，一般需要引入停顿程序的方式来解决。</p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>本篇文章分析了四种基本的垃圾回收算法，它们分别有不同的使用场景：</p>
<ol>
<li>标记 - 清扫： 算法简单，适合于分配固定大小对象的场景；</li>
<li>标记 - 整理： 需要遍历堆多次或引入额外的数据结构来记录转发地址，算法较复杂，优势是可以解决内存碎片的问题，内存利用率较高；</li>
<li>复制式回收算法 ： 内存分配速度及效率较高，缺点是堆的可用空间降低了一半；</li>
<li>引用计数：内存管理的开销分摊到程序运行期间，不需要运行时系统的支持，但需要解决环状引用的问题。</li>
</ol>
<p><strong>参考：</strong></p>
<hr>
<p><a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection" target="_blank" rel="noopener">1. Tracing garbage collection</a><br><a href="https://book.douban.com/subject/26740958/" target="_blank" rel="noopener">2. 垃圾回收算法手册——自动内存管理的艺术</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/12/mind-mapping-insurance-1/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/07/12/mind-mapping-insurance-1/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">思维导图-保险知识-1</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-07-12 10:10:10" itemprop="dateCreated datePublished" datetime="2020-07-12T10:10:10+08:00">2020-07-12</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-08-04 13:53:40" itemprop="dateModified" datetime="2020-08-04T13:53:40+08:00">2020-08-04</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/思维导图/" itemprop="url" rel="index"><span itemprop="name">思维导图</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">278</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">1 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>之前给小孩和自己买保险走了一些弯路，特意研究了保险的品种及保障的作用，用思维导图做了一个总结，权当是笔记吧。</p>
<p><img src="/images/insurance.jpeg" alt="insurance" title="insurance"></p>
<p><strong>参考：</strong></p>
<hr>
<p><a href="https://book.douban.com/subject/30302000/" target="_blank" rel="noopener">1. 你的第一本保险指南</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/14/java-memory-model/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/06/14/java-memory-model/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">Java 内存模型</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-06-14 20:36:17" itemprop="dateCreated datePublished" datetime="2020-06-14T20:36:17+08:00">2020-06-14</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-08-04 13:53:40" itemprop="dateModified" datetime="2020-08-04T13:53:40+08:00">2020-08-04</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/Java基础/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">9.7k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">9 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>处于优化的目的，在不同的编译器及不同体系架构的cpu 中，会将指令重排，即程序中排在后面的指令有可能比排在前面的指令先执行。同时由于cpu 中存在读写缓冲区，会将指令相关的运行时数据暂存在这些缓冲区中，也会导致指令重排的问题。目前的cpu 都是多核的体系架构，同一个语言编写的程序在不同硬件体系中，在多线程执行环境下，多次执行的结果可能不一致。在Java 中，怎么解决这个问题？为了屏蔽不同硬件架构的差异，给程序员提供一致的运行结果，Java 提出了 JMM(内存模型)的概念。</p>
<p>Java 内存模型（JMM）描述了在Java 语言中线程如何与主内存（Main Memory）进行交互，定义了一套线程对共享变量的访问规则，同时决定一个线程对共享变量的写入何时对另外一个线程可见。</p>
<p>在Java 中，共享变量主要包括实例字段、静态字段和数组元素，这些变量存储在堆内存中，由所有线程共享。而局部变量、方法参数和异常处理参数不会在线程间共享，不存在可见性（一个线程对变量的写入对另外的线程可见）的问题，不受内存模型的的影响。</p>
<p>从抽象的角度来看，JMM 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local memory），本地内存中存储了该线程读/写共享变量的副本。本地内存是JMM 的一个抽象概念，并不真实存在，它涵盖了缓存、写缓存区、寄存器以及其它硬件。JMM 抽象示意图如下所示：<br><img src="/images/JMM.jpg" alt="JMM" title="JMM"></p>
<p>从上图来看，线程A与线程B要进行通过的话，必须要经历两个步骤：</p>
<ol>
<li>首先，线程A将在本地内存中修改的共享变量刷新到主内存中；</li>
<li>最后，线程B重新从主内存加载修改后的共享变量，从而看到被修改后的内容。</li>
</ol>
<p>本质上来说，JMM 通过控制主内存与每个线程的本地内存之间的交互，来提供内存可见性的保证。</p>
<h2 id="2-重排序"><a href="#2-重排序" class="headerlink" title="2. 重排序"></a>2. 重排序</h2><p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：</p>
<ol>
<li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li>
<li>指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>
<li>内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。<br>从java源代码到最终实际执行的指令序列，会分别经历下面三种重排序：<br><img src="/images/java-instruction-reorder.png" alt="java-instruction-reorder" title="java-instruction-reorder"></li>
</ol>
<p>上述的1属于编译器重排序，2和3属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM的处理器重排序规则会要求java编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel称之为memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。<br>JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</p>
<h2 id="3-内存系统重排序"><a href="#3-内存系统重排序" class="headerlink" title="3. 内存系统重排序"></a>3. 内存系统重排序</h2><p>现代处理器与内存存在较大的性能差异，以主频为3GHZ的cpu为例，cpu访问一次内存时间在10~100ns内，但cpu  在100ns内可以执行1200条指令（假定一个时钟周期可以同时执行4条指令，一个时间周期为0.3ns）。因此，现代处理器在内存之间引入了多级的缓存结构，同时为了提高指令的执行效率，在cpu 寄存器与缓存之间引入了读/写缓冲区。写缓冲区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟。同时，通过以批处理的方式刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写，可以减少对内存总线的占用。读缓冲区可以缓存当前指令读取的数据，实现cpu异步读取数据，提高cpu的吞吐率。以Intel x86 CPU （2012 Sandy Bridge）为例，如下图所示：<br><img src="/images/memory-heirarchy.png" alt="memory-heirarchy" title="memory-heirarchy"><br>其内部组成包括：</p>
<ol>
<li>寄存器：在每个cpu 核心上，有160个用于整数和144个用于浮点的寄存器单元。访问这些寄存器只需要一个时钟周期，这构成了对执行核心来说最快的内存。编译器会将本地变量和函数参数分配到这些寄存器上。当使用超线程技术（ hyperthreading ）时，这些寄存器可以在超线程协同下共享。</li>
<li>读写缓冲区：读写缓存区包含64个load 缓冲条目和36个的store 缓冲条目。这些缓冲区用于记录等待缓存子系统时正在执行的操作。store 缓冲区保存将要写到L1 缓存的数据。load 缓冲区保存正要被寄存器读取的数据。由于读/写缓存仅对当前cpu 核心可见，这会造成指令的重排序，需要通过内存屏障来保证其执行顺序。</li>
<li>L1 &amp; L2 缓存：L1和L2 是一个本地核心内的缓存，它们在大小和速度上存在差异。</li>
<li>L3 缓存： 同插槽的所有cpu 核心共享L3缓存。L3缓存被分为多个2MB的段，所有段组成一环形网络。每一个核心都连接到这个环形网络上，地址通过hash的方式映射到段上以达到更大的吞吐量。</li>
<li>主内存：在缓存没命中的情况下，内存的平均延迟为65ns。</li>
<li>NUMA：在一个多插槽的服务器上，会使用非一致性内存访问机制（ non-uniform memory access ）。之所以要使用该方式主要是因为需要的数据在另外一个远程插槽上，需要跨越QPI 总线且额外花费40ns。 </li>
</ol>
<p>在上文讲到的多级缓存系统中，L1,L2,L3级缓存与主内存之间一致性一般是通过Cache Conherence技术来实现的，Intel 使用MESIF协议，AMD 使用 MOESI，在这里不再描述，我们假定：一旦内存数据被推送到L1 缓存，就会有消息协议来确保所有的缓存会对所有的共享数据同步并保持一致。</p>
<p>现在我们来分析引入读写缓冲区带来的问题，先看下两者的作用：</p>
<blockquote>
<p>When a store is issued to the out-of-order core for renaming and scheduling, an entry in the store buffer is allocated (in-order) for the address and the data. The store buffer will hold the address and data until the instruction has retired and the data has been written to the L1 cache.</p>
</blockquote>
<blockquote>
<p>Analogously, when a load is issued, an entry in the load buffer is reserved for the address. However, loads must also compare the load address against the contents of the entire store buffer to check for aliasing with older stores. If the load address matches an older store, then the load must wait for the older store to complete to preserve the dependency. Most x86 processors optimize this further, by allowing the store to forward data to the load without accessing the cache. The load buffer entry can be released, once the instruction has retired and the load data is written into the register file.</p>
</blockquote>
<blockquote>
<p>Because of the strong x86 ordering model, the load buffer is snooped by coherency traffic. A remote store must invalidate all other copies of a cache line. If a cache line is read by a load, and then invalidated by a remote store, the load must be cancelled, since it potentially read invalid data. The x86 memory model does not require snooping the store buffer.</p>
</blockquote>
<p>其要点包括：1）写缓冲区缓存指令的地址及数据信息，直到指令执行完毕且数据写入到L1 缓存中，写入到L1 缓存中之后，会通过MESIF协议通知其它cpu 核心失效相关的缓存行；2）读缓冲区按照地址缓存数据，直到指令执行完毕且数据被读到寄存器中；2）读缓冲区缓存了来自L1 缓存的数据，所以受MESIF协议的侦测，如果数据被其它远程的写缓冲区修改，根据MESIF协议，它会失效所有的数据拷贝，包括读缓冲区中的数据。</p>
<p>由于读写缓冲区只对当前cpu 核心有效，会造成指令重排的问题，要解决这个问题，需要引入“内存屏障”的技术。内存屏障提供了两个功能。首先，它们通过确保从另一个cpu 来看屏障的两边的所有指令都是正确的程序顺序，而保持程序顺序的外部可见性；其次它们可以实现内存数据可见性，确保内存数据会同步到cpu L1。</p>
<p><strong>Store Barrier</strong><br>Store 屏障，是x86的”sfence“ 指令，强制所有在store 屏障指令之前的store 指令，都在该store 屏障指令执行之前被执行，并把store 缓冲区的数据都刷到L1 ，这会使得程序状态对其它cpu 可见。</p>
<p><strong>Load Barrier</strong><br>Load 屏障，是x86 上的”ifence“ 指令，强制所有在load 屏障指令之后的load 指令，都在该load 屏障指令执行之后被执行，并且一直等到load 缓冲区被该cpu 读完才能执行之后的load 指令。这使得从其它cpu 暴露出来的程序状态对该cpu 可见，这之后cpu 可以进行后续处理。</p>
<p><strong>Full Barrier</strong><br>Full 屏障，是x86 上的”mfence“ 指令，复合了load 和save 屏障的功能。</p>
<h2 id="4-编译器重排序"><a href="#4-编译器重排序" class="headerlink" title="4. 编译器重排序"></a>4. 编译器重排序</h2><p><strong>数据依赖性</strong><br>如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。数据依赖分下列三种类型：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>代码示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>写后读</td>
<td>a = 1;b = a;</td>
<td>写一个变量之后，再读这个位置</td>
</tr>
<tr>
<td>写后写</td>
<td>a = 1;a = 2;</td>
<td>写一个变量之后，再写这个变量</td>
</tr>
<tr>
<td>读后写</td>
<td>a = b;b = 1;</td>
<td>读一个变量之后，再写这个变量</td>
</tr>
</tbody>
</table>
<p>上面三种情况，只要重排序两个操作的执行顺序，程序的执行结果将会被改变。</p>
<p>前面提到过，编译器和处理器可能会对操作做重排序。编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序</p>
<p><strong>as-if-serial 语义</strong><br>as-if-serial 语义的意思指：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守 as-if-serial 语义。</p>
<p>为了遵守 as-if-serial 语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作可能被编译器和处理器重排序。</p>
<h2 id="5-JMM内存屏障"><a href="#5-JMM内存屏障" class="headerlink" title="5. JMM内存屏障"></a>5. JMM内存屏障</h2><p>为了保证内存可见性，Java 编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。JMM把内存屏障指令分为下列四类：</p>
<table>
<thead>
<tr>
<th>屏障类型</th>
<th>指令示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>LoadLoad Barriers</td>
<td>Load1; LoadLoad; Load2</td>
<td>确保Load1数据的装载，之前于Load2及所有后续装载指令的装载。</td>
</tr>
<tr>
<td>StoreStore Barriers</td>
<td>Store1; StoreStore; Store2</td>
<td>确保Store1数据对其他处理器可见（刷新到内存），<br>之前于Store2及所有后续存储指令的存储。</td>
</tr>
<tr>
<td>LoadStore Barriers</td>
<td>Load1; LoadStore; Store2</td>
<td>确保Load1数据装载，之前于Store2及所有后续<br>的存储指令刷新到内存。</td>
</tr>
<tr>
<td>StoreLoad Barriers</td>
<td>Store1; StoreLoad; Load2</td>
<td>确保Store1数据对其他处理器变得可见（指刷新到内存），<br>之前于Load2及所有后续装载指令的装载。StoreLoad Barriers <br>会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，<br>才执行该屏障之后的内存访问指令。</td>
</tr>
</tbody>
</table>
<p>StoreLoad Barriers是一个“全能型”的屏障，它同时具有其他三个屏障的效果。现代的多处理器大都支持该屏障（其他类型的屏障不一定被所有处理器支持）。执行该屏障开销会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中（buffer fully flush）。</p>
<p><strong>JMM 内存屏障与cpu 内存屏障的映射</strong><br>在不同cpu 架构中，实现的内存屏障是不同的，如上面的X86体系中，只允许StoreLoad指令重排，所以只用实现StoreLoad Barriers，而其它cpu 体系则有所不同，其对应关系如下图所示：<br><img src="/images/cpu-barriers-map-jmm.png" alt="cpu-barriers-map-jmm" title="cpu-barriers-map-jmm"></p>
<p>由于常见的cpu 内存屏障比 JMM 要弱，java 编译器在生成字节码时，会在执行指令序列的适当位置插入内存屏障来限制处理器的重排序。同时，由于各种处理器内存屏障的强弱并不相同，为了在不同的处理器平台向程序员展示一个一致的内存模型，JMM 在不同的处理器中需要插入的内存屏障的数量和种类也不相同。</p>
<h2 id="6-happen-before"><a href="#6-happen-before" class="headerlink" title="6. happen-before"></a>6. happen-before</h2><p>JMM 使用happens-before 的概念来阐述操作之间的内存可见性，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before 关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。<br>与程序员密切相关的happens-before 规则如下：</p>
<ol>
<li>程序顺序规则：一个线程中的每个操作，happens-before 于该线程中的任意后续操作。</li>
<li>监视器锁规则：对一个监视器锁的解锁，happens-before 于随后对这个监视器锁的加锁。</li>
<li>volatile变量规则：对一个volatile域的写，happens-before 于任意后续对这个volatile域的读。</li>
<li>传递性：如果A happens- before B，且B happens- before C，那么A happens- before C。</li>
</ol>
<p>注意，两个操作之间具有happens-before关系，并不意味着前一个操作必须要在后一个操作之前执行！happens-before 仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前（the first is visible to and ordered before the second）。<br>happens-before与JMM的关系如下图所示：<br><img src="/images/happens-before.png" alt="happens-before" title="happens-before"></p>
<h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><p>通过JMM 模型的定义，使得Java语言真正实现了跨平台，在不同平台，多线程的执行总能得到一致的结果，同时定义happens-before 规则，简化了对JMM 理解难度。</p>
<p><strong>参考：</strong></p>
<hr>
<p><a href="https://www.infoq.cn/article/java-memory-model-1/" target="_blank" rel="noopener">1. 深入理解 Java 内存模型（一）——基础</a><br><a href="https://www.infoq.cn/article/java-memory-model-2/" target="_blank" rel="noopener">2. 深入理解 Java 内存模型（二）——重排序</a><br><a href="https://download.oracle.com/otn-pub/jcp/memory_model-1.0-pfd-spec-oth-JSpec/memory_model-1_0-pfd-spec.pdf?AuthParam=1593252270_c3d47e052ce05eb43eb35a8c96217567" target="_blank" rel="noopener">3. SR-133: JavaTM Memory Model and Thread Specification</a><br><a href="https://www.realworldtech.com/haswell-tm-alt/2/" target="_blank" rel="noopener">4. Haswell Transactional Memory Alternatives</a><br><a href="http://ifeve.com/cpu-cache-flushing-fallacy/" target="_blank" rel="noopener">5. CPU Cache Flushing Fallacy</a><br><a href="http://ifeve.com/memory-barriersfences/" target="_blank" rel="noopener">6. Memory Barriers/Fences</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/24/database-transaction/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/05/24/database-transaction/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">数据库事务</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-05-24 12:55:17" itemprop="dateCreated datePublished" datetime="2020-05-24T12:55:17+08:00">2020-05-24</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-08-04 13:53:40" itemprop="dateModified" datetime="2020-08-04T13:53:40+08:00">2020-08-04</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/数据库/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">15k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">13 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在数据库技术中，事务将应用程序的多个读、写操作捆绑在一起成为一个逻辑操作单元。即事务中的所有读写是一个执行的整体，整个事务要么成功（提交）、要么失败（中止或回滚）。如果失败，应用程序可以安全地重试。这样，由于不需要担心部分失败的情况（无论出于何种原因），应用层的错误处理就变得简单得多。</p>
<h2 id="1-ACID的含义"><a href="#1-ACID的含义" class="headerlink" title="1. ACID的含义"></a>1. ACID的含义</h2><p>事务提供了四个方面的安全保证，即ACID，分别代表原子性（Atomicity），一致性（Consistency），隔离性（Isolation）与持久性（Durability）。</p>
<h3 id="1-1-原子性"><a href="#1-1-原子性" class="headerlink" title="1.1 原子性"></a>1.1 原子性</h3><p>ACID原子性描述了客户端发起一个包含多个写操作的请求时可能发生的情况，例如在完成了一部分写入后，系统发生了故障，包括进程崩溃，网络中断，磁盘变满或者违反了某种完整性约束等；把多个写操作纳入到一个原子事务，万一出现了上述故障而导致没法完成最终提交时，则事务会中止，并且数据库丢弃或撤销那些局部完成的操作。<br>ACID原子性所定义的特征是：在出错时中止事务，并将部分完成的写入全部丢弃。它强调一个可中止性的概念。</p>
<h3 id="1-2-一致性"><a href="#1-2-一致性" class="headerlink" title="1.2 一致性"></a>1.2 一致性</h3><p>ACID中的一致性主要是指对数据有特定的预期状态，任何数据更改必须满足这些状态约束（或者恒等条件）。例如，对于一个账单系统，账户的贷款余额应和借款余额保持平衡。如果某事务从一个有效的状态开始，并且事务中任何更新操作都没有违背约束，那么最后的结果依然符合有效状态。<br>这种一致性本质上要求应用层来维护状态一致（或者恒等），应用程序有责任正确地定义事务来保持一致性。这不是数据库可以保证的事情：即如果提供的数据违背了恒等条件，数据库很难检测进而阻止该操作（数据库可以完成针对某些特定类型的恒等约束检查，例如使用外键约束或唯一性约束。但通常主要靠应用程序定义数据的有效/无效状态，数据库主要用于存储）。<br>原子性，隔离性和持久性是数据库自身的属性，而ACID中的一致性更多是应用层的属性。应用程序可能借助数据库提供的原子性和隔离性，以达到一致性，但一致性本身并不源于数据库。因此，也有一种说法，字母C其实并不应该属于ACID。</p>
<h3 id="1-3-隔离性"><a href="#1-3-隔离性" class="headerlink" title="1.3 隔离性"></a>1.3 隔离性</h3><p>ACID语义中的隔离性意味着并发执行的多个事务相互隔离，它们不能互相交叉，主要是指多个事务中对相同记录读写操作进行隔离。</p>
<h3 id="1-4-持久性"><a href="#1-4-持久性" class="headerlink" title="1.4 持久性"></a>1.4 持久性</h3><p>数据库系统本质上是提供一个安全可靠的地方来存储数据而不用担心数据丢失等。持久性它保证一旦事务提交成功，即使存在硬件故障或数据库崩溃，事务所写入的任何数据也不会消失。</p>
<p>在ACID中，原子性，隔离性和持久性是数据库自身的属性，其中原子性和持久性，我们能修改的地方不多，所以后面的内容主要关注隔离性相关的内容。</p>
<h2 id="2-隔离性"><a href="#2-隔离性" class="headerlink" title="2. 隔离性"></a>2. 隔离性</h2><p>隔离性主要是解决多个事务对相同数据或关联数据同时进行读写引发的问题，这些问题包括脏读、脏写、不可重复读及幻读。</p>
<h3 id="2-1-脏读"><a href="#2-1-脏读" class="headerlink" title="2.1 脏读"></a>2.1 脏读</h3><p><strong>定义：一个事务读取了另外一个事务未提交的数据，主要是并发读的问题。</strong></p>
<p>假定某个事务已经完成部分数据写入，但事务尚未提交（或中止），此时另一个事务可以看到尚未提交的数据，如图所示：<br><img src="/images/dirty-read.jpg" alt="dirty-read" title="dirty-read"><br>事务1设置了x=3，在事务1未提交之前，事务2的get x操作返回了3。没有脏读时，事务2只有在事务1的事务提交之后才能看到x的新值。</p>
<p>当有以下需求时，需要防止脏读：</p>
<ul>
<li>如果事务需要更新多个对象，脏读意味着另一个事务可能会看到部分更新，而非全部。</li>
<li>如果事务发生中止，则所有写入操作都需要回滚。如果发生了脏读，这意味着它可能会看到一些稍后被回滚的数据，而这些数据并未实际提交到数据库中。之后所引发的后果可能会变得难以预测。</li>
</ul>
<h3 id="2-2-脏写"><a href="#2-2-脏写" class="headerlink" title="2.2 脏写"></a>2.2 脏写</h3><p><strong>定义：一个事务覆盖了另外一个事务未提交的数据更新，主要是对同一份数据进行并发更新的问题。</strong></p>
<p>如果两个事务同时尝试更新相同的对象，会发生什么情况?我们不清楚写入的顺序，但可以想象后写的操作会覆盖较早的写入。如果先前的写入是尚未提交事务的一部分，是否还会被覆盖？如果是，那就是脏写。<br>如果事务需要更新多个对象，脏写会带来非预期的错误结果，例如Alice和Bob两个人试图购买同一辆车，而购买洗车需要两次数据的写入：商品买主需要更新，同时发票也要更新。如下图所示，车主被改为Bob（他成功更新了商品数据），而Alice成功更新了发票信息，导致了业务数据的不一致。<br><img src="/images/dirty-write.jpg" alt="dirty-write" title="dirty-write"></p>
<h3 id="2-3-隔离级别-读提交"><a href="#2-3-隔离级别-读提交" class="headerlink" title="2.3 隔离级别-读提交"></a>2.3 隔离级别-读提交</h3><p>读-提交是数据库中比较流行的事务隔离级别，它提供以下两个保证：</p>
<ul>
<li>读数据库时，只能看到已成功提交的数据，防止脏读；</li>
<li>写数据库时，只会覆盖已成功提交的数据，防止脏写。</li>
</ul>
<p>数据库通常使用行级锁来防止脏写：当事务想修改某个对象（例如行或文档）时，它必须首先获得该对象的锁；然后一直持有锁直到事务提交（或中止）。给定时刻，只有一个事务可以拿到特定对象的锁，如果有另一个事务尝试更新同一个对象，则必须等待，直到前面的事务完成了提交（或中止）后，才能获得锁并继续。<br>数据库了为防止脏读，一般使用读锁，或者对于每一个待更新的对象，数据库都会维护数据的两个版本：1）旧值的版本；2）当前事务最新的版本。在事务提交之前，所有其它读操作都读取旧值；仅当写事务提交之后，才会切换到读取最新的值。</p>
<h3 id="2-4-不可重复读"><a href="#2-4-不可重复读" class="headerlink" title="2.4 不可重复读"></a>2.4 不可重复读</h3><p><strong>定义：在同一个事务中，同一个查询操作重复多次执行，返回结果不一样，主要是并发读的问题。</strong></p>
<p>不可重复读出现在一个事务中，在同一个查询操作执行多次操作的期间，另外一个事务对相同数据对象进行更新操作并成功提交事务，导致提交前后的数据不同。如下图所示，在读提交隔离级别下不能解决不可重复读的问题。<br><img src="/images/non-repeatable-read.jpg" alt="non-repeatable-read" title="non-repeatable-read"></p>
<p>假设Alice在银行有1000美元的存款，分为两个账户，每个500美元。现在有这样一笔转账交易从账户1转账户2。如果在她提交转账请求之后而数据库系统执行转账的过程中间，来查看两个账户的余额，她有可能会看到账户1在收到转账之前的余额（500美元），和账户2在完成转账之后的敌众余额（400美元）。对于Alice来说，貌似她的账户总共有900美元，而不是1000美元。</p>
<p>在上面的场景中，主要是一个事务跨越了另外一个事务，读取到了另外一个事务前后更新的数据，导致了数据的不一致性。为了解决这个问题，数据库引入了多版本并发控制（Multivesion Concurrency Control,MVCC），这种技术保留了数据对象多个不同的提交版本。</p>
<p>提供MVCC技术的隔离级别称为快照隔离级别，在MYSQL中也叫可重复读隔离级别，我们在这里统一叫快照隔离级别。在快照隔离级别中，脏写也是通过行锁来实现的，而脏读的实现也比较简单，直接基于MVCC来实现。</p>
<p>以PostgreSQL（或Mysql）中的MVCC实现为例。当事务开始时，首先赋予一个唯一的、单调递增的事务ID(txid)。每当事务向数据库写入新内部时，所写的数据都会被标记写入者的事务ID，如下图所示：<br><img src="/images/mvcc.jpg" alt="mvcc" title="mvcc"><br>表中的每一行都有一个created_by字段，其中包含了创建该行的事务ID。每一行还有一个deleted_ty字段，初始为空。如果事务要删除某行，该行实际上并未从数据库中删除，而只是将deleted_ty字段设置为请求删除的事务ID（仅仅标记为删除）。事后，当确定没有其它事务引用该标记删除的行时，数据库的垃圾回收进程才去真正删除并释放存储空间。</p>
<p>一次更新操作在内部会转换为一个删除操作加一个创建操作。例如，事务13从账户2中扣除100元，余额从500美元减为400美元，在account表里会出现现两行：一个余额为500但标记为删除的行（由事务13删除），另一个余额为400，由事务13创建。</p>
<p>当事务读数据库时，通过事务ID可以决定哪些对象可见，哪些不可见。通常情况下，仅当以下两个条件都成立，则该数据对象对事务可见：</p>
<ul>
<li>事务开始的时刻，创建该对象的事务已经完成了提交；</li>
<li>对象没有被标记为删除；或者即使标记了，但删除事务在当前事务开始时还没有完成提交。</li>
</ul>
<p>如事务12只能看到12之前提交的数据，事务13的更改对于事务12来说是不可见的。</p>
<h3 id="2-5-当前读"><a href="#2-5-当前读" class="headerlink" title="2.5 当前读"></a>2.5 当前读</h3><p>在快照隔离级别下，以下的场景会产生问题：</p>
<ol>
<li>首先输入一些匹配条件，即采用SELECT查询所有满足条件的行（例如，至少有两名医生正在值班，同一时刻房间没有预订）。</li>
<li>根据查询的结果，应用层代码来决定下一步的操作（有可能继续，或者报告错误并中止）。</li>
<li>如果应用程序决定继续执行，它将发起数据库写入（INSERT,UPDATE或DELETE）并提交事务。</li>
</ol>
<p>假定在一个医生管理系统中，医院会安排多个医生值班，医生也可以申请调整班次，但前提是确保至少一个医生还在该班次中值班。现在的情况是，Alice和Bob是两位值班医生，两个人碰巧都感到身体不适，因而都决定请假。如果他们几乎同一个时刻执行了调班的操作，如下图所示：<br><img src="/images/write-tilt.jpg" alt="write-tilt" title="write-tilt"></p>
<p>在数据库使用快照级别隔离，两个检查都返回有两名医生，所以两个事务都安全地进入下一下阶段。接下来，两个事务执行更新操作，调班成功。两个事务都成功提交，最后的结果却是没有任何医生在值班，显然违背了至少一个医生值班的业务需求。</p>
<p>为了解决这个问题，一种可选的方案是对查询的数据行显示加锁，加上for update，如下所示：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> doctors  <span class="keyword">where</span> on_call=<span class="literal">true</span> <span class="keyword">and</span> shift_id=<span class="number">1234</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> doctors  <span class="keyword">set</span> on_call=<span class="literal">false</span>  <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'Alice'</span>  <span class="keyword">and</span> shift_id=<span class="number">1234</span>;</span><br></pre></td></tr></table></figure></p>
<p>在上面的查询语句中，加入了for update，表示对数据行进行加锁，采用的是“当前读”的模式（Mysql数据库），即当前读会读取当前最新提交的数据，即使当前事务落后于最新事务，也能看到最新事务提交后的数据。</p>
<h3 id="2-6-幻读"><a href="#2-6-幻读" class="headerlink" title="2.6 幻读"></a>2.6 幻读</h3><p><strong>定义：在一个事务中的写入（插入）操作改变了另外一个事务查询的结果。</strong></p>
<p>在Mysql中，在快照读（可重复读）隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。幻读只会在“当前读”下才会出现，同时幻读专指“新插入的行”。</p>
<p>假定有如下的表及初始数据：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`d`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`c`</span> (<span class="string">`c`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>),(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>),(<span class="number">15</span>,<span class="number">15</span>,<span class="number">15</span>),(<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>),(<span class="number">25</span>,<span class="number">25</span>,<span class="number">25</span>);</span><br></pre></td></tr></table></figure></p>
<p>现在对该表执行三个事务，如下图所示：<br><img src="/images/multi-transaction.jpg" alt="multi-transaction" title="multi-transaction"></p>
<p>可以看到，事务A里执行了三次查询，分别是 Q1、Q2 和 Q3。它们的 SQL 语句相同，都是 select * from t where d=5 for update。这个语句查询所有d=5的行，使用当前读，并且加上锁，现在来看它们的返回结果：</p>
<ol>
<li>Q1只返回id=5这一行数据；</li>
<li>在T2时刻，事务B修改了id=0这行数据，所以Q2返回id=0和id=5这两行数据；</li>
<li>在T4时刻，事务C插入了新的一行数据，所以Q3返回id=0,id=1及id=5这三行数据。</li>
</ol>
<p>其中，Q3 读到 id=1 这一行的现象，被称为“幻读”。也就是说，幻读指的是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。</p>
<h4 id="2-6-1-幻读引发的问题"><a href="#2-6-1-幻读引发的问题" class="headerlink" title="2.6.1 幻读引发的问题"></a>2.6.1 幻读引发的问题</h4><p>幻读会引入两个问题，一是语义上的问题，事务A已经对d=5的行加了锁，其它事务仍然还可以对d=5的行进行操作，如将其它行的d字段改为5或新插入d=5的行；另外一个问题，会导致数据库数据和日志的不一致，如下图所示：<br><img src="/images/phantom-read-problem.jpg" alt="phantom-read-problemn" title="phantom-read-problem"><br>在数据库中id=5的行，d字段修改为100；id=1的行，d=5,c=5。我们再来看binlog的日志：</p>
<ol>
<li><p>T2时刻，事务C提交之后，写入两行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> c=<span class="number">5</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>T4时刻，事务A提交之后，写入三行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> d=<span class="number">100</span> <span class="keyword">where</span> d=<span class="number">5</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>合在一起之后，日志内容如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> c=<span class="number">5</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> d=<span class="number">100</span> <span class="keyword">where</span> d=<span class="number">5</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure></p>
<p>从执行的语句来看，事务A的update最后执行，导致所有d=5的行，d字段都修改为100，与数据库中的数据不一致。如果使用这个binlog日志进行恢复数据或进行主从备份，会导致数据的前后不一致。</p>
<h4 id="2-6-2-解决的办法"><a href="#2-6-2-解决的办法" class="headerlink" title="2.6.2 解决的办法"></a>2.6.2 解决的办法</h4><p>事务B中的update操作可以通过行锁来解决，但对于事务C的插入操作，由于该行在插入之前根本不存在，不能使用行锁来解决，因此，为了解决幻读问题，InnoDB 引入新的锁，也就是间隙锁 (Gap Lock)。顾名思义，间隙锁，锁的就是两个值之间的空隙。比如文章开头的表 t，初始化插入了 6 个记录，这就产生了 7 个间隙。如下图所示：<br><img src="/images/gap-lock.jpg" alt="gap-lock" title="gap-lock"><br>这样，当执行 <code>select * from t where d=5 for update</code> 的时候，就不止是给数据库中已有的 6 个记录加上了行锁，还同时加了 7 个间隙锁。这样就确保了无法再插入新的记录。也就是说这时候，在一行行扫描的过程中，不仅将给行加上了行锁，还给行两边的空隙，也加上了间隙锁。<br>间隙锁和行锁合称 next-key lock，每个 next-key lock 是前开后闭区间。也就是说，我们的表 t 初始化以后，如果用 <code>select * from t for update</code> 要把整个表所有记录锁起来，就形成了 7 个 next-key lock，分别是 (-∞,0]、(0,5]、(5,10]、(10,15]、(15,20]、(20, 25]、(25, +supremum]，其中supremum是InnoDB为每个索引加的一个不存在的最大值。</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>除了上面提到的两种隔离级别：读-提交和可重复读（快照读），数据库还提供了另外两种隔离级别：读未提交和串行化，其中读未提交只解决了脏写，没有解决脏读，而串行化则要求事务串行化执行，由于性能的问题，大多数据库一般不会使用该隔离级别。</p>
<p><strong>参考：</strong></p>
<hr>
<p><a href="https://book.douban.com/subject/30329536/" target="_blank" rel="noopener">1. 数据密集型应用系统设计</a><br><a href="https://time.geekbang.org/column/article/75173?utm_source=pinpaizhuanqu&amp;utm_medium=geektime&amp;utm_campaign=guanwang&amp;utm_term=guanwang&amp;utm_content=0511" target="_blank" rel="noopener">2. 幻读是什么，幻读有什么问题？</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Noahsark</p>
              <p class="site-description motion-element" itemprop="description">不畏将来，不念过往</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">38</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">19</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">137</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Noahsark</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数">316k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
    <span title="站点阅读时长">4:48</span>
  
</div>

<div class="BbeiAn-info">
    <a target="_blank" href="https://beian.miit.gov.cn/" rel="nofollow">粤ICP备 2021097726号-1 </a>
	<a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44030702004132" style="text-decoration:none;padding-left:30px;background:url(https://s1.ax1x.com/2018/09/29/ilmwIH.png) no-repeat left center" rel="nofollow">粤公网安备 44030702004132号</a>
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v6.5.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.5.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.5.0"></script>



  



  










  





  

  

  

  

  

  
  

  

  

  

  

  

  

</body>
</html>
