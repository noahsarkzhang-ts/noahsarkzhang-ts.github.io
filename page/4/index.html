<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.5.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.5.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.5.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.5.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="不畏将来，不念过往">
<meta name="keywords" content="Java">
<meta property="og:type" content="website">
<meta property="og:title" content="以太格">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="以太格">
<meta property="og:description" content="不畏将来，不念过往">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="以太格">
<meta name="twitter:description" content="不畏将来，不念过往">






  <link rel="canonical" href="http://yoursite.com/page/4/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>以太格</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">以太格</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-commonweal">

    
    
    
      
    

    

    <a href="/404/" rel="section"><i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>公益 404</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于我</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/14/java-memory-model/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/06/14/java-memory-model/" class="post-title-link" itemprop="http://yoursite.com/page/4/index.html">Java 内存模型</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-06-14 20:36:17" itemprop="dateCreated datePublished" datetime="2020-06-14T20:36:17+08:00">2020-06-14</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-07-31 17:17:10" itemprop="dateModified" datetime="2021-07-31T17:17:10+08:00">2021-07-31</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java基础/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">9.7k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">9 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>处于优化的目的，在不同的编译器及不同体系架构的cpu 中，会将指令重排，即程序中排在后面的指令有可能比排在前面的指令先执行。同时由于cpu 中存在读写缓冲区，会将指令相关的运行时数据暂存在这些缓冲区中，也会导致指令重排的问题。目前的cpu 都是多核的体系架构，同一个语言编写的程序在不同硬件体系中，在多线程执行环境下，多次执行的结果可能不一致。在Java 中，怎么解决这个问题？为了屏蔽不同硬件架构的差异，给程序员提供一致的运行结果，Java 提出了 JMM(内存模型)的概念。</p>
<p>Java 内存模型（JMM）描述了在Java 语言中线程如何与主内存（Main Memory）进行交互，定义了一套线程对共享变量的访问规则，同时决定一个线程对共享变量的写入何时对另外一个线程可见。</p>
<p>在Java 中，共享变量主要包括实例字段、静态字段和数组元素，这些变量存储在堆内存中，由所有线程共享。而局部变量、方法参数和异常处理参数不会在线程间共享，不存在可见性（一个线程对变量的写入对另外的线程可见）的问题，不受内存模型的的影响。</p>
<p>从抽象的角度来看，JMM 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local memory），本地内存中存储了该线程读/写共享变量的副本。本地内存是JMM 的一个抽象概念，并不真实存在，它涵盖了缓存、写缓存区、寄存器以及其它硬件。JMM 抽象示意图如下所示：<br><img src="/images/JMM.jpg" alt="JMM" title="JMM"></p>
<p>从上图来看，线程A与线程B要进行通过的话，必须要经历两个步骤：</p>
<ol>
<li>首先，线程A将在本地内存中修改的共享变量刷新到主内存中；</li>
<li>最后，线程B重新从主内存加载修改后的共享变量，从而看到被修改后的内容。</li>
</ol>
<p>本质上来说，JMM 通过控制主内存与每个线程的本地内存之间的交互，来提供内存可见性的保证。</p>
<h2 id="2-重排序"><a href="#2-重排序" class="headerlink" title="2. 重排序"></a>2. 重排序</h2><p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：</p>
<ol>
<li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li>
<li>指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>
<li>内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。<br>从java源代码到最终实际执行的指令序列，会分别经历下面三种重排序：<br><img src="/images/java-instruction-reorder.png" alt="java-instruction-reorder" title="java-instruction-reorder"></li>
</ol>
<p>上述的1属于编译器重排序，2和3属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM的处理器重排序规则会要求java编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel称之为memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。<br>JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</p>
<h2 id="3-内存系统重排序"><a href="#3-内存系统重排序" class="headerlink" title="3. 内存系统重排序"></a>3. 内存系统重排序</h2><p>现代处理器与内存存在较大的性能差异，以主频为3GHZ的cpu为例，cpu访问一次内存时间在10~100ns内，但cpu  在100ns内可以执行1200条指令（假定一个时钟周期可以同时执行4条指令，一个时间周期为0.3ns）。因此，现代处理器在内存之间引入了多级的缓存结构，同时为了提高指令的执行效率，在cpu 寄存器与缓存之间引入了读/写缓冲区。写缓冲区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟。同时，通过以批处理的方式刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写，可以减少对内存总线的占用。读缓冲区可以缓存当前指令读取的数据，实现cpu异步读取数据，提高cpu的吞吐率。以Intel x86 CPU （2012 Sandy Bridge）为例，如下图所示：<br><img src="/images/memory-heirarchy.png" alt="memory-heirarchy" title="memory-heirarchy"><br>其内部组成包括：</p>
<ol>
<li>寄存器：在每个cpu 核心上，有160个用于整数和144个用于浮点的寄存器单元。访问这些寄存器只需要一个时钟周期，这构成了对执行核心来说最快的内存。编译器会将本地变量和函数参数分配到这些寄存器上。当使用超线程技术（ hyperthreading ）时，这些寄存器可以在超线程协同下共享。</li>
<li>读写缓冲区：读写缓存区包含64个load 缓冲条目和36个的store 缓冲条目。这些缓冲区用于记录等待缓存子系统时正在执行的操作。store 缓冲区保存将要写到L1 缓存的数据。load 缓冲区保存正要被寄存器读取的数据。由于读/写缓存仅对当前cpu 核心可见，这会造成指令的重排序，需要通过内存屏障来保证其执行顺序。</li>
<li>L1 &amp; L2 缓存：L1和L2 是一个本地核心内的缓存，它们在大小和速度上存在差异。</li>
<li>L3 缓存： 同插槽的所有cpu 核心共享L3缓存。L3缓存被分为多个2MB的段，所有段组成一环形网络。每一个核心都连接到这个环形网络上，地址通过hash的方式映射到段上以达到更大的吞吐量。</li>
<li>主内存：在缓存没命中的情况下，内存的平均延迟为65ns。</li>
<li>NUMA：在一个多插槽的服务器上，会使用非一致性内存访问机制（ non-uniform memory access ）。之所以要使用该方式主要是因为需要的数据在另外一个远程插槽上，需要跨越QPI 总线且额外花费40ns。 </li>
</ol>
<p>在上文讲到的多级缓存系统中，L1,L2,L3级缓存与主内存之间一致性一般是通过Cache Conherence技术来实现的，Intel 使用MESIF协议，AMD 使用 MOESI，在这里不再描述，我们假定：一旦内存数据被推送到L1 缓存，就会有消息协议来确保所有的缓存会对所有的共享数据同步并保持一致。</p>
<p>现在我们来分析引入读写缓冲区带来的问题，先看下两者的作用：</p>
<blockquote>
<p>When a store is issued to the out-of-order core for renaming and scheduling, an entry in the store buffer is allocated (in-order) for the address and the data. The store buffer will hold the address and data until the instruction has retired and the data has been written to the L1 cache.</p>
</blockquote>
<blockquote>
<p>Analogously, when a load is issued, an entry in the load buffer is reserved for the address. However, loads must also compare the load address against the contents of the entire store buffer to check for aliasing with older stores. If the load address matches an older store, then the load must wait for the older store to complete to preserve the dependency. Most x86 processors optimize this further, by allowing the store to forward data to the load without accessing the cache. The load buffer entry can be released, once the instruction has retired and the load data is written into the register file.</p>
</blockquote>
<blockquote>
<p>Because of the strong x86 ordering model, the load buffer is snooped by coherency traffic. A remote store must invalidate all other copies of a cache line. If a cache line is read by a load, and then invalidated by a remote store, the load must be cancelled, since it potentially read invalid data. The x86 memory model does not require snooping the store buffer.</p>
</blockquote>
<p>其要点包括：1）写缓冲区缓存指令的地址及数据信息，直到指令执行完毕且数据写入到L1 缓存中，写入到L1 缓存中之后，会通过MESIF协议通知其它cpu 核心失效相关的缓存行；2）读缓冲区按照地址缓存数据，直到指令执行完毕且数据被读到寄存器中；2）读缓冲区缓存了来自L1 缓存的数据，所以受MESIF协议的侦测，如果数据被其它远程的写缓冲区修改，根据MESIF协议，它会失效所有的数据拷贝，包括读缓冲区中的数据。</p>
<p>由于读写缓冲区只对当前cpu 核心有效，会造成指令重排的问题，要解决这个问题，需要引入“内存屏障”的技术。内存屏障提供了两个功能。首先，它们通过确保从另一个cpu 来看屏障的两边的所有指令都是正确的程序顺序，而保持程序顺序的外部可见性；其次它们可以实现内存数据可见性，确保内存数据会同步到cpu L1。</p>
<p><strong>Store Barrier</strong><br>Store 屏障，是x86的”sfence“ 指令，强制所有在store 屏障指令之前的store 指令，都在该store 屏障指令执行之前被执行，并把store 缓冲区的数据都刷到L1 ，这会使得程序状态对其它cpu 可见。</p>
<p><strong>Load Barrier</strong><br>Load 屏障，是x86 上的”ifence“ 指令，强制所有在load 屏障指令之后的load 指令，都在该load 屏障指令执行之后被执行，并且一直等到load 缓冲区被该cpu 读完才能执行之后的load 指令。这使得从其它cpu 暴露出来的程序状态对该cpu 可见，这之后cpu 可以进行后续处理。</p>
<p><strong>Full Barrier</strong><br>Full 屏障，是x86 上的”mfence“ 指令，复合了load 和save 屏障的功能。</p>
<h2 id="4-编译器重排序"><a href="#4-编译器重排序" class="headerlink" title="4. 编译器重排序"></a>4. 编译器重排序</h2><p><strong>数据依赖性</strong><br>如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。数据依赖分下列三种类型：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>代码示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>写后读</td>
<td>a = 1;b = a;</td>
<td>写一个变量之后，再读这个位置</td>
</tr>
<tr>
<td>写后写</td>
<td>a = 1;a = 2;</td>
<td>写一个变量之后，再写这个变量</td>
</tr>
<tr>
<td>读后写</td>
<td>a = b;b = 1;</td>
<td>读一个变量之后，再写这个变量</td>
</tr>
</tbody>
</table>
<p>上面三种情况，只要重排序两个操作的执行顺序，程序的执行结果将会被改变。</p>
<p>前面提到过，编译器和处理器可能会对操作做重排序。编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序</p>
<p><strong>as-if-serial 语义</strong><br>as-if-serial 语义的意思指：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守 as-if-serial 语义。</p>
<p>为了遵守 as-if-serial 语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作可能被编译器和处理器重排序。</p>
<h2 id="5-JMM内存屏障"><a href="#5-JMM内存屏障" class="headerlink" title="5. JMM内存屏障"></a>5. JMM内存屏障</h2><p>为了保证内存可见性，Java 编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。JMM把内存屏障指令分为下列四类：</p>
<table>
<thead>
<tr>
<th>屏障类型</th>
<th>指令示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>LoadLoad Barriers</td>
<td>Load1; LoadLoad; Load2</td>
<td>确保Load1数据的装载，之前于Load2及所有后续装载指令的装载。</td>
</tr>
<tr>
<td>StoreStore Barriers</td>
<td>Store1; StoreStore; Store2</td>
<td>确保Store1数据对其他处理器可见（刷新到内存），<br>之前于Store2及所有后续存储指令的存储。</td>
</tr>
<tr>
<td>LoadStore Barriers</td>
<td>Load1; LoadStore; Store2</td>
<td>确保Load1数据装载，之前于Store2及所有后续<br>的存储指令刷新到内存。</td>
</tr>
<tr>
<td>StoreLoad Barriers</td>
<td>Store1; StoreLoad; Load2</td>
<td>确保Store1数据对其他处理器变得可见（指刷新到内存），<br>之前于Load2及所有后续装载指令的装载。StoreLoad Barriers <br>会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，<br>才执行该屏障之后的内存访问指令。</td>
</tr>
</tbody>
</table>
<p>StoreLoad Barriers是一个“全能型”的屏障，它同时具有其他三个屏障的效果。现代的多处理器大都支持该屏障（其他类型的屏障不一定被所有处理器支持）。执行该屏障开销会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中（buffer fully flush）。</p>
<p><strong>JMM 内存屏障与cpu 内存屏障的映射</strong><br>在不同cpu 架构中，实现的内存屏障是不同的，如上面的X86体系中，只允许StoreLoad指令重排，所以只用实现StoreLoad Barriers，而其它cpu 体系则有所不同，其对应关系如下图所示：<br><img src="/images/cpu-barriers-map-jmm.png" alt="cpu-barriers-map-jmm" title="cpu-barriers-map-jmm"></p>
<p>由于常见的cpu 内存屏障比 JMM 要弱，java 编译器在生成字节码时，会在执行指令序列的适当位置插入内存屏障来限制处理器的重排序。同时，由于各种处理器内存屏障的强弱并不相同，为了在不同的处理器平台向程序员展示一个一致的内存模型，JMM 在不同的处理器中需要插入的内存屏障的数量和种类也不相同。</p>
<h2 id="6-happen-before"><a href="#6-happen-before" class="headerlink" title="6. happen-before"></a>6. happen-before</h2><p>JMM 使用happens-before 的概念来阐述操作之间的内存可见性，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before 关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。<br>与程序员密切相关的happens-before 规则如下：</p>
<ol>
<li>程序顺序规则：一个线程中的每个操作，happens-before 于该线程中的任意后续操作。</li>
<li>监视器锁规则：对一个监视器锁的解锁，happens-before 于随后对这个监视器锁的加锁。</li>
<li>volatile变量规则：对一个volatile域的写，happens-before 于任意后续对这个volatile域的读。</li>
<li>传递性：如果A happens- before B，且B happens- before C，那么A happens- before C。</li>
</ol>
<p>注意，两个操作之间具有happens-before关系，并不意味着前一个操作必须要在后一个操作之前执行！happens-before 仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前（the first is visible to and ordered before the second）。<br>happens-before与JMM的关系如下图所示：<br><img src="/images/happens-before.png" alt="happens-before" title="happens-before"></p>
<h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><p>通过JMM 模型的定义，使得Java语言真正实现了跨平台，在不同平台，多线程的执行总能得到一致的结果，同时定义happens-before 规则，简化了对JMM 理解难度。</p>
<p><strong>参考：</strong></p>
<hr>
<p><a href="https://www.infoq.cn/article/java-memory-model-1/" target="_blank" rel="noopener">1. 深入理解 Java 内存模型（一）——基础</a><br><a href="https://www.infoq.cn/article/java-memory-model-2/" target="_blank" rel="noopener">2. 深入理解 Java 内存模型（二）——重排序</a><br><a href="https://download.oracle.com/otn-pub/jcp/memory_model-1.0-pfd-spec-oth-JSpec/memory_model-1_0-pfd-spec.pdf?AuthParam=1593252270_c3d47e052ce05eb43eb35a8c96217567" target="_blank" rel="noopener">3. SR-133: JavaTM Memory Model and Thread Specification</a><br><a href="https://www.realworldtech.com/haswell-tm-alt/2/" target="_blank" rel="noopener">4. Haswell Transactional Memory Alternatives</a><br><a href="http://ifeve.com/cpu-cache-flushing-fallacy/" target="_blank" rel="noopener">5. CPU Cache Flushing Fallacy</a><br><a href="http://ifeve.com/memory-barriersfences/" target="_blank" rel="noopener">6. Memory Barriers/Fences</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/24/database-transaction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/05/24/database-transaction/" class="post-title-link" itemprop="http://yoursite.com/page/4/index.html">数据库事务</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-05-24 12:55:17" itemprop="dateCreated datePublished" datetime="2020-05-24T12:55:17+08:00">2020-05-24</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-07-31 17:17:10" itemprop="dateModified" datetime="2021-07-31T17:17:10+08:00">2021-07-31</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据库/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">15k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">13 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在数据库技术中，事务将应用程序的多个读、写操作捆绑在一起成为一个逻辑操作单元。即事务中的所有读写是一个执行的整体，整个事务要么成功（提交）、要么失败（中止或回滚）。如果失败，应用程序可以安全地重试。这样，由于不需要担心部分失败的情况（无论出于何种原因），应用层的错误处理就变得简单得多。</p>
<h2 id="1-ACID的含义"><a href="#1-ACID的含义" class="headerlink" title="1. ACID的含义"></a>1. ACID的含义</h2><p>事务提供了四个方面的安全保证，即ACID，分别代表原子性（Atomicity），一致性（Consistency），隔离性（Isolation）与持久性（Durability）。</p>
<h3 id="1-1-原子性"><a href="#1-1-原子性" class="headerlink" title="1.1 原子性"></a>1.1 原子性</h3><p>ACID原子性描述了客户端发起一个包含多个写操作的请求时可能发生的情况，例如在完成了一部分写入后，系统发生了故障，包括进程崩溃，网络中断，磁盘变满或者违反了某种完整性约束等；把多个写操作纳入到一个原子事务，万一出现了上述故障而导致没法完成最终提交时，则事务会中止，并且数据库丢弃或撤销那些局部完成的操作。<br>ACID原子性所定义的特征是：在出错时中止事务，并将部分完成的写入全部丢弃。它强调一个可中止性的概念。</p>
<h3 id="1-2-一致性"><a href="#1-2-一致性" class="headerlink" title="1.2 一致性"></a>1.2 一致性</h3><p>ACID中的一致性主要是指对数据有特定的预期状态，任何数据更改必须满足这些状态约束（或者恒等条件）。例如，对于一个账单系统，账户的贷款余额应和借款余额保持平衡。如果某事务从一个有效的状态开始，并且事务中任何更新操作都没有违背约束，那么最后的结果依然符合有效状态。<br>这种一致性本质上要求应用层来维护状态一致（或者恒等），应用程序有责任正确地定义事务来保持一致性。这不是数据库可以保证的事情：即如果提供的数据违背了恒等条件，数据库很难检测进而阻止该操作（数据库可以完成针对某些特定类型的恒等约束检查，例如使用外键约束或唯一性约束。但通常主要靠应用程序定义数据的有效/无效状态，数据库主要用于存储）。<br>原子性，隔离性和持久性是数据库自身的属性，而ACID中的一致性更多是应用层的属性。应用程序可能借助数据库提供的原子性和隔离性，以达到一致性，但一致性本身并不源于数据库。因此，也有一种说法，字母C其实并不应该属于ACID。</p>
<h3 id="1-3-隔离性"><a href="#1-3-隔离性" class="headerlink" title="1.3 隔离性"></a>1.3 隔离性</h3><p>ACID语义中的隔离性意味着并发执行的多个事务相互隔离，它们不能互相交叉，主要是指多个事务中对相同记录读写操作进行隔离。</p>
<h3 id="1-4-持久性"><a href="#1-4-持久性" class="headerlink" title="1.4 持久性"></a>1.4 持久性</h3><p>数据库系统本质上是提供一个安全可靠的地方来存储数据而不用担心数据丢失等。持久性它保证一旦事务提交成功，即使存在硬件故障或数据库崩溃，事务所写入的任何数据也不会消失。</p>
<p>在ACID中，原子性，隔离性和持久性是数据库自身的属性，其中原子性和持久性，我们能修改的地方不多，所以后面的内容主要关注隔离性相关的内容。</p>
<h2 id="2-隔离性"><a href="#2-隔离性" class="headerlink" title="2. 隔离性"></a>2. 隔离性</h2><p>隔离性主要是解决多个事务对相同数据或关联数据同时进行读写引发的问题，这些问题包括脏读、脏写、不可重复读及幻读。</p>
<h3 id="2-1-脏读"><a href="#2-1-脏读" class="headerlink" title="2.1 脏读"></a>2.1 脏读</h3><p><strong>定义：一个事务读取了另外一个事务未提交的数据，主要是并发读的问题。</strong></p>
<p>假定某个事务已经完成部分数据写入，但事务尚未提交（或中止），此时另一个事务可以看到尚未提交的数据，如图所示：<br><img src="/images/dirty-read.jpg" alt="dirty-read" title="dirty-read"><br>事务1设置了x=3，在事务1未提交之前，事务2的get x操作返回了3。没有脏读时，事务2只有在事务1的事务提交之后才能看到x的新值。</p>
<p>当有以下需求时，需要防止脏读：</p>
<ul>
<li>如果事务需要更新多个对象，脏读意味着另一个事务可能会看到部分更新，而非全部。</li>
<li>如果事务发生中止，则所有写入操作都需要回滚。如果发生了脏读，这意味着它可能会看到一些稍后被回滚的数据，而这些数据并未实际提交到数据库中。之后所引发的后果可能会变得难以预测。</li>
</ul>
<h3 id="2-2-脏写"><a href="#2-2-脏写" class="headerlink" title="2.2 脏写"></a>2.2 脏写</h3><p><strong>定义：一个事务覆盖了另外一个事务未提交的数据更新，主要是对同一份数据进行并发更新的问题。</strong></p>
<p>如果两个事务同时尝试更新相同的对象，会发生什么情况?我们不清楚写入的顺序，但可以想象后写的操作会覆盖较早的写入。如果先前的写入是尚未提交事务的一部分，是否还会被覆盖？如果是，那就是脏写。<br>如果事务需要更新多个对象，脏写会带来非预期的错误结果，例如Alice和Bob两个人试图购买同一辆车，而购买洗车需要两次数据的写入：商品买主需要更新，同时发票也要更新。如下图所示，车主被改为Bob（他成功更新了商品数据），而Alice成功更新了发票信息，导致了业务数据的不一致。<br><img src="/images/dirty-write.jpg" alt="dirty-write" title="dirty-write"></p>
<h3 id="2-3-隔离级别-读提交"><a href="#2-3-隔离级别-读提交" class="headerlink" title="2.3 隔离级别-读提交"></a>2.3 隔离级别-读提交</h3><p>读-提交是数据库中比较流行的事务隔离级别，它提供以下两个保证：</p>
<ul>
<li>读数据库时，只能看到已成功提交的数据，防止脏读；</li>
<li>写数据库时，只会覆盖已成功提交的数据，防止脏写。</li>
</ul>
<p>数据库通常使用行级锁来防止脏写：当事务想修改某个对象（例如行或文档）时，它必须首先获得该对象的锁；然后一直持有锁直到事务提交（或中止）。给定时刻，只有一个事务可以拿到特定对象的锁，如果有另一个事务尝试更新同一个对象，则必须等待，直到前面的事务完成了提交（或中止）后，才能获得锁并继续。<br>数据库了为防止脏读，一般使用读锁，或者对于每一个待更新的对象，数据库都会维护数据的两个版本：1）旧值的版本；2）当前事务最新的版本。在事务提交之前，所有其它读操作都读取旧值；仅当写事务提交之后，才会切换到读取最新的值。</p>
<h3 id="2-4-不可重复读"><a href="#2-4-不可重复读" class="headerlink" title="2.4 不可重复读"></a>2.4 不可重复读</h3><p><strong>定义：在同一个事务中，同一个查询操作重复多次执行，返回结果不一样，主要是并发读的问题。</strong></p>
<p>不可重复读出现在一个事务中，在同一个查询操作执行多次操作的期间，另外一个事务对相同数据对象进行更新操作并成功提交事务，导致提交前后的数据不同。如下图所示，在读提交隔离级别下不能解决不可重复读的问题。<br><img src="/images/non-repeatable-read.jpg" alt="non-repeatable-read" title="non-repeatable-read"></p>
<p>假设Alice在银行有1000美元的存款，分为两个账户，每个500美元。现在有这样一笔转账交易从账户1转账户2。如果在她提交转账请求之后而数据库系统执行转账的过程中间，来查看两个账户的余额，她有可能会看到账户1在收到转账之前的余额（500美元），和账户2在完成转账之后的敌众余额（400美元）。对于Alice来说，貌似她的账户总共有900美元，而不是1000美元。</p>
<p>在上面的场景中，主要是一个事务跨越了另外一个事务，读取到了另外一个事务前后更新的数据，导致了数据的不一致性。为了解决这个问题，数据库引入了多版本并发控制（Multivesion Concurrency Control,MVCC），这种技术保留了数据对象多个不同的提交版本。</p>
<p>提供MVCC技术的隔离级别称为快照隔离级别，在MYSQL中也叫可重复读隔离级别，我们在这里统一叫快照隔离级别。在快照隔离级别中，脏写也是通过行锁来实现的，而脏读的实现也比较简单，直接基于MVCC来实现。</p>
<p>以PostgreSQL（或Mysql）中的MVCC实现为例。当事务开始时，首先赋予一个唯一的、单调递增的事务ID(txid)。每当事务向数据库写入新内部时，所写的数据都会被标记写入者的事务ID，如下图所示：<br><img src="/images/mvcc.jpg" alt="mvcc" title="mvcc"><br>表中的每一行都有一个created_by字段，其中包含了创建该行的事务ID。每一行还有一个deleted_ty字段，初始为空。如果事务要删除某行，该行实际上并未从数据库中删除，而只是将deleted_ty字段设置为请求删除的事务ID（仅仅标记为删除）。事后，当确定没有其它事务引用该标记删除的行时，数据库的垃圾回收进程才去真正删除并释放存储空间。</p>
<p>一次更新操作在内部会转换为一个删除操作加一个创建操作。例如，事务13从账户2中扣除100元，余额从500美元减为400美元，在account表里会出现现两行：一个余额为500但标记为删除的行（由事务13删除），另一个余额为400，由事务13创建。</p>
<p>当事务读数据库时，通过事务ID可以决定哪些对象可见，哪些不可见。通常情况下，仅当以下两个条件都成立，则该数据对象对事务可见：</p>
<ul>
<li>事务开始的时刻，创建该对象的事务已经完成了提交；</li>
<li>对象没有被标记为删除；或者即使标记了，但删除事务在当前事务开始时还没有完成提交。</li>
</ul>
<p>如事务12只能看到12之前提交的数据，事务13的更改对于事务12来说是不可见的。</p>
<h3 id="2-5-当前读"><a href="#2-5-当前读" class="headerlink" title="2.5 当前读"></a>2.5 当前读</h3><p>在快照隔离级别下，以下的场景会产生问题：</p>
<ol>
<li>首先输入一些匹配条件，即采用SELECT查询所有满足条件的行（例如，至少有两名医生正在值班，同一时刻房间没有预订）。</li>
<li>根据查询的结果，应用层代码来决定下一步的操作（有可能继续，或者报告错误并中止）。</li>
<li>如果应用程序决定继续执行，它将发起数据库写入（INSERT,UPDATE或DELETE）并提交事务。</li>
</ol>
<p>假定在一个医生管理系统中，医院会安排多个医生值班，医生也可以申请调整班次，但前提是确保至少一个医生还在该班次中值班。现在的情况是，Alice和Bob是两位值班医生，两个人碰巧都感到身体不适，因而都决定请假。如果他们几乎同一个时刻执行了调班的操作，如下图所示：<br><img src="/images/write-tilt.jpg" alt="write-tilt" title="write-tilt"></p>
<p>在数据库使用快照级别隔离，两个检查都返回有两名医生，所以两个事务都安全地进入下一下阶段。接下来，两个事务执行更新操作，调班成功。两个事务都成功提交，最后的结果却是没有任何医生在值班，显然违背了至少一个医生值班的业务需求。</p>
<p>为了解决这个问题，一种可选的方案是对查询的数据行显示加锁，加上for update，如下所示：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> doctors  <span class="keyword">where</span> on_call=<span class="literal">true</span> <span class="keyword">and</span> shift_id=<span class="number">1234</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> doctors  <span class="keyword">set</span> on_call=<span class="literal">false</span>  <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'Alice'</span>  <span class="keyword">and</span> shift_id=<span class="number">1234</span>;</span><br></pre></td></tr></table></figure></p>
<p>在上面的查询语句中，加入了for update，表示对数据行进行加锁，采用的是“当前读”的模式（Mysql数据库），即当前读会读取当前最新提交的数据，即使当前事务落后于最新事务，也能看到最新事务提交后的数据。</p>
<h3 id="2-6-幻读"><a href="#2-6-幻读" class="headerlink" title="2.6 幻读"></a>2.6 幻读</h3><p><strong>定义：在一个事务中的写入（插入）操作改变了另外一个事务查询的结果。</strong></p>
<p>在Mysql中，在快照读（可重复读）隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。幻读只会在“当前读”下才会出现，同时幻读专指“新插入的行”。</p>
<p>假定有如下的表及初始数据：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`d`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`c`</span> (<span class="string">`c`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>),(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>),(<span class="number">15</span>,<span class="number">15</span>,<span class="number">15</span>),(<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>),(<span class="number">25</span>,<span class="number">25</span>,<span class="number">25</span>);</span><br></pre></td></tr></table></figure></p>
<p>现在对该表执行三个事务，如下图所示：<br><img src="/images/multi-transaction.jpg" alt="multi-transaction" title="multi-transaction"></p>
<p>可以看到，事务A里执行了三次查询，分别是 Q1、Q2 和 Q3。它们的 SQL 语句相同，都是 select * from t where d=5 for update。这个语句查询所有d=5的行，使用当前读，并且加上锁，现在来看它们的返回结果：</p>
<ol>
<li>Q1只返回id=5这一行数据；</li>
<li>在T2时刻，事务B修改了id=0这行数据，所以Q2返回id=0和id=5这两行数据；</li>
<li>在T4时刻，事务C插入了新的一行数据，所以Q3返回id=0,id=1及id=5这三行数据。</li>
</ol>
<p>其中，Q3 读到 id=1 这一行的现象，被称为“幻读”。也就是说，幻读指的是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。</p>
<h4 id="2-6-1-幻读引发的问题"><a href="#2-6-1-幻读引发的问题" class="headerlink" title="2.6.1 幻读引发的问题"></a>2.6.1 幻读引发的问题</h4><p>幻读会引入两个问题，一是语义上的问题，事务A已经对d=5的行加了锁，其它事务仍然还可以对d=5的行进行操作，如将其它行的d字段改为5或新插入d=5的行；另外一个问题，会导致数据库数据和日志的不一致，如下图所示：<br><img src="/images/phantom-read-problem.jpg" alt="phantom-read-problemn" title="phantom-read-problem"><br>在数据库中id=5的行，d字段修改为100；id=1的行，d=5,c=5。我们再来看binlog的日志：</p>
<ol>
<li><p>T2时刻，事务C提交之后，写入两行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> c=<span class="number">5</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>T4时刻，事务A提交之后，写入三行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> d=<span class="number">100</span> <span class="keyword">where</span> d=<span class="number">5</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>合在一起之后，日志内容如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> c=<span class="number">5</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> d=<span class="number">100</span> <span class="keyword">where</span> d=<span class="number">5</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure></p>
<p>从执行的语句来看，事务A的update最后执行，导致所有d=5的行，d字段都修改为100，与数据库中的数据不一致。如果使用这个binlog日志进行恢复数据或进行主从备份，会导致数据的前后不一致。</p>
<h4 id="2-6-2-解决的办法"><a href="#2-6-2-解决的办法" class="headerlink" title="2.6.2 解决的办法"></a>2.6.2 解决的办法</h4><p>事务B中的update操作可以通过行锁来解决，但对于事务C的插入操作，由于该行在插入之前根本不存在，不能使用行锁来解决，因此，为了解决幻读问题，InnoDB 引入新的锁，也就是间隙锁 (Gap Lock)。顾名思义，间隙锁，锁的就是两个值之间的空隙。比如文章开头的表 t，初始化插入了 6 个记录，这就产生了 7 个间隙。如下图所示：<br><img src="/images/gap-lock.jpg" alt="gap-lock" title="gap-lock"><br>这样，当执行 <code>select * from t where d=5 for update</code> 的时候，就不止是给数据库中已有的 6 个记录加上了行锁，还同时加了 7 个间隙锁。这样就确保了无法再插入新的记录。也就是说这时候，在一行行扫描的过程中，不仅将给行加上了行锁，还给行两边的空隙，也加上了间隙锁。<br>间隙锁和行锁合称 next-key lock，每个 next-key lock 是前开后闭区间。也就是说，我们的表 t 初始化以后，如果用 <code>select * from t for update</code> 要把整个表所有记录锁起来，就形成了 7 个 next-key lock，分别是 (-∞,0]、(0,5]、(5,10]、(10,15]、(15,20]、(20, 25]、(25, +supremum]，其中supremum是InnoDB为每个索引加的一个不存在的最大值。</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>除了上面提到的两种隔离级别：读-提交和可重复读（快照读），数据库还提供了另外两种隔离级别：读未提交和串行化，其中读未提交只解决了脏写，没有解决脏读，而串行化则要求事务串行化执行，由于性能的问题，大多数据库一般不会使用该隔离级别。</p>
<p><strong>参考：</strong></p>
<hr>
<p><a href="https://book.douban.com/subject/30329536/" target="_blank" rel="noopener">1. 数据密集型应用系统设计</a><br><a href="https://time.geekbang.org/column/article/75173?utm_source=pinpaizhuanqu&amp;utm_medium=geektime&amp;utm_campaign=guanwang&amp;utm_term=guanwang&amp;utm_content=0511" target="_blank" rel="noopener">2. 幻读是什么，幻读有什么问题？</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/16/mysql-and-ignite-update-operation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/05/16/mysql-and-ignite-update-operation/" class="post-title-link" itemprop="http://yoursite.com/page/4/index.html">mysql和ignite更新性能对比</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-05-16 16:58:02" itemprop="dateCreated datePublished" datetime="2020-05-16T16:58:02+08:00">2020-05-16</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-07-31 17:17:10" itemprop="dateModified" datetime="2021-07-31T17:17:10+08:00">2021-07-31</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据库/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">9.3k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">8 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前段时间，需要对内存数据库ignite进行造型，将mysql与ignite进行了性能测试，这篇文章主要是讲在update操作上两者的差异。我们首先假定数据库表如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_token_info (</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">	token_id <span class="built_in">CHAR</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	state <span class="built_in">TINYINT</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	server_id <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	room_id <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	update_date datetime <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	PRIMARY <span class="keyword">KEY</span> (datetime)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> idx_token_id <span class="keyword">ON</span> t_token_info (token_id);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx_server_id <span class="keyword">ON</span> t_token_info (server_id);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx_room_id <span class="keyword">ON</span> t_token_info (room_id);</span><br></pre></td></tr></table></figure></p>
<p>t_token_info表上有4个索引，其中在字段id上建立主键索引，token_id上建立唯一索引，server_id和room_id上建立B+Tree索引。更新的场景包括两方面：1）在token_id上进行更新，只影响一条件记录；2）批量更新，根据server_id及room_id上进行批量更新，一次server_id操作影响的记录为2000条。下面将对mysql及ignite两种数据库进行分析 ，首先分析update操作背后的逻辑，然后再根据场景进行性能测试，最后得出结论。</p>
<h2 id="1-Mysql"><a href="#1-Mysql" class="headerlink" title="1. Mysql"></a>1. Mysql</h2><h3 id="1-1-单条记录更新"><a href="#1-1-单条记录更新" class="headerlink" title="1.1 单条记录更新"></a>1.1 单条记录更新</h3><p>以下面的更新为例，分析mysql的操作过程：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> t_token_info <span class="keyword">set</span> state=<span class="number">1</span>,update_date=<span class="keyword">now</span>(),server_id=<span class="number">12</span> <span class="keyword">where</span>  token_id=token1;</span><br></pre></td></tr></table></figure></p>
<p><img src="/images/mysql-update.jpg" alt="mysql-update" title="mysql-update"></p>
<p>涉及到的IO操作如下：</p>
<ol>
<li>读取记录：包括B+Tree索引结点及数据的读取，假定索引及数据没有加载到内存，且B+Tree索引深度为2（分支因子为500且结点大小为4K的四级树可以存储256 TB的数据），则需要3次IO操作，两次读取索引结点，一次读取数据；</li>
<li>写入操作：包括预写日志（存储引擎的redo log日志）、binlog日志及写入的数据，至少三次IO操作，如果新写入的数据，导致B+Tree叶子结点进行分裂操作，则需要更多的IO操作；</li>
<li>更新索引操作：因为更新的字段state及activeId是二级索引，更新这两个值，在事务中需要更新索引。更新索引又涉及到读取索引结点，更新索引的内容，等同于多次对数据进行更新操作，索引越多，则IO操作越多。</li>
</ol>
<h3 id="1-2-批量更新"><a href="#1-2-批量更新" class="headerlink" title="1.2 批量更新"></a>1.2 批量更新</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> t_token_info <span class="keyword">set</span> state=<span class="number">1</span>,update_date=<span class="keyword">now</span>() <span class="keyword">where</span> server_id=<span class="number">12</span>;</span><br></pre></td></tr></table></figure>
<p>批量更新操作最终会转换为多次主键更新操作，这个操作由mysql服务器中执行器模块来执行，如下图所示：<br><img src="/images/mysql-batch-update.jpg" alt="mysql-batch-update" title="mysql-batch-update"></p>
<p>批量更新的操作如下：</p>
<ol>
<li>根据activeId的索引找到更新的tokenId列表；</li>
<li>遍历tokenId列表，取到tokenId，再根据主键索引找到token的数据；</li>
<li>执行单个token的执行操作，直到所有的token更新完毕；</li>
<li>批量更新的时间与影响的记录数存在线性的关系，记录数越多，时间越长。</li>
</ol>
<h2 id="2-ignite"><a href="#2-ignite" class="headerlink" title="2. ignite"></a>2. ignite</h2><h3 id="2-1-ignite固化内存模型"><a href="#2-1-ignite固化内存模型" class="headerlink" title="2.1 ignite固化内存模型"></a>2.1 ignite固化内存模型</h3><p><img src="/images/Durable_Memory_Diagram.png" alt="Durable_Memory_Diagram" title="Durable_Memory_Diagram"><br>iginte固化内存模型的层次：</p>
<ul>
<li>内存区域：可以根据业务需要，可以将内存分为不同的大小的段，每一个区域分为不同的页，如存放key-value对（ignite本质是基于key-value的内存数据库）的数据页；B+Tree元数据页，存放每一个索引的根结点及层次信息；索引页面，存放B+Tree结点，根据索引字段进行排序，值存储数据结点的页号及偏移值；空闲页，由多个空闲链表进行维护。</li>
<li>页：分为不同类型，一般为4K，可以进行配置。</li>
</ul>
<h3 id="2-2-B-Tree和索引页面"><a href="#2-2-B-Tree和索引页面" class="headerlink" title="2.2 B+Tree和索引页面"></a>2.2 B+Tree和索引页面</h3><p><img src="/images/page-memory-b-tree.png" alt="page-memory-b-tree" title="page-memory-b-tree"><br>应用定义和使用的SQL索引是以B+Tree数据结构的形式进行维护的。每个唯一索引Ignite会实例化并且管理一个专用的B+Tree实例。<br>整个B+Tree的目的就是链接和排序在固化内存中分配和存储的索引页面。从内部来说，索引页面包括了定位索引值、索引指向的缓存条目在数据页面中的偏移量、还有到其它索引页面的引用（用来遍历树）等所有必要的信息，缓存的键也会存储于B+Tree，它们通过哈希值进行排序。<br>B+树的元页面需要获得特定B+Tree的根和它的层次，以高效地执行范围查询。比如，当执行myCache.get(keyA)时，它会触发下面的操作流程：</p>
<ol>
<li>Ignite会查找myCache属于那个内存区；<br>在该内存区中，会定位持有myCache的键的B+Tree的元页面；</li>
<li>根据keyA的哈希值，然后在B+Tree中检索该键所属的索引页面；</li>
<li>如果对应的索引页面在内存/磁盘中没找到，那么意味着其在myCache中不存在，然后Ignite会返回null；</li>
<li>如果索引页面存在，那么它会包含找到缓存条目keyA所在的数据页面的所有必要信息；</li>
<li>Ignite定位keyA所属的数据页面然后将值返回给应用。</li>
</ol>
<p>3、数据的存储<br> <img src="/images/inginte-data.png" alt="inginte-data" title="inginte-data"><br>上图是一个数据页的内部结构，包括三个部分：1）Page Header；2）Data Header；3）Page Data，数据区，存放key-value对。</p>
<p>4、更新操作流程<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> t_token_info <span class="keyword">set</span> state=<span class="number">1</span>,update_date=<span class="keyword">now</span>(),server_id=<span class="number">12</span> <span class="keyword">where</span>  token_id=token1;</span><br></pre></td></tr></table></figure></p>
<p>在ignite内部中，一次操作为转化为缓存的一次put操作。myCache.put(keyA,valueA)操作的执行流程如下：</p>
<ol>
<li>Ignite会找到myCache所属的内存区；</li>
<li>在该内存区中，会定位持有myCache的键的B+树的元数据页面；</li>
<li>根据keyA的哈希值，然后在B+树中检索该键所属的索引页面；</li>
<li>如果对应的索引页面在内存或者磁盘上都没有找到，那么会从空闲列表中申请一个新的页面，成功之后，它就会被加入B+树；</li>
<li>如果索引页面是空的（即未引用任何数据页面），根据总的缓存条目大小会从空闲列表中分配一个新的数据页面，然后在索引页面中添加到新数据页面的引用；</li>
<li>该缓存条目会加入该数据页面。</li>
</ol>
<p>5、批量更新<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> t_token_info <span class="keyword">set</span> state=<span class="number">1</span>,update_date=<span class="keyword">now</span>() <span class="keyword">where</span> server_id=<span class="number">12</span>;</span><br></pre></td></tr></table></figure></p>
<p>在ignite中，批量更新操作，内部会转化为两个操作：1）select * from tokeninfo where activeId=12，先进行一次select操作，查询出修改的记录；2）再调用cache.invokeAll(…) 修改数据。<br>使用这种方式，批量更新的操作等同于：一次select操作（客户端操作） + n次单条记录的更新操作（客户端批量提交到服务器器），下面就对批量更新的性能进行验证。</p>
<h2 id="3-性能验证"><a href="#3-性能验证" class="headerlink" title="3. 性能验证"></a>3. 性能验证</h2><ol>
<li>场景1：假定有20万token数据，每一个服务器上的token数为2000个；</li>
<li>场景1：假定有20万token数据，每一个服务器上的token数为200个；</li>
<li>场景1：假定有20万token数据，每一个服务器上的token数为20个；</li>
</ol>
<p>分别在三种场景下，执行两种操作：1）按照唯一键token_id更新; 2）按照server_id进行批量更新。</p>
<h2 id="4-结论（ignite使用纯内存）"><a href="#4-结论（ignite使用纯内存）" class="headerlink" title="4. 结论（ignite使用纯内存）"></a>4. 结论（ignite使用纯内存）</h2><ol>
<li>ignite按照主键进行更新，QPS可以达到10,000，响应时间在5~10ms，性能相比mysql，有较大的提升。</li>
<li>ignite中批量更新操作会转换为：一个select操作 + n个token的更新操作。在批量执行token前，客户端需要执行一次select操作，获取影响的记录（获取主键），然后向服务器批量提交更新操作（根据主键进行操作）。客户端执行一次select操作，性能上会有一定的影响；</li>
<li>根据三种场景的测试，按照服务器进行批量更新操作，QPS及响应时间受两个因素影响：1）数据库服务器1S内可更新的缓存数量SC；2）一个操作影响的记录数ST。在SC确定的情况下，ST越大，QPS越小，响应时间越长，ST越小，QPS越大，响应时间越短。目前测试得出，在单台服务上1S可以完成对20，000个缓存的更新操作，如果ST为2000个，QPS只能达到10，受SC影响，如果ST为200个，QPS增大10倍，响应时间减少到10/1。</li>
</ol>
<p><strong>参考：</strong></p>
<hr>
<p><a href="https://www.ignite-service.cn/doc/java/DurableMemory.html#_1-%E5%9B%BA%E5%8C%96%E5%86%85%E5%AD%98" target="_blank" rel="noopener">1. 固化内存</a></p>
<p><a href="https://cwiki.apache.org/confluence/display/IGNITE/Ignite+Durable+Memory+-+under+the+hood" target="_blank" rel="noopener">2. Ignite Durable Memory - under the hood</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/05/storage-model/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/05/05/storage-model/" class="post-title-link" itemprop="http://yoursite.com/page/4/index.html">存储引擎</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-05-05 16:20:33" itemprop="dateCreated datePublished" datetime="2020-05-05T16:20:33+08:00">2020-05-05</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-07-31 17:17:10" itemprop="dateModified" datetime="2021-07-31T17:17:10+08:00">2021-07-31</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据库/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">4.8k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">4 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>概括来讲，存储引擎分为两大类：针对事务处理（OLTP）优化的结构，以及针对分析型（OLAP）的优化结构。它们典型的访问模式存在很大的差异：</p>
<ul>
<li>OLTP系统通常面向用户，这意味着它们可能收到大量的请求。为了处理负载，应用程序通常在每个用户查询中只涉及小量的记录。应用程序基于某种键来请求记录，而存储引擎使用索引来查找所请求的数据。磁盘寻道时间往往是瓶颈。</li>
<li>由于不直接面对最终用户，数据仓库和类似的分析系统相对并不太广为人知，它们主要由业务分析师使用。处理的查询请求数目远低于OLTP系统，但每个查询通常要求非常苛刻，需要在短时间内扫描百万条记录。磁盘带宽（不是寻道时间）通常是瓶颈，而面向列的存储对于这种工作负载成为日益流行的解决方案。<br>在OLTP方面，有两个主要流派的存储引擎：</li>
<li>日志结构流派：它只允许追加方式更新文件和删除过时的文件，但不会修改已写入的文件。BitCask、SSTable、LST-Tree、LevelDB、Cassandra、HBase、Lucence等属于此类；</li>
<li>原地更新流派：将磁盘视为可以覆盖的一组固定大小的页。B-Tree是这个哲学的最典型代表，它已用于所有主要的关系数据库，以及大量的非关系数据库。</li>
</ul>
<p>日志结构的存储引擎是一个相对较新的方案。其关键思想是系统地将磁盘上随机访问写入转为顺序写入，由于硬盘驱动器和SSD的性能特性，可以实现更高的写入吞吐量。下面将针对这两种存储引擎进行分析。</p>
<h2 id="1-LSM-Tree"><a href="#1-LSM-Tree" class="headerlink" title="1. LSM-Tree"></a>1. LSM-Tree</h2><p>LSM-Tree(Log-Structured Merge Tree)广泛用于key-value存储引擎库中，如LevelDB和RocksDB，类似的存储引擎还用于Cassandra和HBase中，它的主要特征包括：1）数据顺序写入，不支持更新（更新及删除通过压缩合并数据段来实现）；2）数据写入操作内存表，数据异步写入磁盘；3）数据以SSTable段的形式写入磁盘，按照key进行排序，定期对数据段进行压缩合并；4）在内存中建立索引，由于数据段已经排序，只需要记录段首的记录即可。其结构如下所示：<br><img src="/images/lsm-tree.jpg" alt="lsm-tree" title="lsm-tree"></p>
<p>LSM-Tree存储引擎数据存储于SSTables中，一个SSTables表示一个数据段，存储的是key-value值，且按照key进行排序，这种格式也称为排序字符串表。SSTables有两种形式，在内存中，采用的数据结构主要是树状数据结构，如红黑树或AVL树，进行内存排序；内存中的SSTables大于某个阈值时，顺序写入到磁盘中的日志文件中。</p>
<p>LSM-Tree存储引擎的工作流程如下：</p>
<ul>
<li>当写入时，将其添加到内存中的平衡树数据结构中（例如红黑树）。这个内存中的树有时也被称为内存表；</li>
<li>当内存表大于某个阈值（通常为几兆字节）时，将其作为SSTable文件写入到磁盘。由于树已经维护了按照key排序的key-value对，写磁盘可以比较高效。新的SSTable文件成为数据库的最新部分。当SSTable写磁盘的同时，写入可以继续添加到一个新的内存表实例；</li>
<li>为了处理读请求，首先尝试在内存表中查找key,然后是最新的磁盘段文件，接下来是次新的磁盘段文件，以此类推，直到找到目标；</li>
<li>后台进程周期性执行段合并及压缩过程，以合并多个段文件，并丢弃那些已经被覆盖或删除的值；</li>
<li>每个写入操作都会立即追加到一个WAL日志文件中，它记录了操作的内容，它的目的是在数据库崩溃之后恢复内存表，每当将内存表写入SSTable时，相应的日志可以被丢弃。</li>
</ul>
<p>数据库运行一段时间之后，磁盘上会生成多个SSTable文件，一个key可以包含在多个SSTable文件中，即一个key可以有多个版本。后台进程使用合并排序算法周期性地合并数据段，如下图所示。并发读取多个输入段文件，比较每个文件的第一个key，把最小的key（根据排序文件）拷贝到输出文件，并重复这个过程，最后会产生一个新的按key排序的合并段文件。当多个段包含相同的key时，可以保留最新段的值，并丢弃旧段中的值。<br>在文件中查找特定的key时，不需要在内存中保存所有key的索引，因为段是排序的，只需要一个内存索引来记录段首的key，可以减少内存的占用，同时可以进行区间查询。由于读请求往往需要扫描请求范围内的多个key-value对，可以考虑将这些记录保存到一个磁盘块中并在写磁盘前将其压缩。然后内存索引的每个条目指向压缩块的开关。除了节省磁盘空间，压缩还减少了I/O带宽的占用。</p>
<p><img src="/images/lsm-tree-combine.jpg" alt="lsm-tree-combine" title="lsm-tree-combine"></p>
<p>查找数据库中某个不存在的key时，LSM-Tree算法可能很慢：在确定key不存在之前，必须先检查内存表，然后将段一直回溯访问到最旧的段文件（可能必须从磁盘多次读取），为了优化这种访问，存储引擎通常使用额外的布隆过滤器。</p>
<h2 id="2-B-Tree"><a href="#2-B-Tree" class="headerlink" title="2. B-Tree"></a>2. B-Tree</h2><p>B-Tree是关系数据库中被广泛使用的索引结构，像SSTable一样，B-Tree留按照key排序的key-value对，这样可以实现高效的key-value查找和区间查询。从本质上来说，B-Tree具有非常不同的设计理念。<br>在LSM-Tree中，日志结构索引将数据库分解为可变大小的段，通常大小为几兆字节或更大，并且始终按顺序写入段。相比之下，B-Tree将数据库分解为固定大小的块或页，传统上大小为4 KB（有时更大），页是内部读/写的最小单元。这种设计更接近底层硬件，因为磁盘也是以固定大小的块排列。<br>每个页面都可以使用地址或位置进行标识，这样可以让一个页面引用另一个页面，类似指针，不过是指向磁盘地址，而不是内存，可以使用这些页面引用来构造一个树状页面，如下所示。<br><img src="/images/b-tree.jpg" alt="b-tree" title="b-tree"><br>某一页被指定为B-Tree的根，每当查找索引中的一个key时，总是从这里开始。该页面包含若干个key和对子页的引用。每个孩子都负责一个连续范围内的key,相邻引用之间的key可以指示这些范围之间的边界。<br>假定正在查找key 251,需要沿着200~300间的页引用，到达类似的页，它进一步将200~300范围分解成子范围。最终到达一个包含单个key的页(叶子页)，该页包含每个内联key的值或包含找到值的页的引用。<br>B-Tree中每一个页所包含的子页引用数量称为分支因子，例如在上图中，分支因子为6，在实际中，分支因子取决于存储页面引用和范围过界所需的空间总量，通常为几百个。<br>在正常情况下，数据库表一般只包含一个主键索引，如上图中以user_id为主键的索引。在主键索引中根据叶子结点中存储记录的内容还是引用，可以分为聚集索引和非聚集索引，而二级索引引用主键，如下图所示，在user_name上建立一个二级索引，它引用的值是主键。<br><img src="/images/b-tree-index.jpg" alt="b-tree-index" title="b-tree-index"></p>
<p>如果更新B-Tree中原有的值，首先搜索包含该key的叶子页，更改该页的值，并将页定回到磁盘（对该页的任何引用仍然有效）。如果要添加新key，则需要找到其范围包含新key的页，并将其添加到该页，如果页中没有足够的可用空间来容纳新key，则将其分裂为两个半满的页，并且父页也需要更新以包含分裂之后的新key范围，如下图所示：<br><img src="/images/b-tree-split.jpg" alt="b-tree-split" title="b-tree-split"><br>该算法确保树保持平衡：具有n个key的B-Tree总是具有O(log n)的深度，大多数数据库可以适合3~4层的B-Tree，因此不需要遍历非常深的页面层次即可找到所需的页（分支因子为500的4 KB页的四级树可以存储高达256 TB）。</p>
<p>为了使数据库能从崩溃中恢复，常见的B-Tree的实现需要支持磁盘上的额外的数据结构：预写日志（Write-ahead log,WAL），也称为重做日志。这是一个仅支持追加修改的文件，每一个B-Tree的修改必须先更新WAL然后再修改树本身的页。当数据库在崩溃后需要恢复时，该日志用于将B-Tree恢复到最近一致的状态。</p>
<h2 id="3-对比B-Tree和LSM-Tree"><a href="#3-对比B-Tree和LSM-Tree" class="headerlink" title="3. 对比B-Tree和LSM-Tree"></a>3. 对比B-Tree和LSM-Tree</h2><p>根据经验，LSM-Tree通常对于写入更快，而B-Tree被认为对于读取更快。读取通常在LSM-Tree上较慢，主要是因为它们必须在不同的压缩阶段检查多个不同的数据结构和SSTable。</p>
<h3 id="3-1-磁盘写入"><a href="#3-1-磁盘写入" class="headerlink" title="3.1 磁盘写入"></a>3.1 磁盘写入</h3><p>B-Tree索引必须至少写两次数据：一个写入预写日志，一次写入树的页本身（还可能发生页分裂）。即使该页中只有几个字节更改，也必须承受整个页的开销。另外，B-Tree存储引擎使用与磁盘类似的分页结构，存在磁盘的碎片化。<br>LSM-Tree数据通常是写入内存表，内存表达到一定阈值的时候再统一写入磁盘，对于磁盘上的SStable段文件由后台线程进行合并压缩，效率更高，同时也会减少磁盘碎片。相对B-Tree来说，具有更高的写入吞吐量。</p>
<h3 id="3-2-事务支持"><a href="#3-2-事务支持" class="headerlink" title="3.2 事务支持"></a>3.2 事务支持</h3><p>B-Tree的优点则是每个键都恰好唯一对应于索引中的某个位置，而日志结构的存储引擎可能在不同的段中具有相同键的多个副本。如果数据库希望提供强大的事务语义，B-Tree显得更具吸引力：在许多关系数据库，事务隔离是通过键范围上的锁来实现的，并且在B-Tree索引中，这些锁可以直接定义到树中。</p>
<p><strong>参考：</strong></p>
<hr>
<p><a href="https://book.douban.com/subject/30329536/" target="_blank" rel="noopener">1. 数据密集型应用系统设计</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/25/non-functional-features-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/04/25/non-functional-features-1/" class="post-title-link" itemprop="http://yoursite.com/page/4/index.html">系统设计-非功能性特性</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-04-25 20:49:32" itemprop="dateCreated datePublished" datetime="2020-04-25T20:49:32+08:00">2020-04-25</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-07-31 17:17:10" itemprop="dateModified" datetime="2021-07-31T17:17:10+08:00">2021-07-31</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/非功能性特性/" itemprop="url" rel="index"><span itemprop="name">非功能性特性</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">2.7k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">2 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在大多数软件系统中，功能特性决定了系统能做什么，而非功能特性决定了系统能走多远，本篇文章专注于非功能特性中三个比较重要的特性：</p>
<ul>
<li>可靠性（Reliability）：当出现意外情况如硬件、软件故障、人为失误等，系统应可以继续正常运转：虽然性能可能有所降低，但确保功能正确。</li>
<li>可扩展性（Scalability）:随着规模的增长，例如数据量、流量或复杂性，系统应以合理的方式来匹配这种增长。</li>
<li>可维护性（Maintainability）：随着时间的推移，许多新的人员参与到系统开发和运维，以维护现有功能或适配新场景等，系统都应高效运转。</li>
</ul>
<h2 id="1-可靠性"><a href="#1-可靠性" class="headerlink" title="1. 可靠性"></a>1. 可靠性</h2><p>可靠性意味着即使发生故障，系统也可以正常工作。故障包括硬件（通常是随机的，不相关的），软件（缺陷通常是系统的，更加难以处理）以及人为（总是很难避免时不时会出错）方面。容错技术可以很好地隐藏某种类型故障，避免影响最终用户。</p>
<h2 id="2-可扩展性"><a href="#2-可扩展性" class="headerlink" title="2. 可扩展性"></a>2. 可扩展性</h2><p>可扩展性是指负载增加时，有效保持系统性能的相关技术策略。即使系统现在工作可靠，并不意味着它将来一定能够可靠运转。发生退化的一常见原因是负载增加：例如并发用户从最初的10 000个增长到100 000个，或从100万到1000万；又或者系统目前要处理的数据量超出之前很多倍。可扩展性是用来描述系统应对负载增加能力的术语，为了讨论可扩展性，首先需要明确如何定量描述负载和性能？</p>
<h3 id="2-1-负载"><a href="#2-1-负载" class="headerlink" title="2.1 负载"></a>2.1 负载</h3><p>负载可以用称为负载参数的若干数字来描述，参数的最佳选择取决于系统的体系结构，它可能是Web服务器的每秒请求处理次数，数据库写入的比例，聊天室的同时活动用户数量，缓存命中率等。有时平均值很重要，有时系统瓶颈来自于少数峰值。</p>
<p>以Twitter为例，使用其2012年11月发布的数据。Twitter的两个典型业务操作是：</p>
<ul>
<li>发布tweet消息：用户可以快速推送新消息到所有的关注者，平均大约4.6k requests/sec，峰值约12k requests/sec。</li>
<li>主页时间线（Home timeline）浏览：平均300k requests/sec 查看关注对象的最新消息。</li>
</ul>
<h3 id="2-2-性能"><a href="#2-2-性能" class="headerlink" title="2.2 性能"></a>2.2 性能</h3><p>如果负载增加将会发生什么，有两种考虑方式：</p>
<ul>
<li>负载增加，但系统资源（如CPU、内存、网络带宽等）保持不变，系统性能会发生什么变化；</li>
<li>负载增加，如果要保持性能不变，需要增加多少资源？</li>
</ul>
<p>这两个问题都会关注性能指标，那如何描述系统性能？</p>
<p>在批处理系统中如Hadoop中，通常关心吞吐量(throughput)，即每秒可处理的记录条数，或者在某指定数据集上运行作业所需的总时间；而在线系统通常更重服务的响应时间(response time)，即客户端从发送请求到接收响应之间的间隔。</p>
<p>服务的响应时间通常是使用服务请求的平均响应时间，即n个请求响应时间的算术平均值。然而，如果想知道多少用户实际经历了多少延迟，最好使用百分位数(percentiles)。如果已经搜集到响应时间信息，将其从最快到最慢排序，中位数(median)就是列表中间的响应时间。例如，如果中位数响应时间为200ms，那意味着有一半的请求响应不到200ms，而另一半请求则需要更长的时间。</p>
<p>中位数指标非常适合描述多少用户需要等待多长时间：一半的用户请求的响应时间少于中位数响应时间，另一半则多于中位数的时间。因此中位数也称为50百分位数，有时也缩写为p50。为了弄清楚异常有多糟糕，需要关注更大的百分位数如常见的第95、99和99.9（缩写为p95、p99和p999）值。作为典型的响应时间阈值，它们分别表示为95%、99%或99.9%的请求响应时间快于阈值。例如95百分位数响应时间为1.5s，这意味着100个请求中的95个请求快于1.5s，而5个请求则需要1.5s或更长的时间。</p>
<h2 id="3-可维护性"><a href="#3-可维护性" class="headerlink" title="3. 可维护性"></a>3. 可维护性</h2><p>可维护性则意味着许多方面，但究其本质是为了让工程和运营团队更为轻松。良好的抽象可以帮助降低复杂性，并使系统更易于修改和适配新场景。良好的可操作性意味着对系统健康状况有良好的可观测性和有效的管理方法。</p>
<p>可运维性在软件设计时就需要开始考虑，尽可能减少维护期间的麻烦，甚至避免造出容易过期的系统。为此，需要特别关注软件系统的三个设计原则：</p>
<ul>
<li>可运维性：方便运营团队来保持系统平衡地运行；</li>
<li>简单性：简化系统复杂性，使新工程师能够轻松理解系统。</li>
<li>可演化性：后续工程师能够轻松对系统进行改进，并根据需求变化将其适配到非典型场景，也称为可延伸性、易修改性或可塑性。</li>
</ul>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>知易行难，使应用程序可靠、可扩展或可维护并不容易，需要结合使用的场景选择不同的策略和技术。</p>
<p><strong>参考：</strong></p>
<hr>
<p><a href="https://book.douban.com/subject/30329536/" target="_blank" rel="noopener">1. 数据密集型应用系统设计</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/20/rocketmq-namesrv-overview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/01/20/rocketmq-namesrv-overview/" class="post-title-link" itemprop="http://yoursite.com/page/4/index.html">RocketMQ系列：NameServer概览</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-01-20 18:27:30" itemprop="dateCreated datePublished" datetime="2020-01-20T18:27:30+08:00">2020-01-20</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-07-31 17:17:10" itemprop="dateModified" datetime="2021-07-31T17:17:10+08:00">2021-07-31</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/rocketmq系列/" itemprop="url" rel="index"><span itemprop="name">rocketmq系列</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">2.6k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">2 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>NameServer 作为消息中间件 RocketMQ 的核心组件之一， 起着注册中心的作用，这篇文章主要是从整体上分析一下NameServer的实现。<br><img src="/images/rocketmq-namesrv-overview.jpg" alt="rocketmq-namesrv-overview" title="rocketmq-namesrv-overview"><br>NameServer可以分为三个层次（暂且这么分，方便理解），1）通信层，使用 Netty 作为底层通信组件，封装统一的网络 IO 事件处理流程，同时用户也可以自定义事件。2）服务层，封装通用的业务逻辑：a）统一请求处理流程；b）定义三种调用方式，如同步调用，异步调用及单向调用（发出请求不需要响应数据）；c）响应超时处理；d）IO事件处理。3）业务层，实现请求处理器及事件监听器注册接口，处理NameServer相关的数据，如broker地址及保活信息、topic队列信息及服务器过滤信息。</p>
<ul>
<li><p>通信层：Netty 使用 Reactors 的多线程模型，MainReactor 负责客户端的连接请求，并将请求转交给 SubReactor，SubReactor 负责相应通道的 IO 读写请求。在这里，BossGroup 承担MainReactor的角色，一般只需要一个线程即可（一个 EventLoop 实质就是一个线程），Work Group 承担 SubReactor 的角色，在RomcketMQ中默认是三个线程。从上面的关系可以看出，EventLoopGroup 包含多个 EventLoop，而一个 EventLoop 代表了一个独立的事件循环，循环等待 IO 事件，一般由一个线程来处理，一个 EventLoop 可以同时处理多个 tcp 连接（Channel），同时一个 Channel 所有事件只能在一个 EventLoop 中处理，一个 Channel 一旦分配给一个 EventLoop 之后将不会改变这种关联关系。在 Netty 中事件处理使用了责任链的模式，将事件处理分为不同的处理单元，让数据以水流的方式在管道中流动处理，每一个阀门都有一个独立的处理逻辑，这些处理单元包括但不限此，如数据的编/解码、数据的转换、空闲连接的检测及数据的消费，在 Netty 中，这些处理单元叫做 Handler 对象。每一个 Handler 对象存储在 ChannelHandlerContext 对象中，再将 ChannelHandlerContext 对象串连起来，形成一个双向链表。根据处理事件的不同，Handler 对象可以分为出站或入站对象，入站代表读事件，出站代表了写事件，所以，访问 ChannelHandlerContext 链表也分为出站和入站两种，入站从链首开始，正向访问，而出站则从链尾开始，反向访问。 在 ChannelPipeline 对象中，存储 ChannelHandlerContext 链表的链首及链尾对象，每一个 Channel 对象都会关联一个 ChannelPipeline 对象，在处理事件的时候，可方便调用相应的 Handler 对象，上层应用只要定义相应的 Handle对象 到Netty中即可。下图是 EventLoop 处理事件的流程。<br><img src="/images/rocketmq-namesrv-netty.jpg" alt="rocketmq-namesrv-netty" title="rocketmq-namesrv-netty"><br>可以看到，EventLoop 主要处理三件事：1）在多路复用器 Selector 上调用 select 方法，监听所有的 Channel的 IO 事件；2）执行 IO 处理流程，调用 ChannelHandlerContext 链表，执行业务处理；3）执行提交的任务，在 EventLoop 中，可以处理定时任务，在处理完业务逻辑之后，会调用已经到期的任务执行。定时任务存放在一个优先级队列（scheduleTaskQueue队列，实现类为PriorityQueue队列）中，按照时间进行排序，执行任务前会将已经到期的任务移到 taskQueue 队列中，然后依次执行 taskQueue 队列中的所有任务。</p>
</li>
<li><p>服务层：定义了四个基本功能，1）统一请求处理流程，每一个命令可以注册一个处理器（Processor对象）及处理线程池，不同业务请求可以由不同的线程池处理，这样有做到业务隔离和提高并发处理能力；2）定义了三种调用方式，分别是同步调用、异步调用及单向调用（发出请求不需要响应数据），同步调用及异步调用都是使用 Future 对象来实现，区别在于：同步调用需要在 Future 对象上等待一个超时时间，而异步调用只需定义一个回调方法即可；3）响应超时处理，在异步调用中，调用结束之后程序已经返回了，响应的数据需要在另外一个线程处理，为了方便响应数据找到对应的请求，需要构造一个 Future 对象存储到响应结果表中，请求及响应数据包含相同的请求序号，可以方便地从表中检索到 Future 对象，调用对应的回调函数。在这里，有一个问题，如果一直没有响应怎么办？这就需要一个线程定时扫描响应结果表，将已经超时的请求移除响应结果表；4）IO事件处理，主要包括连接、空闲、关闭及异常事件，上层应用注册事件监听器（ChannelEventListener）来处理相关的事件。</p>
</li>
<li><p>业务层：业务层维护了 broker 地址及保活信息、topic 队列信息及服务器过滤信息，Broker 定期向 NameServer 发送心跳信息，心跳信息中就包含了这些信息，另外生产者和消费者也会向 NameServer查询Broker及topic的信息，业务层通过向服务层注册请求处理器（Processor对象）及事件监听器（ChannelEventListener对象），来处理心跳、查询等请求。</p>
</li>
</ul>
<p>通过上面的分析可以看出，NameServer 在设计结构比较清晰，在业务处理过程中，使用了异步的处理方式，大大提高了服务器的处理能力。</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/08/java-stream-pipeline/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/12/08/java-stream-pipeline/" class="post-title-link" itemprop="http://yoursite.com/page/4/index.html">Java Stream Pipeline</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-12-08 20:13:30" itemprop="dateCreated datePublished" datetime="2019-12-08T20:13:30+08:00">2019-12-08</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-07-31 17:17:10" itemprop="dateModified" datetime="2021-07-31T17:17:10+08:00">2021-07-31</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java基础/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">35k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">32 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><blockquote>
<p>Java 8中的Stream是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作（Aggregate operation），或者大批量数据操作(Bulk data operation)。Stream API借助于同样新出现的Lambda表达式，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用fork/join并行方式来拆分任务和加速处理过程<sup>1</sup>。</p>
</blockquote>
<p>这篇文章重点分析Stream背后的数据结构及执行流程，以下面代码为例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">int</span> sum = list.stream().filter(x -&gt; x % <span class="number">2</span> == <span class="number">0</span>).sorted(Comparator.reverseOrder()).map(x -&gt; x * x).reduce((x, y) -&gt; x + y).get();</span><br></pre></td></tr></table></figure></p>
<p>在这段执行代码之后，将会生成以下的数据结构：</p>
<p><img src="/images/java-stream-pipeline.jpg" alt="java-stream-pipeline" title="java-stream-pipeline"></p>
<ul>
<li>操作的定义：对数据的一次处理，如过滤(filter)，排序(sorted)，映射(map)及规约（reduce）等等。操作有三种类型：1)Head，头结点，没有实际操作，包含了数据源；2)ReferencePipeline，中间操作，代表了一次数据处理；3)TerminalOp，结束操作，代表处理的结束。</li>
<li>ReferencePipeline对象代表了一次中间操作，描述了操作的静态信息，Stream执行的一次中间操作之后都会生成一个ReferencePipeline对象(StatelessOp及StatefulOp)，这些对象在最终操作（reduce）之前会形成一个双向链表，此时只是建立操作的前后关系，还未执行真正的操作。</li>
<li>Sink对象代表了真正的所要执行的操作，执行terminal操作(如reduce)之后，将会从后往前生成一个”操作序列”，如上图所示的wrapedSink对象。每一个ReferencePipeline对象对应一个Sink对象，代表了ReferencePipeline所要执行的操作，前一个Sink对象会持有下一个操作的Sink对象，形成一个单向链表。</li>
<li>Sink对象有四个基本方法：1）begin()，操作的开始；2）end()，代表操作结束；3）accept(E e)，真正的操作,如filter,sorted,map及reduce等数据处理；4）cancellationRequested，是否取消操作，用于断路操作，如anyMatch表示找到第一个匹配的对象，后面的数据不用再执行，直接退出；Sink对象根据需要实现这四个方法，来满足不同的数据处理需求。</li>
<li>ReferencePipeline对象有两种不同的类型：StatelessOp（无状态操作）和StatefulOp（有状态操作），这两种类型的区别就在于数据元素之间是否有依赖，如排序(sotred)操作，是一个有状态操作，需要知道所有数据元素才能进行排序，它会临时生成一个列表存放所有的数据，排序之后，重新迭代处理后面的操作，而对于无状态操作，前一个数据元素的操作与后一个数据元素操作没有关系，可以直接将多个无状态操作合并起来，即前一个操作结束之后，可将操作结果直接传给下一个操作（downstream）,在一次迭代中将所有操作执行完毕，这就是Stream处理数据高效的原因。相对而言，有状态操作会存储临时结果，重起一次迭代，而无状态操作一次迭代即可完成所有操作，如上图所示，因为有sorted操作，所有的数据处理需要两次迭代完成。</li>
<li>上图中的执行流程是一个没有短路操作（后面会讲短路操作的流程）的流程，可以看到，主要分为三个步骤：1）执行begin()，进行初始化操作；2）执行accept()，数据处理；3）执行end()操作，进行数据收尾操作，这三个操作会递归调用，直到碰到有状态操作或结束操作才结束，如果碰到的是有状态操作，如sorted，前一个迭代的end操作将会触发下一个迭代的开始。</li>
</ul>
<p>在文章开始前，先讲述下几个重要概念：<br>1、Stream</p>
<blockquote>
<p>A sequence of elements supporting sequential and parallel aggregate operations.  The following example illustrates an aggregate operation using<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = widgets.stream()</span><br><span class="line">                   .filter(w -&gt; w.getColor() == RED)</span><br><span class="line">                   .mapToInt(w -&gt; w.getWeight())</span><br><span class="line">                   .sum();</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>2、AbstractPipeline</p>
<blockquote>
<p>Abstract base class for “pipeline” classes, which are the core implementations of the Stream interface and its primitive specializations. Manages construction and evaluation of stream pipelines.<br>An AbstractPipelinere presents an initial portion of a stream pipeline, encapsulating a stream source and zero or more intermediate operations. The individual AbstractPipeline objects are often referred to as stages, where each stage describes either the stream source or an intermediate operation.</p>
</blockquote>
<p>3、Sink</p>
<blockquote>
<p>An extension of Consumer used to conduct values through the stages of a stream pipeline, with additional methods to manage size information, control flow, etc.  Before calling the  accept() method on a code Sink for the first time, you must first call the  begin() method to inform it that data is coming (optionally informing the sink how much data is coming), and after all data has been sent, you must call the end() method.  After calling end(), you should not call accept() without again calling begin(). Sink also offers a mechanism by which the sink can cooperatively signal that it does not wish to receive any more data (the cancellationRequested() method), which a source can poll before sending more data to the Sink.</p>
</blockquote>
<h2 id="2-AbstractPipeline"><a href="#2-AbstractPipeline" class="headerlink" title="2. AbstractPipeline"></a>2. AbstractPipeline</h2><p>在Stream中执行的一个数据处理都对应一个操作，最终以双向链表的形式组织起来，而操作的类型分为三种：1）head头结点；2）ReferencePipeline，中间操作；3）TerminalOp，结束操作，实际上head头结点也是ReferencePipeline类型，只是它有点特殊，它没有实际的操作，所以单独把它拿出来。ReferencePipeline中间操作分为两种操作：1）有状态操作(StatefulOp)；2）无状态操作（StatelessOp）,两者的操作在上面内容已经讲述过，在这里不再赘述。TerminalOp结束操作也分为两种操作：1）非短路操作；2）短路操作，这两者之间的区别在短路操作会终止后续的操作，提前返回，关于短路操作在后面的内容重点讲述。这几种分类如下图所示：</p>
<table width="600"><tr><td colspan="3" style="text-align:center" border="0">Stream操作分类</td></tr><tr><td rowspan="2" border="1">中间操作(Intermediate operations)</td><td>无状态(Stateless)</td><td>unordered() filter() map() mapToInt() mapToLong() mapToDouble() flatMap() flatMapToInt() flatMapToLong() flatMapToDouble() peek()</td></tr><tr><td>有状态(Stateful)</td><td>distinct() sorted() sorted() limit() skip() </td></tr><tr><td rowspan="2" border="1">结束操作(Terminal operations)</td><td>非短路操作</td><td>forEach() forEachOrdered() toArray() reduce() collect() max() min() count()</td></tr><tr><td>短路操作(short-circuiting)</td><td>anyMatch() allMatch() noneMatch() findFirst() findAny()</td></tr></table>

<p>中间操作的类图如下所示：<br><img src="/images/ReferencePipeline.jpg" alt="ReferencePipeline" title="ReferencePipeline"><br>Head,Stateful及StatelessOp都继承自ReferencePipeline类，Head相对其它两种类型，没有实际的操作，只是包含了一个数据源。另外，这三个类也实现了Stream接口，每一个操作都可以继续调用下一个操作，实现链式调用。<br>ReferencePipeline类，有两个比较重要的作用：1）将中间操作以双向链表的形式组织起来，方便后面构建”操作序列”（Sink对象链）；2）构建当前操作的Sink对象，该对象是包含了真正的处理流程。以map方法为例介绍这两个作用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R&gt; <span class="function">Stream&lt;R&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> P_OUT, ? extends R&gt; mapper)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(mapper);</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StatelessOp&lt;P_OUT, R&gt;(<span class="keyword">this</span>, StreamShape.REFERENCE,</span><br><span class="line">                                 StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function">Sink&lt;P_OUT&gt; <span class="title">opWrapSink</span><span class="params">(<span class="keyword">int</span> flags, Sink&lt;R&gt; sink)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Sink.ChainedReference&lt;P_OUT, R&gt;(sink) &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(P_OUT u)</span> </span>&#123;</span><br><span class="line">                    downstream.accept(mapper.apply(u));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在map方法调用中，会生成一个StatelessOp对象，在构造函数中将当前的Pipeline对象（this对象）作为参数传递给新生成的对象，该StatelessOp对象继承了AbstractPipeline抽象类，在AbstractPipeline类中通过nextStage、previousStage两个字段将前后两个操作建立起前后的关联关系，代码如下图所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> previousStage 前一个阶段的操作,就是构建函数中传入的this对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> opFlags the operation flags for the new stage 操作的标志</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">AbstractPipeline(AbstractPipeline&lt;?, E_IN, ?&gt; previousStage, <span class="keyword">int</span> opFlags) &#123;</span><br><span class="line">    <span class="keyword">if</span> (previousStage.linkedOrConsumed)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(MSG_STREAM_LINKED);</span><br><span class="line">    previousStage.linkedOrConsumed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 上一个阶段(前一个操作)的nextStage指向当前的StatelessOp对象</span></span><br><span class="line">    previousStage.nextStage = <span class="keyword">this</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前对象的previousStage指向上一个阶段的对象(前一个操作)</span></span><br><span class="line">    <span class="keyword">this</span>.previousStage = previousStage;</span><br><span class="line">    <span class="keyword">this</span>.sourceOrOpFlags = opFlags &amp; StreamOpFlag.OP_MASK;</span><br><span class="line">    <span class="keyword">this</span>.combinedFlags = StreamOpFlag.combineOpFlags(opFlags, previousStage.combinedFlags);</span><br><span class="line">    <span class="keyword">this</span>.sourceStage = previousStage.sourceStage;</span><br><span class="line">    <span class="keyword">if</span> (opIsStateful())</span><br><span class="line">        sourceStage.sourceAnyStateful = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.depth = previousStage.depth + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外，在StatelessOp对象的opWrapSink方法中，构建了一个Sink.ChainedReference对象，该对象包含了map的处理逻辑。这个方法相对比较简单，数据用mapper方法处理完之后，将结果传递给下个操作(downstream)处理，其中mapper对应是Lamdba表达式：x -&gt; x * x。</p>
<p>TerminalOp终止操作的类图如下所示：<br><img src="/images/TerminalOp.jpg" alt="TerminalOp" title="TerminalOp"><br>TerminalOp有四种类型，分别是：1）ForEachOp；2）FindOp；3）MatchOp；4）ReduceOp。表格中提到的所有终止操作都是基于这四种类型来实现的，另外终止类型的操作并没有加入到由ReferencePipeline组成的双向链表中。<br>最后的终止操作是通过调用诸如forEach(), reduce(), collect(), anyMatch()等这些方法来触发的，这些方法最终会调用ReferencePipeline类中的evaluate()方法来完成操作，在evaluate()方法，生成一个TerminalOp对象，且封装了一个统一的处理流程，现在来看下这个evaluate()方法，其流程如下：<br><img src="/images/stream-evaluate.jpg" alt="stream-evaluate" title="stream-evaluate"></p>
<ul>
<li>根据不同的终止操作生成不同的TerminalOp对象，可以是上面四种类型中的任意一种；</li>
<li>构建数据源Spliterator；</li>
<li>执行evaluate()方法的中间操作ReferencePipeline对象合并TerminalOp对象的操作标志位，如是否短路操作等等；</li>
<li>判断执行的模式，并发模式暂不分析，我们主要分析Sequential模式；</li>
<li>从TerminalOp对象中构建TerminalSink对象；</li>
<li>从后往前遍历中间操作（ReferencePipeline）对象，构建每一个中间操作对应的Sink对象，并将这些Sink对象从前往后生成链表，TerminalSink对象在链尾；</li>
<li>根据操作标志位判来触发真正的动作，如短路操作，或者非短路操作，该部分内容在后面讲述；</li>
</ul>
<p>在这里重点看一个步骤：包装Sink对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sink TerminalSink对象,链尾对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 链首Sink对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">final</span> &lt;P_IN&gt; <span class="function">Sink&lt;P_IN&gt; <span class="title">wrapSink</span><span class="params">(Sink&lt;E_OUT&gt; sink)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(sink);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历所有的中间操作</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>) AbstractPipeline p=AbstractPipeline.<span class="keyword">this</span>; p.depth &gt; <span class="number">0</span>; p=p.previousStage) &#123;</span><br><span class="line">        sink = p.opWrapSink(p.previousStage.combinedFlags, sink);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (Sink&lt;P_IN&gt;) sink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过wrapSink方法，从后往前遍历所有的AbstractPipeline对象，生成每个操作对应的Sink对象，并将后一个Sink对象作为参数传入，赋值给dowonstream字段，从而将所有的Sink对象串连起来，通过链首的Sink对象访问所有的Sink对象。</p>
<h2 id="3-Sink"><a href="#3-Sink" class="headerlink" title="3. Sink"></a>3. Sink</h2><p>Sink对象是扩展自Comsumer接口，主要用来处理数据，除了Comsumer接口的accept()方法，还增加了三个方法：begin(),end()及cancellationRequested()。在调用accept()方法之前，先调用begin(int size)方法，告之数据源的大小，调用accept()方法之后，再调用end()方法，通知数据处理已经结束，如果有短路操作（中止后续数据的处理），必须先调用cancellationRequested()方法，这两种处理模式如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非短路操作</span></span><br><span class="line"><span class="keyword">if</span> (!StreamOpFlag.SHORT_CIRCUIT.isKnown(getStreamAndOpFlags())) &#123;</span><br><span class="line">    <span class="comment">// 1、调用begin()方法，告之数据源大小；</span></span><br><span class="line">    wrappedSink.begin(spliterator.getExactSizeIfKnown());</span><br><span class="line">    <span class="comment">// 2、遍历数据源元素，调用wrappedSink.accept()方法处理数据；</span></span><br><span class="line">    spliterator.forEachRemaining(wrappedSink);</span><br><span class="line">    <span class="comment">// 3、处理完数据之后，调用end()方法</span></span><br><span class="line">    wrappedSink.end();</span><br><span class="line">	</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  <span class="comment">// 短路操作</span></span><br><span class="line">    <span class="comment">// 调用begin()方法，告之数据源大小；</span></span><br><span class="line">    wrappedSink.begin(spliterator.getExactSizeIfKnown());</span><br><span class="line">    <span class="comment">// 2、遍历数据源元素，调用wrappedSink.accept()方法处理数据，</span></span><br><span class="line">    <span class="comment">// 如果上一个元素设置了“短路”标志，说明数据已经完毕，则退出遍历；</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!wrappedSink.cancellationRequested() &amp;&amp; spliterator.tryAdvance(wrappedSink));</span><br><span class="line">    <span class="comment">// 3、处理完数据之后，调用end()方法</span></span><br><span class="line">    wrappedSink.end();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面的代码可以看出，所有的操作都是在一次遍历中完成的，对数据的处理操作已经按照书写顺序串连起来，即Sink对象链表，数据源中的每一个元素依次传递给Sink对象，被Sink对象的accept()方法处理，如果是短路操作，则需要设置”短路”标志，在处理下一个数据元素时，调用cancellationRequested()方法便可知道数据已经处理完毕，退出遍历返回即可。这里有两个问题，1）“短路”标志是如何设置的？2）数据的处理是否只需要一次遍历？<br>1) “短路”标志设置<br>在两个地方需要判断“短路”标志，一个是根据“短路”标志，是否执行“短路”操作，另外一个是在遍历数据源的过程中，判断数据处理是否已经被取消，需要中止操作，以anyMatch()方法为例。<br><img src="/images/short_circuit-1.jpg" alt="short_circuit-1" title="short_circuit-1"><br>如上图所示，判断“短路”的逻辑如下：</p>
<ul>
<li><p>在短路操作的TerminalOp对象中设置短路的标志位；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MatchOp.getOpFlags()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOpFlags</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> StreamOpFlag.IS_SHORT_CIRCUIT | StreamOpFlag.NOT_ORDERED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将TerminalOp对象中短路标志位合并到最后一个ReferencePipeline对象的combinedFlags中；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractPipeline.sourceSpliterator()</span></span><br><span class="line"><span class="keyword">if</span> (terminalFlags != <span class="number">0</span>)  &#123;</span><br><span class="line">    <span class="comment">// Apply flags from the terminal operation to last pipeline stage</span></span><br><span class="line">    combinedFlags = StreamOpFlag.combineOpFlags(terminalFlags, combinedFlags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据combinedFlags判断是否执行短路操作；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractPipeline.copyInto()</span></span><br><span class="line"><span class="keyword">if</span> (!StreamOpFlag.SHORT_CIRCUIT.isKnown(getStreamAndOpFlags())) &#123;</span><br><span class="line">    wrappedSink.begin(spliterator.getExactSizeIfKnown());</span><br><span class="line">    spliterator.forEachRemaining(wrappedSink);</span><br><span class="line">    wrappedSink.end();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    copyIntoWithCancel(wrappedSink, spliterator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>中止操作的逻辑如下：<br><img src="/images/short_circuit-2.jpg" alt="short_circuit-2" title="short_circuit-2"><br>在MatchSink中一个stop的字段，如果找到匹配的数据，则设置stop=true，在进行下一个数据匹配之前递归调用cancellationRequested()，取得stop的值，从而中止操作。</p>
<ul>
<li><p>找到匹配的数据并设置stop；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MatchSink.accept()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 条件匹配</span></span><br><span class="line">    <span class="keyword">if</span> (!stop &amp;&amp; predicate.test(t) == matchKind.stopOnPredicateMatches) &#123;</span><br><span class="line">        stop = <span class="keyword">true</span>; <span class="comment">// 设置stop</span></span><br><span class="line">        value = matchKind.shortCircuitResult;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对下一个数据元素进行数据处理前递归调用cancellationRequested()方法，调用到TerminalSink，结束调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReferencePipeline.forEachWithCancel()</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEachWithCancel</span><span class="params">(Spliterator&lt;P_OUT&gt; spliterator, Sink&lt;P_OUT&gt; sink)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理下一个数据之前调用cancellationRequested()方法</span></span><br><span class="line">    <span class="keyword">do</span> &#123; &#125; <span class="keyword">while</span> (!sink.cancellationRequested() &amp;&amp; spliterator.tryAdvance(sink));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ChainedReference.cancellationRequested()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancellationRequested</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归调用一个Sink的cancellationRequested()方法</span></span><br><span class="line">    <span class="keyword">return</span> downstream.cancellationRequested();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BooleanTerminalSink.cancellationRequested</span></span><br><span class="line"><span class="comment">// 调用到TerminalSink，结束调用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancellationRequested</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> stop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>2）遍历次数<br>中间操作ReferencePipeline对象分为两种类型：1）无状态操作StatelessOp；2）有状态操作StatefulOp。这两种操作的区别在于：在无状态操作StatelessOp中数据元素没有依赖关系，每一个数据元素可以独立处理，而有状态操作StatefulOp中数据元素的处理依赖其它元素，每一个元素不能独立处理，以filter()和sorted()两个方法为例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReferencePipeline.filter()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Stream&lt;P_OUT&gt; <span class="title">filter</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> P_OUT&gt; predicate)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(predicate);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StatelessOp&lt;P_OUT, P_OUT&gt;(<span class="keyword">this</span>, StreamShape.REFERENCE,</span><br><span class="line">                                 StreamOpFlag.NOT_SIZED) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function">Sink&lt;P_OUT&gt; <span class="title">opWrapSink</span><span class="params">(<span class="keyword">int</span> flags, Sink&lt;P_OUT&gt; sink)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Sink.ChainedReference&lt;P_OUT, P_OUT&gt;(sink) &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">(<span class="keyword">long</span> size)</span> </span>&#123;</span><br><span class="line">                    downstream.begin(-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(P_OUT u)</span> </span>&#123;</span><br><span class="line">					<span class="comment">// 如果满足过滤条件，则传递给下一个Sink处理</span></span><br><span class="line">                    <span class="keyword">if</span> (predicate.test(u))</span><br><span class="line">                        downstream.accept(u);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在StatelessOp操作中，经过本阶段的Sink处理完毕之后，会将数据元素继续传递给下一个Sink对象处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sorted()方法对应的Sink对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RefSortingSink</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractRefSortingSink</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 临时生成一个列表对象</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;T&gt; list;</span><br><span class="line"></span><br><span class="line">    RefSortingSink(Sink&lt;? <span class="keyword">super</span> T&gt; sink, Comparator&lt;? <span class="keyword">super</span> T&gt; comparator) &#123;</span><br><span class="line">        <span class="keyword">super</span>(sink, comparator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">(<span class="keyword">long</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size &gt;= Nodes.MAX_ARRAY_SIZE)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(Nodes.BAD_SIZE);</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 2. 列表对象初始化，一般生成不限长度的列表</span></span><br><span class="line">        list = (size &gt;= <span class="number">0</span>) ? <span class="keyword">new</span> ArrayList&lt;T&gt;((<span class="keyword">int</span>) size) : <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 4. 进行排序操作</span></span><br><span class="line">        list.sort(comparator);</span><br><span class="line">	</span><br><span class="line">        <span class="comment">// 5. 重新遍历数据列表，处理后续的操作</span></span><br><span class="line">        downstream.begin(list.size()); <span class="comment">// 通知数据处理开始</span></span><br><span class="line">        <span class="comment">// 6. 判断是否进行“短路”操作</span></span><br><span class="line">        <span class="keyword">if</span> (!cancellationWasRequested) &#123;</span><br><span class="line">            <span class="comment">// 7. 执行非短路操作</span></span><br><span class="line">            list.forEach(downstream::accept);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 8. 执行短路操作</span></span><br><span class="line">            <span class="keyword">for</span> (T t : list) &#123;</span><br><span class="line">                <span class="keyword">if</span> (downstream.cancellationRequested()) <span class="keyword">break</span>;</span><br><span class="line">                downstream.accept(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 9. 通知数据处理结束</span></span><br><span class="line">        downstream.end();</span><br><span class="line">        list = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 3. 将数据元素添加到列表中</span></span><br><span class="line">        list.add(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于排序操作而言，需要知道所有的元素才能进行，所以它临时生成了一个新的列表对象，存储完所有的数据元素之后，再进行排序操作。最后遍历列表对象，重新执行短路/非短路操作，完成剩余的操作。</p>
<p>总上所述，在操作序列中只有无状态操作的话，只要遍历一次即可执行完所有操作，如果包含有状态操作，则每一个有状态操作者需要增加一次遍历。</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>通过上面的分析，Stream的实现有以下三个特点：1）通过链表的方式将操作序列串连起来，数据元素在这个链表中依次流动（传递），可以有效减少数据遍历的次数；2）定义了一套“协议”，规范了前后两个不同操作之间的交互方式，遵循了这套协议，不同操作可按不同顺序组合，完成不同的功能；3）借助Fork/Join框架，数据源可并发执行数据处理，显著提高数据处理的效率。</p>
<p><strong>参考：</strong></p>
<hr>
<p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/index.html" target="_blank" rel="noopener">1. Java 8 中的 Streams API 详解</a></p>
<p><a href="https://www.cnblogs.com/CarpenterLee/p/6637118.html" target="_blank" rel="noopener">2. 深入理解Java Stream流水线</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/19/java-fork-join/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/19/java-fork-join/" class="post-title-link" itemprop="http://yoursite.com/page/4/index.html">Java Fork/Join框架</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-19 14:15:31" itemprop="dateCreated datePublished" datetime="2019-11-19T14:15:31+08:00">2019-11-19</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-07-31 17:17:10" itemprop="dateModified" datetime="2021-07-31T17:17:10+08:00">2021-07-31</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/并发编程/" itemprop="url" rel="index"><span itemprop="name">并发编程</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">56k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">51 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>ForkJoinPool运用了Fork/Join原理，使用“分而治之”的思想，将大任务分拆成小任务，从而分配给多个线程并行执行，最后合并得到最终结果，加快计算。ForkJoinPool可以充分利用多cpu，多核cpu的优势，提高算法的执行效率，ForkJoinPool整体结构如下图所示：<br><img src="/images/fork-join.jpg" alt="fork-join" title="fork-join"></p>
<ul>
<li>ForkJoinPool：框架的主体，存放了工作队列数组，对线程、工作队列及任务进行统一的管理。</li>
<li>WorkQueue：工作队列，是任务存储的容器，也是实现Work-Stealing的关键数据结构。</li>
<li>ForkJoinWorkerThread：工作线程，是任务的执行单元。</li>
<li>ForkJoinTask：封装业务的执行逻辑，包括任务fork及join流程。</li>
</ul>
<h2 id="2-核心思想"><a href="#2-核心思想" class="headerlink" title="2. 核心思想"></a>2. 核心思想</h2><p>ForkJoinPool的两大核心就是分而治之(Divide and conquer)和工作窃取(Work Stealing)算法，下面先对两种算法作一个介绍，后面将会具体细节做说明，这部分内容来自 <a href="https://blog.hufeifei.cn/2018/09/15/Java/ForkJoinPool/" target="_blank" rel="noopener">holmofy</a>，作者进行了很好的总结。</p>
<h3 id="2-1-分而治之"><a href="#2-1-分而治之" class="headerlink" title="2.1 分而治之"></a>2.1 分而治之</h3><p>ForkJoinPool主要思想是：将一个大任务拆分成多个小任务后，使用fork可以将小任务分发给其他线程同时处理，使用join可以将多个线程处理的结果进行汇总。<br><img src="/images/devide-conquer.jpg" alt="devide-conquer" title="devide-conquer"></p>
<h3 id="2-2-工作窃取"><a href="#2-2-工作窃取" class="headerlink" title="2.2 工作窃取"></a>2.2 工作窃取</h3><p>Fork/Join框架中使用的work stealing灵感来源于Cilk(开发Cilk的公司被Intel收购，原项目后来被升级为Clik Plus)。</p>
<blockquote>
<p>Intel公司除了Clik Plus还有一个TBB(Threading Building Blocks)也是使用work stealing算法实现。</p>
</blockquote>
<p>Work Stealing算法是Fork/Join框架的核心思想：</p>
<ul>
<li>每个线程都有自己的一个WorkQueue，该工作队列是一个双端队列；</li>
<li>队列支持三个功能push、pop、poll；</li>
<li>push/pop只能被队列的所有者线程调用，而poll可以被其他线程调用；</li>
<li>划分的子任务调用fork时，都会被push到自己的队列中；</li>
<li>默认情况下，工作线程从自己的双端队列获出任务并执行；</li>
<li>当自己的队列为空时，线程随机从另一个线程的队列末尾调用poll方法窃取任务。<br><img src="/images/work-stealing.jpg" alt="work-stealing" title="work-stealing"></li>
</ul>
<h2 id="3-数据结构"><a href="#3-数据结构" class="headerlink" title="3. 数据结构"></a>3. 数据结构</h2><h3 id="3-1-ForkJoinPool"><a href="#3-1-ForkJoinPool" class="headerlink" title="3.1 ForkJoinPool"></a>3.1 ForkJoinPool</h3><p>ForkJoinPool中的几个关键字段如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">long</span> ctl;                   <span class="comment">// main pool control</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> runState;               <span class="comment">// lockable status</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> config;                    <span class="comment">// parallelism, mode</span></span><br><span class="line"><span class="keyword">int</span> indexSeed;                       <span class="comment">// to generate worker index</span></span><br><span class="line"><span class="keyword">volatile</span> WorkQueue[] workQueues;     <span class="comment">// main registry</span></span><br></pre></td></tr></table></figure></p>
<h4 id="3-1-1-ctl字段"><a href="#3-1-1-ctl字段" class="headerlink" title="3.1.1 ctl字段"></a>3.1.1 ctl字段</h4><p>ctl有64位，分成4组各16位，代表了不同的状态，在ForkJoinPool中是一个很重要的字段，很多控制逻辑都要根据ctl来完成，如下图所示：<br><img src="/images/ctl.jpg" alt="ctl" title="ctl"></p>
<ul>
<li>AC：活跃线程的数量，初始化-parallelism；</li>
<li>TC：所有线程的数量，初始化-parallelism；</li>
<li>SS：表示空闲线程栈（Treiber stack）栈顶元素的版本和状态；</li>
<li>ID：表示空闲线程栈（Treiber stack）栈顶元素在workQueues数组中的下标；</li>
</ul>
<p>parallelism表示ForkJoinPool的最大线程数，其最大值由MAX_CAP(32767)限定，默认情况下等于cpu的核数（Runtime.getRuntime().availableProcessors()），要改变这个值也可以通过构造函数设置。</p>
<p>为了方便运算，AC和TC初始化parallelism负值，当AC和TC为负数时，表示线程数未达到最大线程数，可以新建线程。SP是ctl的低32位，可通过sp=(int)ctl取到，如果是否零的情况下，表示有空闲线程。</p>
<p>在ForkJoinPool中，线程是绑定在WorkQueue上的，即一个线程必然有绑定WorkQueue（但WorkQueue不一定绑定线程，外部线程提交任务创建的WorkQueue绑定的线程为null）。ID存放的实际是空闲线程对应的WorkQueue在WorkQueue[]数组中的下标，后面为了描述的方便，统一说成是空闲线程的下标。下一个空闲线程（其实保存的也是WorkQueue[]的下标）保存在WorkQueue的stackPred字段中，讲到WorkQueue时，我们再对空闲线程栈进行深入描述。</p>
<p>ForkJoinPool中定义的常量字段：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bounds</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SMASK        = <span class="number">0xffff</span>;        <span class="comment">// short bits == max index</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_CAP      = <span class="number">0x7fff</span>;        <span class="comment">// max #workers - 1</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EVENMASK     = <span class="number">0xfffe</span>;        <span class="comment">// even short bits</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SQMASK       = <span class="number">0x007e</span>;        <span class="comment">// max 64 (even) slots</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Masks and units for WorkQueue.scanState and ctl sp subfield</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SCANNING     = <span class="number">1</span>;             <span class="comment">// false when running tasks</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INACTIVE     = <span class="number">1</span> &lt;&lt; <span class="number">31</span>;       <span class="comment">// must be negative</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SS_SEQ       = <span class="number">1</span> &lt;&lt; <span class="number">16</span>;       <span class="comment">// version count</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Mode bits for ForkJoinPool.config and WorkQueue.config</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_MASK    = <span class="number">0xffff</span> &lt;&lt; <span class="number">16</span>;  <span class="comment">// top half of int</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LIFO_QUEUE   = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FIFO_QUEUE   = <span class="number">1</span> &lt;&lt; <span class="number">16</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_QUEUE = <span class="number">1</span> &lt;&lt; <span class="number">31</span>;       <span class="comment">// must be negative</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Lower and upper word masks</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SP_MASK    = <span class="number">0xffffffffL</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> UC_MASK    = ~SP_MASK;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Active counts</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  AC_SHIFT   = <span class="number">48</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> AC_UNIT    = <span class="number">0x0001L</span> &lt;&lt; AC_SHIFT;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> AC_MASK    = <span class="number">0xffffL</span> &lt;&lt; AC_SHIFT;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Total counts</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  TC_SHIFT   = <span class="number">32</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TC_UNIT    = <span class="number">0x0001L</span> &lt;&lt; TC_SHIFT;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TC_MASK    = <span class="number">0xffffL</span> &lt;&lt; TC_SHIFT;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> ADD_WORKER = <span class="number">0x0001L</span> &lt;&lt; (TC_SHIFT + <span class="number">15</span>); <span class="comment">// sign 48位是TC的符号位</span></span><br></pre></td></tr></table></figure></p>
<p>1、ctl的初始化(ForkJoinPool)：AC=TC=-parallelism,SS=ID=0<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.config = (parallelism &amp; SMASK) | mode;</span><br><span class="line"><span class="keyword">long</span> np = (<span class="keyword">long</span>)(-parallelism); <span class="comment">// offset ctl counts</span></span><br><span class="line"><span class="keyword">this</span>.ctl = ((np &lt;&lt; AC_SHIFT) &amp; AC_MASK) | ((np &lt;&lt; TC_SHIFT) &amp; TC_MASK);</span><br></pre></td></tr></table></figure></p>
<p>假定parallelism值为4，np为-4，16进制为FFFF FFFF FFFF FFFC，np &lt;&lt; AC_SHIFT 表示np左移48（AC_SHIFT）位，得到FFFC 0000 0000 0000，再与AC_MASK(0XFFFF 0000 0000 0000)进行&amp;（与）操作，((np &lt;&lt; AC_SHIFT) &amp; AC_MASK)得到的值为FFFC 0000 0000 0000，同理，((np &lt;&lt; TC_SHIFT) &amp; TC_MASK)，得到的值为0000 FFFC 0000 0000，最后再将这两个值进行|（或）操作，得到的值为FFFC FFFC 0000 0000，即将AC，TC赋值为-4赋值，SS和ID为0。</p>
<p>2、添加线程(tryAddWorker)：AC=TC=+1<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> nc = ((AC_MASK &amp; (c + AC_UNIT)) |</span><br><span class="line">           (TC_MASK &amp; (c + TC_UNIT)));</span><br></pre></td></tr></table></figure></p>
<p>添加线程的时候，会将AC和TC都加1，其中c为当前CTL的值，新值为nc。假定c为FFFC FFFC 0000 0000，c + AC_UNIT 可以表示为FFFC FFFC 0000 0000 + 0001 0000 000 000，即在TC部分加1，得到的值为FFFD FFFC 0000 0000，再与AC_MASK(FFFF 0000 0000 0000)进行&amp;(与操作)，(AC_MASK &amp; (c + AC_UNIT))的值为FFFD 0000 0000 0000。同理TC_MASK &amp; (c + TC_UNIT))为0000 FFFD 0000 0000，最后将这个值进行|(或)操作，得到FFFD FFFD 0000 0000。</p>
<p>3、睡眠线程(scan)：AC:-1,ID=new ID<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ss = w.scanState; <span class="comment">// w为WorkQueue的变量</span></span><br><span class="line"><span class="keyword">int</span> ns = ss | INACTIVE;       <span class="comment">// try to inactivate</span></span><br><span class="line"><span class="keyword">long</span> nc = ((SP_MASK &amp; ns) |</span><br><span class="line">           (UC_MASK &amp; ((c = ctl) - AC_UNIT)));</span><br><span class="line">w.stackPred = (<span class="keyword">int</span>)c;         <span class="comment">// hold prev stack top</span></span><br></pre></td></tr></table></figure></p>
<p>ss的值为WorkQueue的scanState，scanState初始值为WorkQueue在WorkQueue[]中的下标（如果是外部线程提交任务产生的WorkQueue，scanState为INACTIVE），假定scanState为3，c为FFFD FFFD 0000 0000。ss | INACTIVE(0X8000 0000)等于8000 0011，SP_MASK &amp; ns等于0000 0000 8000 0011，(UC_MASK &amp; ((c = ctl) - AC_UNIT))等于FFFC FFFD 0000 0000，最后nc等于FFFC FFFD 8000 0011，即将空闲线程的下标设置在ID上。</p>
<p>4、唤醒空闲线程(signalWork)：AC:+1,ID=v.stackPred<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下代码进行了精简，与signalWork方法中的顺序不一定一致。</span></span><br><span class="line"><span class="keyword">long</span> c = ctl;</span><br><span class="line"><span class="keyword">int</span> sp = (<span class="keyword">int</span>)c;</span><br><span class="line"><span class="keyword">int</span> i = sp &amp; SMASK; <span class="comment">// 空闲线程的下标</span></span><br><span class="line">WorkQueue v = ws[i]; <span class="comment">// 空闲线程绑定的WorkQueue</span></span><br><span class="line"><span class="keyword">long</span> nc = (UC_MASK &amp; (c + AC_UNIT)) | (SP_MASK &amp; v.stackPred);</span><br></pre></td></tr></table></figure></p>
<p>假定c为FFFC FFFD 8000 0011,v.stackPred为5。将c的类型强制转化为int后，sp得到了c低32位的值，即SS与ID。sp与SMASK(0X0000 FFFF)得到低16位的值，即得到下标值(3)。再根据下标i得到对应的WorkQueue v，取到下一个空闲线程的下标(5)，并将这个下标设置到新ctl中的ID中。</p>
<p>c + AC_UNIT表示AC加1,(UC_MASK &amp; (c + AC_UNIT))得到的值为FFFD FFFD 0000 0000，SP_MASK &amp; v.stackPred为0000 0000 0000 0101，最后这两个值进行|(或)操作，nc的值为FFFE FFFF 0000 0101。</p>
<h4 id="3-1-2-config"><a href="#3-1-2-config" class="headerlink" title="3.1.2 config"></a>3.1.2 config</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LIFO_QUEUE   = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FIFO_QUEUE   = <span class="number">1</span> &lt;&lt; <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> asyncMode = <span class="keyword">false</span>; <span class="comment">// 默认为LIFO</span></span><br><span class="line"><span class="keyword">int</span> mode = asyncMode ? FIFO_QUEUE : LIFO_QUEUE,</span><br><span class="line"><span class="keyword">this</span>.config = (parallelism &amp; SMASK) | mode;</span><br></pre></td></tr></table></figure>
<p>config主要是存放两部分信息：1) parallelism,ForkJoinPool线程数；2) ForkJoinPool同步或异步模式，同步用LIFO模式，异步用FIFO，默认为LIFO。parallelism存放在int的低16位，LIFO_QUEUE为0，两者进行|（或）操作，还是parallelism本身。如果模式是FIFO_QUEUE的话，则将int第17位设置为1，假定parallelism为4，最后|（操作）之后，config的值为0X0001 0004。</p>
<h4 id="3-1-3-workQueues"><a href="#3-1-3-workQueues" class="headerlink" title="3.1.3 workQueues"></a>3.1.3 workQueues</h4><p>workQueues是ForkJoinPool中非常重要的数据结构，存放多个工作队列WorkQueue，工作队列主要有两种类型：1）外部线程提交一次ForkJoinTask任务，都会生成一个WorkQueue，用来存放提交的的任务（一次可提交多个任务），该队列不属于任何一个线程，会等待其它线程来偷取(Work Stealing)任务，这类WorkQueue存放在workQueues的偶数下标处；2）新增一个工作线程WorkerThread时，都会生成一个WorkQueue，用来存放该线程需要执行的子任务，该WorkQueue绑定在工作线程上，这类WorkQueue存放在workQueues的奇数下标处。</p>
<p>1、workQueues初始化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create workQueues array with size a power of two</span></span><br><span class="line"><span class="keyword">int</span> p = config &amp; SMASK; <span class="comment">// ensure at least 2 slots</span></span><br><span class="line"><span class="keyword">int</span> n = (p &gt; <span class="number">1</span>) ? p - <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">1</span>; n |= n &gt;&gt;&gt; <span class="number">2</span>;  n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">8</span>; n |= n &gt;&gt;&gt; <span class="number">16</span>; n = (n + <span class="number">1</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">workQueues = <span class="keyword">new</span> WorkQueue[n];</span><br></pre></td></tr></table></figure></p>
<p>p存放parallelism的值，经过一系列的符号右移及或操作之后，保证n为奇数，最后对n加1，再左移1位，得到一个2的倍数的值，一般情况下workQueues等于parallelism的2倍。</p>
<p>2、提交任务的WorkQueue<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SQMASK常量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SQMASK  = <span class="number">0x007e</span>;   <span class="comment">// max 64 (even) slots</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m = ws.length - <span class="number">1</span>; <span class="comment">// m等于workQueues长度减一，是一个奇数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> k = r &amp; m &amp; SQMASK;</span><br><span class="line">WorkQueue q = <span class="keyword">new</span> WorkQueue(<span class="keyword">this</span>, <span class="keyword">null</span>);</span><br><span class="line">q.hint = r; <span class="comment">// r是一个随机值， r = ThreadLocalRandom.getProbe()</span></span><br><span class="line">q.config = k | SHARED_QUEUE; <span class="comment">// k是存放在workqueue[]中的位置</span></span><br><span class="line">q.scanState = INACTIVE; <span class="comment">// 初始化scanState的状态</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rs &gt; <span class="number">0</span> &amp;&amp;  (ws = workQueues) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">    k &lt; ws.length &amp;&amp; ws[k] == <span class="keyword">null</span>)</span><br><span class="line">    ws[k] = q;  <span class="comment">// else terminated</span></span><br></pre></td></tr></table></figure></p>
<p>r是一个随机数，m是数组长度减一，r &amp; m 操作得到一个介于0~m的随机数字。SQMASK是数组的最大值64，其最低位是0，进行与操作，最低位必然是0，从而保证r &amp; m &amp; SQMASK的值是一个介于0~m的随机偶数。k是一个随机数，主要是为了减少插入位置的冲突。</p>
<p>3、工作线程的WorkQueue<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">WorkQueue w = <span class="keyword">new</span> WorkQueue(<span class="keyword">this</span>, wt);</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;                                    <span class="comment">// assign a pool index</span></span><br><span class="line"><span class="keyword">int</span> mode = config &amp; MODE_MASK;</span><br><span class="line"><span class="keyword">int</span> rs = lockRunState();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    WorkQueue[] ws; <span class="keyword">int</span> n;                    <span class="comment">// skip if no array</span></span><br><span class="line">    <span class="keyword">if</span> ((ws = workQueues) != <span class="keyword">null</span> &amp;&amp; (n = ws.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> s = indexSeed += SEED_INCREMENT;  <span class="comment">// unlikely to collide</span></span><br><span class="line">        <span class="keyword">int</span> m = n - <span class="number">1</span>;</span><br><span class="line">        i = ((s &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>) &amp; m;               <span class="comment">// odd-numbered indices</span></span><br><span class="line">        <span class="keyword">if</span> (ws[i] != <span class="keyword">null</span>) &#123;                  <span class="comment">// collision</span></span><br><span class="line">            <span class="keyword">int</span> probes = <span class="number">0</span>;                   <span class="comment">// step by approx half n</span></span><br><span class="line">            <span class="keyword">int</span> step = (n &lt;= <span class="number">4</span>) ? <span class="number">2</span> : ((n &gt;&gt;&gt; <span class="number">1</span>) &amp; EVENMASK) + <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">while</span> (ws[i = (i + step) &amp; m] != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (++probes &gt;= n) &#123;</span><br><span class="line">                    workQueues = ws = Arrays.copyOf(ws, n &lt;&lt;= <span class="number">1</span>);</span><br><span class="line">                    m = n - <span class="number">1</span>;</span><br><span class="line">                    probes = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        w.hint = s;                           <span class="comment">// use as random seed</span></span><br><span class="line">        w.config = i | mode;</span><br><span class="line">        w.scanState = i;                      <span class="comment">// publication fence</span></span><br><span class="line">        ws[i] = w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    unlockRunState(rs, rs &amp; ~RSLOCK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>重点看以下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">WorkQueue w = <span class="keyword">new</span> WorkQueue(<span class="keyword">this</span>, wt);</span><br><span class="line"></span><br><span class="line">n = ws.length</span><br><span class="line"><span class="keyword">int</span> s = indexSeed += SEED_INCREMENT;  <span class="comment">// unlikely to collide</span></span><br><span class="line"><span class="keyword">int</span> m = n - <span class="number">1</span>;</span><br><span class="line">i = ((s &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>) &amp; m;</span><br><span class="line"></span><br><span class="line">ws[i] = w;</span><br></pre></td></tr></table></figure></p>
<p>s是一个随机值， ((s &lt;&lt; 1) | 1)表达式得到一个随机的奇数，即最低为1。再与m(也是一个奇数)进行&amp;(与)操作，得到一个介于0~m(包括m)的的奇数。从而保证工作线程的WorkQueue存放在workQueues的奇数位置。</p>
<h4 id="3-1-4-indexSeed"><a href="#3-1-4-indexSeed" class="headerlink" title="3.1.4 indexSeed"></a>3.1.4 indexSeed</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Increment for seed generators. See class ThreadLocal for</span></span><br><span class="line"><span class="comment">* explanation.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SEED_INCREMENT = <span class="number">0x9e3779b9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> s = indexSeed += SEED_INCREMENT;</span><br></pre></td></tr></table></figure>
<p>indexSeed主要是用来随机生成WorkQueue的下标。</p>
<h3 id="3-2-WorkQueue"><a href="#3-2-WorkQueue" class="headerlink" title="3.2 WorkQueue"></a>3.2 WorkQueue</h3><p>WorkQueue是存储ForkJoinTask的容器，也是Work-Stealing依赖的数据结构。外部提交新的ForkJoinTask任务，会新建一个WorkQueue，将任务存放到WorkQueue的ForkJoinTask数组中，最后将该WorkQueue存放到ForkJoinPool对象的workQueues数组中（存放到偶数下标处），新的任务会被工作线程窃取。另外一方面工作线程中产生的子任务会存放到该线程绑定的工作队列中。下面是WorkQueue的一些关键字段。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Instance fields</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> scanState;    <span class="comment">// versioned, &lt;0: inactive; odd:scanning</span></span><br><span class="line"><span class="keyword">int</span> stackPred;             <span class="comment">// pool stack (ctl) predecessor</span></span><br><span class="line"><span class="keyword">int</span> nsteals;               <span class="comment">// number of steals</span></span><br><span class="line"><span class="keyword">int</span> hint;                  <span class="comment">// randomization and stealer index hint</span></span><br><span class="line"><span class="keyword">int</span> config;                <span class="comment">// pool index and mode</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> qlock;        <span class="comment">// 1: locked, &lt; 0: terminate; else 0</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> base;         <span class="comment">// index of next slot for poll</span></span><br><span class="line"><span class="keyword">int</span> top;                   <span class="comment">// index of next slot for push</span></span><br><span class="line">ForkJoinTask&lt;?&gt;[] array;   <span class="comment">// the elements (initially unallocated)</span></span><br><span class="line"><span class="keyword">final</span> ForkJoinPool pool;   <span class="comment">// the containing pool (may be null)</span></span><br><span class="line"><span class="keyword">final</span> ForkJoinWorkerThread owner; <span class="comment">// owning thread or null if shared</span></span><br><span class="line"><span class="keyword">volatile</span> Thread parker;    <span class="comment">// == owner during call to park; else null</span></span><br><span class="line"><span class="keyword">volatile</span> ForkJoinTask&lt;?&gt; currentJoin;  <span class="comment">// task being joined in awaitJoin</span></span><br><span class="line"><span class="keyword">volatile</span> ForkJoinTask&lt;?&gt; currentSteal; <span class="comment">// mainly used by helpStealer</span></span><br></pre></td></tr></table></figure></p>
<h4 id="3-2-1-stackPred"><a href="#3-2-1-stackPred" class="headerlink" title="3.2.1 stackPred"></a>3.2.1 stackPred</h4><p>通过ctl的ID字段与stackPred可以形成一个空闲线程列表栈，栈首存放在ID字段中，stackPred存放的是下一个空闲线程的下标，如下图所示：<br><img src="/images/idle-thread-list.jpg" alt="idle-thread-list" title="idle-thread-list"></p>
<h4 id="3-2-2-array-base-top"><a href="#3-2-2-array-base-top" class="headerlink" title="3.2.2 array,base,top"></a>3.2.2 array,base,top</h4><p>这三个字段主要是用来存取ForkJoinTask任务的，array是一个ForkJoinTask类型的数组，以双端队列的方式提供服务；base是队列的底部，外部线程窃取任务就是从base开始；top是队列的顶部，工作队列绑定的线程push/pop都是在top上操作。这三个值的初始状态如下图所示：<br><img src="/images/workqueue-array-init.jpg" alt="workqueue-array-init" title="workqueue-array-init"></p>
<p>array的初始大小为8192，最大为64M，base及top默认值为初始大小的一半4096，代码定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_QUEUE_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">13</span>; <span class="comment">// 8192 数组初始大小</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_QUEUE_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">26</span>; <span class="comment">// 64M 数组最大值</span></span><br><span class="line"></span><br><span class="line">base = top = INITIAL_QUEUE_CAPACITY &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">// base及top默认值</span></span><br></pre></td></tr></table></figure>
<p>工作窃取时的队列如下所示:<br><img src="/images/workqueue-array.jpg" alt="workqueue-array" title="workqueue-array"></p>
<h4 id="3-2-2-currentSteal-currentJoin"><a href="#3-2-2-currentSteal-currentJoin" class="headerlink" title="3.2.2 currentSteal,currentJoin"></a>3.2.2 currentSteal,currentJoin</h4><p>currentSteal表示当前工作线程从外部工作队列中窃取到的任务，currentJoin表示当前工作线程处在join中的任务，通过这两个参数的配合使用，可以将递归类型的任务分布在多个工作线程执行，同时父级任务线程可以帮子任务或孙子任务线程执行任务，它们的关系如下图所示：<br><img src="/images/workqueue-join-steal.jpg" alt="workqueue-join-steal" title="workqueue-join-steal"></p>
<p>wt1线程当前join的任务就是wt2线程窃取的任务，当wt1线程队列没有任务的时候，它会找到窃取它任务的wt2线程，发现wt2线程的任务队列为空，再去查找窃取wt2线程任务的wt3线程，发现wt3线程队列不为空，则窃取wt3线程工作队列base位置的任务t-1-2-1，并执行它。</p>
<h3 id="3-3-ForkJoinWorkerThread"><a href="#3-3-ForkJoinWorkerThread" class="headerlink" title="3.3 ForkJoinWorkerThread"></a>3.3 ForkJoinWorkerThread</h3><p>ForkJoinWorkerThread对象继承自Thread对象，是任务执行的实体，继承关系如下图所示：<br><img src="/images/ForkJoinWorkerThread.jpg" alt="ForkJoinWorkerThread" title="ForkJoinWorkerThread"></p>
<p>ForkJoinWorkerThread有内部有两个字段，主要是保存了WorkQueue及ForkJoinPool的引用，定义如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ForkJoinPool pool;                <span class="comment">// the pool this thread works in</span></span><br><span class="line"><span class="keyword">final</span> ForkJoinPool.WorkQueue workQueue; <span class="comment">// work-stealing mechanics</span></span><br></pre></td></tr></table></figure></p>
<h3 id="3-4-ForkJoinTask"><a href="#3-4-ForkJoinTask" class="headerlink" title="3.4 ForkJoinTask"></a>3.4 ForkJoinTask</h3><p>ForkJoinTask封装了计算的流程，实现了fork及join方法，它是分治算法中两个核心的方法，这两个方法我们在后面的部分详细介绍。ForkJoinTask有两个子类：RecursiveTask和ForkJoinTask，它们的区别主要是计算有没有返回值。这两个子类都提供了一个抽象方法compute，由具体的业务算法来实现，主要包括子任务的划分及结果的合并逻辑，其核心思想如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if(任务很小）&#123;</span><br><span class="line">    直接计算得到结果</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    分拆成N个子任务</span><br><span class="line">    调用子任务的fork()进行计算</span><br><span class="line">    调用子任务的join()合并计算结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="4-工作流程"><a href="#4-工作流程" class="headerlink" title="4. 工作流程"></a>4. 工作流程</h2><h3 id="4-1-提交任务"><a href="#4-1-提交任务" class="headerlink" title="4.1 提交任务"></a>4.1 提交任务</h3><p><img src="/images/invoke-task.jpg" alt="invoke-task" title="invoke-task"></p>
<p>流程：<br>1） 提交线程</p>
<ul>
<li>提交线程（不是工作线程）构建ForkJoinTask，提交给ForkJoinPool执行，如通过invoke方法；</li>
<li>如果ForkJoinPool中的工作队列数组workQueues没有创建，则创建该数组，默认为parallelism的2倍；</li>
<li>创建工作队列q，并将该队列添加到workQueues的偶数下标处；</li>
<li>创建工作队列q的任务数组array，默认大小了8192，base和top的初始值为数组大小的一半，即4096；</li>
<li>提交线程会走到“激活工作线程”的流程，该流程会在后面的内容讲到。</li>
</ul>
<p>2）工作线程</p>
<ul>
<li>启动工作线程wt，扫描ForkJoinPool的workQueues数组，窃取一个ForkJoinTask去执行；</li>
<li>随机生成一个在数组大小范围内的奇数，作为扫描的起始位置，这样可以避免多个线程同时从一个位置扫描，减少竞争；</li>
<li>遍历工作队列workQueues数组，如果工作队列中有任务，则从其base位置处取得任务t，如果该队列中还有其它任务，则“激活工作线程”，让其它工作线程来窃取其它任务；</li>
<li>设置工作线程wt的currentSteal（在工作队列中）的值为t，表示工作窃取了任务t；</li>
<li>执行任务t；</li>
<li>任务执行结束，将currentSteal设置为null；</li>
<li>遍历工作队列workQueues数组，如果都没有找到任务，则会将当前工作线程加入到空闲线程列表中，并睡眠当前工作线程等待激活。</li>
</ul>
<h3 id="4-2-fork流程"><a href="#4-2-fork流程" class="headerlink" title="4.2 fork流程"></a>4.2 fork流程</h3><p><img src="/images/fork-flow.jpg" alt="fork-flow" title="fork-flow"></p>
<p>流程：</p>
<ul>
<li>执行fork的线程可以是外部线程，也可以是工作线程，这两种方式处理方法不一样；</li>
<li>判断线程的类型是否ForkJoinWorkerThread；</li>
<li>如果是ForkJoinWorkerThread类型，则将任务提交到工作线程的工作队列中，执行“激活工作线程”流程；</li>
<li>如果不是ForkJoinWorkerThread类型，则将任务提交到commonForkJoinPool中，与“提交任务”流程是一样的。</li>
</ul>
<h4 id="4-2-1-激活工作线程"><a href="#4-2-1-激活工作线程" class="headerlink" title="4.2.1 激活工作线程"></a>4.2.1 激活工作线程</h4><p><img src="/images/singal-worker.jpg" alt="singal-worker" title="singal-worker"></p>
<p>流程：</p>
<ul>
<li>设置工作队列数组为ws,当前工作队列为q；</li>
<li>判断当前活跃线程是否小于parallelim，如果已经大于parallelim，则直接退出；</li>
<li>再判断是否有空闲线程，有空闲线程则唤醒空闲线程；</li>
<li>如果没有空闲线程，同时线程总数小于parallelim，则创建一个新的工作线程wt来执行任务；</li>
<li>建立线程相关的工作队列w，建立线程与队列的关联关系，并将工作队列添加到数组ws的奇数下标处；</li>
<li>启动wt线程。</li>
</ul>
<h3 id="4-3-join流程"><a href="#4-3-join流程" class="headerlink" title="4.3 join流程"></a>4.3 join流程</h3><p><img src="/images/join-flow.jpg" alt="join-flow" title="join-flow"></p>
<p>流程：</p>
<ul>
<li>执行join的任务为task，执行join方法的线程为wt，wt的工作队列为w；</li>
<li>判断task任务是否已经结束，如果已经结束，直接返回结果即可；</li>
<li>task没有结束，则判断wt的类型，是否为ForkJoinWorkerThread；</li>
<li>如果wt不是ForkJoinWorkerThread类型的线程，则说明是外部线程执行了join方法，则阻塞该线程，等待任务结束后被唤醒；</li>
<li>如果wt是ForkJoinWorkerThread类型的线程，则分为三种情况；</li>
<li>1）task在w的栈首位置，则直接将task出栈，执行task即可；</li>
<li>2）task在w中，但不在栈首位置，处于w的中间位置，则将w中的task转换为空任务（空操作，因为该任务已经被提前执行），执行task；</li>
<li>3）task不在w中，表示该任务已经被其它工作线程窃取了，此时如果w的队列为空，则执行“工作窃取流程”，帮助窃取任务的线程，让它更快结束；</li>
<li>在一个步骤中，如果w的队列不为空，则睡眠线程wt，在睡眠之前，作为补偿，会创建一个新的工作线程或唤醒一个空闲线程来执行任务。</li>
</ul>
<h4 id="4-3-1-工作窃取流程"><a href="#4-3-1-工作窃取流程" class="headerlink" title="4.3.1 工作窃取流程"></a>4.3.1 工作窃取流程</h4><p><img src="/images/work-stealing-flow.jpg" alt="work-stealing-flow" title="work-stealing-flow"></p>
<p>流程：</p>
<ul>
<li>设置task为被窃取的任务，w为当前工作线程的工作队列；</li>
<li>遍历工作队列数组，找到窃取task任务的工作线程,其工作队列为v，判断条件为工作线程的v.cureentSteal==task; </li>
<li>判断工作队列v是否为空；</li>
<li>如果v不为空，则从工作队列v的base位置窃取任务t，在当前线程w中执行任务t，并设置w.currentSteal=t，直到v为空；</li>
<li>如果v为空，则说明任务被其它线程窃取，通过其currentJoin字段找到被窃取的任务，并将该字段设置为task的值，从第一步重新执行，从而帮助儿子任务、孙子任务等等后代任务快速结束。</li>
</ul>
<h2 id="5-实例"><a href="#5-实例" class="headerlink" title="5. 实例"></a>5. 实例</h2><p>我们通过ForkJoinPool框架实现快速排序算法，来展示将在一个线程中执行的递归算法转化为在多个线程中“分治”执行的算法。维基百科关于快速排序的定义如下：</p>
<blockquote>
<p>快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为较小和较大的2个子序列，然后递归地排序两个子序列。<br>步骤为：</p>
<ul>
<li>挑选基准值：从数列中挑出一个元素，称为“基准”（pivot），</li>
<li>分割：重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（与基准值相等的数可以到任何一边）。在这个分割结束之后，对基准值的排序就已经完成，</li>
<li>递归排序子序列：递归地将小于基准值元素的子序列和大于基准值元素的子序列排序。<br>递归到最底部的判断条件是数列的大小是零或一，此时该数列显然已经有序。</li>
</ul>
</blockquote>
<h3 id="5-1-递归算法"><a href="#5-1-递归算法" class="headerlink" title="5.1 递归算法"></a>5.1 递归算法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursiveQuicksort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换数组中两个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array 数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left 左边的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 右边的下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> tmp = array[left];</span><br><span class="line">        array[left] = array[right];</span><br><span class="line">        array[right] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分隔数组为两个子数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array 数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left 左边的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 右边的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 分隔的下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算基准的下标</span></span><br><span class="line">        <span class="keyword">int</span> index = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> privot = array[index];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="keyword">int</span> j = right - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        swap(array, index, right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt;= right &amp;&amp; array[i] &lt; privot) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> ( j &gt;= left &amp;&amp; array[j] &gt; privot) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                swap(array, i, j);</span><br><span class="line">                i++;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (array[i] &gt; array[right]) &#123;</span><br><span class="line">            swap(array, i, right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 快速排序算法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array 数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left 左边的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 右边的下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right || array == <span class="keyword">null</span> || array.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> privot = partition(array, left, right);</span><br><span class="line">        quicksort(array, left, privot - <span class="number">1</span>);</span><br><span class="line">        quicksort(array, privot + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">30</span>, <span class="number">32</span>, <span class="number">65</span>, <span class="number">100</span>, <span class="number">102</span>&#125;;</span><br><span class="line">        <span class="keyword">new</span> RecursiveQuicksort().quicksort(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        IntStream stream = IntStream.of(array);</span><br><span class="line">        stream.forEach(a -&gt; System.out.println(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-2-Fork-Join"><a href="#5-2-Fork-Join" class="headerlink" title="5.2 Fork/Join"></a>5.2 Fork/Join</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinQuicksort</span> <span class="keyword">extends</span> <span class="title">RecursiveAction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> left;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForkJoinQuicksort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForkJoinQuicksort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.array = array;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right || array == <span class="keyword">null</span> || array.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> privot = partition(array, left, right);</span><br><span class="line">        ForkJoinQuicksort leftTask = <span class="keyword">new</span> ForkJoinQuicksort(array, left, privot - <span class="number">1</span>);</span><br><span class="line">        ForkJoinQuicksort rightTask = <span class="keyword">new</span> ForkJoinQuicksort(array, privot + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">        leftTask.fork();    <span class="comment">// 提交异步子任务</span></span><br><span class="line">        rightTask.fork();</span><br><span class="line"></span><br><span class="line">        rightTask.join();   <span class="comment">// 等待任务执行结束</span></span><br><span class="line">        leftTask.join();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">50</span>, <span class="number">23</span>, <span class="number">20</span>, <span class="number">44</span>, <span class="number">22</span>, <span class="number">51</span>, <span class="number">32</span>, <span class="number">65</span>, <span class="number">2</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">        ForkJoinQuicksort task = <span class="keyword">new</span> ForkJoinQuicksort(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">        pool.invoke(task);  <span class="comment">// 提交任务</span></span><br><span class="line"></span><br><span class="line">        IntStream stream = IntStream.of(array);</span><br><span class="line">        stream.forEach(value -&gt; System.out.println(value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ForkJoinQuicksort主要是继承RecursiveAction（没有返回值），算法逻辑在compute方法实现即可。</p>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>ForkJoinPool主要是提供了“分治算法”的多线程版本，基于“Work-Stealing”，可以有效使用cpu多核的优势，提高算法的速度。ForkJoinPool 最适合的是计算密集型的任务，如果存在 I/O、线程间同步、sleep() 等会造成线程长时间阻塞的情况时，最好配合使用 ManagedBlocker。</p>
<p><strong>参考：</strong></p>
<hr>
<p><a href="http://blog.dyngr.com/blog/2016/09/15/java-forkjoinpool-internals/" target="_blank" rel="noopener">1. Java 并发编程笔记：如何使用 ForkJoinPool 以及原理</a></p>
<p><a href="https://www.jianshu.com/p/f777abb7b251" target="_blank" rel="noopener">2. jdk1.8-ForkJoin框架剖析</a></p>
<p><a href="https://blog.hufeifei.cn/2018/09/15/Java/ForkJoinPool/" target="_blank" rel="noopener">3.ForkJoinPool入门篇</a></p>
<p><a href="https://www.jianshu.com/p/de025df55363" target="_blank" rel="noopener">4.分析jdk-1.8-ForkJoinPool实现原理(上)</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/07/consistent-hash/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/07/consistent-hash/" class="post-title-link" itemprop="http://yoursite.com/page/4/index.html">一致性哈希算法</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-07 18:04:49" itemprop="dateCreated datePublished" datetime="2019-11-07T18:04:49+08:00">2019-11-07</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-07-31 17:17:10" itemprop="dateModified" datetime="2021-07-31T17:17:10+08:00">2021-07-31</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构与算法/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">59k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">54 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-解决的问题"><a href="#1-解决的问题" class="headerlink" title="1. 解决的问题"></a>1. 解决的问题</h2><p>在分布式服务中，往往有这样的场景：将某个用户或某台机器的请求负载路由到固定的某台服务器上。简单的做法直接是使用哈希算法，<strong>h = hash(key) % N</strong> ，该算法的核心思想是：将服务器编号，使用哈希算法取根据某类请求参数key（用户id或IP）计算出一个哈希值，再对该哈希值用服务器数据N进行取余（%）操作，从而得到服务器编号。使用该算法有一个问题，就是服务器数据数目（N）增加中或减少的时候，h的值都会被改变，即请求会负载到新的服务器上，有可能会导致状态数据的失效。有没有一种算法，既可以将同一请求负载到同一台服务器上，又可以在服务器增加或减少的时候将请求的变更控制在一定的范围内，所以提出了一致性哈希算法。</p>
<p>一致性哈希算法（Consistent Hashing）最早在论文《Consistent Hashing and Random Trees: Distributed Caching Protocols for Relieving Hot Spots on the World Wide Web》中被提出，其原理如下：</p>
<blockquote>
<p>一致性哈希算法将整个哈希值（整数）空间组织成一个0~2^32-1的虚拟哈希环，首先，服务器按照名称（或编号）取哈希，并将该哈希值放置在哈希环上，然后再对key取哈希，按照随时针方向查找离该值最近的服务器结点哈希值，从而完成key与服务器的匹配映射工作。</p>
</blockquote>
<p>通过一致性哈希算法，服务器的增加或减少只会影响该服务器周围的请求，不会扩大到整个哈希环，从而保证算法的可扩展性。</p>
<p>一致性哈希算法也有一个问题，就是服务器较少时，可能出现服务器之间负载的请求可能不均衡，有些服务器负载的请求可能过多，而有些服务负载较少。解决这个问题的关键是增加哈希环上服务节点的数量，在物理服务器不能增加的情况下，可以将一个服务结点映射为多个虚拟结点，均匀分布在哈希环上，从而解决该问题。</p>
<h2 id="2-哈希算法"><a href="#2-哈希算法" class="headerlink" title="2. 哈希算法"></a>2. 哈希算法</h2><p>在一致性哈希算法中，哈希算法是一个重要的组成部分，它将服务器结点和请求字符串转换为一个整数，如何选择一个好的哈希算法？评判一个哈希算法的标准是什么？</p>
<p>哈希算法大致有两种类型：加密哈希算法和非加密哈希算法，加密哈希算法为了防止攻击者找出碰撞而设计的，它的速度较慢。非加密哈希算法将字符串作为输入，通过计算输出一个整数，理想的哈希算法有一个特性：输出非常均匀分布在可能的输出域，特别是当输入非常相似的时候。可以将哈希算法大致分为三代：</p>
<ul>
<li>第一代：SHA-1（1993），MD5（1992），CRC（1975），Lookup3（2006）</li>
<li>第二代：MurmurHash（2008）</li>
<li>第三代：CityHash， SpookyHash（2011）</li>
</ul>
<p>其中SHA-1和MD5属于非加密哈希算法，其它都是非加密哈希算法，在一致性哈希算法中，主要用的是非加密哈希算法。除了以上的算法，还有一些算法没有列出，如JDK中hashCode使用的算法，另外，还有专门针对一致性哈希算法设计的哈希算法，如Ketama，也得到了广泛的运用。</p>
<p>在一致性哈希算法的使用场景中，有几个比较重要的算法，单独说明一下：</p>
<ul>
<li>MurmurHash 算法：高运算性能，低碰撞率，由 Austin Appleby 创建于 2008 年，现已应用到 Hadoop、libstdc++、nginx、libmemcached 等开源系统。2011 年 Appleby被Google雇佣，随后Google推出其变种的CityHash算法。官方只提供了C语言的实现版本。Java体系中，Guava，Redis，Memcached，Cassandra，HBase，Lucene都在使用它。</li>
<li>FNV算法：全名为Fowler-Noll-Vo算法，是以三位发明人Glenn Fowler，Landon Curt Noll，Phong Vo 的名字来命名的，最早在 1991 年提出。特点和用途：FNV 能快速 hash 大量数据并保持较小的冲突率，它的高度分散使它适用于hash一些非常相近的字符串，比如URL，hostname，文件名，text，IP 地址等。</li>
<li>Ketama 算法：Ketama不仅提供了一个哈希算法，更是提供了一套一致性哈希算法的实现，在Dubbo及Memcached中使用了该算法。</li>
</ul>
<p>下面针对这些算法，作一一介绍：</p>
<p>1）Java 字符串哈希算法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Java字符串哈希算法是遍历整个字符串，按照hash * 31 + c的算法计算，最后的哈希值为s[0] *31^(n-1) + s<a href="https://www.oschina.net/translate/state-of-hash-functions" target="_blank" rel="noopener">1</a>*31^(n-2) + … + s[n-1]。</p>
<p>2）CRC 哈希算法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CRCHashStrategy</span> <span class="keyword">implements</span> <span class="title">HashStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LOOKUP_TABLE[] = &#123;<span class="number">0x0000</span>, <span class="number">0x1021</span>, <span class="number">0x2042</span>, <span class="number">0x3063</span>,</span><br><span class="line">            <span class="number">0x4084</span>, <span class="number">0x50A5</span>, <span class="number">0x60C6</span>, <span class="number">0x70E7</span>, <span class="number">0x8108</span>, <span class="number">0x9129</span>, <span class="number">0xA14A</span>, <span class="number">0xB16B</span>,</span><br><span class="line">            <span class="number">0xC18C</span>, <span class="number">0xD1AD</span>, <span class="number">0xE1CE</span>, <span class="number">0xF1EF</span>, <span class="number">0x1231</span>, <span class="number">0x0210</span>, <span class="number">0x3273</span>, <span class="number">0x2252</span>,</span><br><span class="line">            <span class="number">0x52B5</span>, <span class="number">0x4294</span>, <span class="number">0x72F7</span>, <span class="number">0x62D6</span>, <span class="number">0x9339</span>, <span class="number">0x8318</span>, <span class="number">0xB37B</span>, <span class="number">0xA35A</span>,</span><br><span class="line">            <span class="number">0xD3BD</span>, <span class="number">0xC39C</span>, <span class="number">0xF3FF</span>, <span class="number">0xE3DE</span>, <span class="number">0x2462</span>, <span class="number">0x3443</span>, <span class="number">0x0420</span>, <span class="number">0x1401</span>,</span><br><span class="line">            <span class="number">0x64E6</span>, <span class="number">0x74C7</span>, <span class="number">0x44A4</span>, <span class="number">0x5485</span>, <span class="number">0xA56A</span>, <span class="number">0xB54B</span>, <span class="number">0x8528</span>, <span class="number">0x9509</span>,</span><br><span class="line">            <span class="number">0xE5EE</span>, <span class="number">0xF5CF</span>, <span class="number">0xC5AC</span>, <span class="number">0xD58D</span>, <span class="number">0x3653</span>, <span class="number">0x2672</span>, <span class="number">0x1611</span>, <span class="number">0x0630</span>,</span><br><span class="line">            <span class="number">0x76D7</span>, <span class="number">0x66F6</span>, <span class="number">0x5695</span>, <span class="number">0x46B4</span>, <span class="number">0xB75B</span>, <span class="number">0xA77A</span>, <span class="number">0x9719</span>, <span class="number">0x8738</span>,</span><br><span class="line">            <span class="number">0xF7DF</span>, <span class="number">0xE7FE</span>, <span class="number">0xD79D</span>, <span class="number">0xC7BC</span>, <span class="number">0x48C4</span>, <span class="number">0x58E5</span>, <span class="number">0x6886</span>, <span class="number">0x78A7</span>,</span><br><span class="line">            <span class="number">0x0840</span>, <span class="number">0x1861</span>, <span class="number">0x2802</span>, <span class="number">0x3823</span>, <span class="number">0xC9CC</span>, <span class="number">0xD9ED</span>, <span class="number">0xE98E</span>, <span class="number">0xF9AF</span>,</span><br><span class="line">            <span class="number">0x8948</span>, <span class="number">0x9969</span>, <span class="number">0xA90A</span>, <span class="number">0xB92B</span>, <span class="number">0x5AF5</span>, <span class="number">0x4AD4</span>, <span class="number">0x7AB7</span>, <span class="number">0x6A96</span>,</span><br><span class="line">            <span class="number">0x1A71</span>, <span class="number">0x0A50</span>, <span class="number">0x3A33</span>, <span class="number">0x2A12</span>, <span class="number">0xDBFD</span>, <span class="number">0xCBDC</span>, <span class="number">0xFBBF</span>, <span class="number">0xEB9E</span>,</span><br><span class="line">            <span class="number">0x9B79</span>, <span class="number">0x8B58</span>, <span class="number">0xBB3B</span>, <span class="number">0xAB1A</span>, <span class="number">0x6CA6</span>, <span class="number">0x7C87</span>, <span class="number">0x4CE4</span>, <span class="number">0x5CC5</span>,</span><br><span class="line">            <span class="number">0x2C22</span>, <span class="number">0x3C03</span>, <span class="number">0x0C60</span>, <span class="number">0x1C41</span>, <span class="number">0xEDAE</span>, <span class="number">0xFD8F</span>, <span class="number">0xCDEC</span>, <span class="number">0xDDCD</span>,</span><br><span class="line">            <span class="number">0xAD2A</span>, <span class="number">0xBD0B</span>, <span class="number">0x8D68</span>, <span class="number">0x9D49</span>, <span class="number">0x7E97</span>, <span class="number">0x6EB6</span>, <span class="number">0x5ED5</span>, <span class="number">0x4EF4</span>,</span><br><span class="line">            <span class="number">0x3E13</span>, <span class="number">0x2E32</span>, <span class="number">0x1E51</span>, <span class="number">0x0E70</span>, <span class="number">0xFF9F</span>, <span class="number">0xEFBE</span>, <span class="number">0xDFDD</span>, <span class="number">0xCFFC</span>,</span><br><span class="line">            <span class="number">0xBF1B</span>, <span class="number">0xAF3A</span>, <span class="number">0x9F59</span>, <span class="number">0x8F78</span>, <span class="number">0x9188</span>, <span class="number">0x81A9</span>, <span class="number">0xB1CA</span>, <span class="number">0xA1EB</span>,</span><br><span class="line">            <span class="number">0xD10C</span>, <span class="number">0xC12D</span>, <span class="number">0xF14E</span>, <span class="number">0xE16F</span>, <span class="number">0x1080</span>, <span class="number">0x00A1</span>, <span class="number">0x30C2</span>, <span class="number">0x20E3</span>,</span><br><span class="line">            <span class="number">0x5004</span>, <span class="number">0x4025</span>, <span class="number">0x7046</span>, <span class="number">0x6067</span>, <span class="number">0x83B9</span>, <span class="number">0x9398</span>, <span class="number">0xA3FB</span>, <span class="number">0xB3DA</span>,</span><br><span class="line">            <span class="number">0xC33D</span>, <span class="number">0xD31C</span>, <span class="number">0xE37F</span>, <span class="number">0xF35E</span>, <span class="number">0x02B1</span>, <span class="number">0x1290</span>, <span class="number">0x22F3</span>, <span class="number">0x32D2</span>,</span><br><span class="line">            <span class="number">0x4235</span>, <span class="number">0x5214</span>, <span class="number">0x6277</span>, <span class="number">0x7256</span>, <span class="number">0xB5EA</span>, <span class="number">0xA5CB</span>, <span class="number">0x95A8</span>, <span class="number">0x8589</span>,</span><br><span class="line">            <span class="number">0xF56E</span>, <span class="number">0xE54F</span>, <span class="number">0xD52C</span>, <span class="number">0xC50D</span>, <span class="number">0x34E2</span>, <span class="number">0x24C3</span>, <span class="number">0x14A0</span>, <span class="number">0x0481</span>,</span><br><span class="line">            <span class="number">0x7466</span>, <span class="number">0x6447</span>, <span class="number">0x5424</span>, <span class="number">0x4405</span>, <span class="number">0xA7DB</span>, <span class="number">0xB7FA</span>, <span class="number">0x8799</span>, <span class="number">0x97B8</span>,</span><br><span class="line">            <span class="number">0xE75F</span>, <span class="number">0xF77E</span>, <span class="number">0xC71D</span>, <span class="number">0xD73C</span>, <span class="number">0x26D3</span>, <span class="number">0x36F2</span>, <span class="number">0x0691</span>, <span class="number">0x16B0</span>,</span><br><span class="line">            <span class="number">0x6657</span>, <span class="number">0x7676</span>, <span class="number">0x4615</span>, <span class="number">0x5634</span>, <span class="number">0xD94C</span>, <span class="number">0xC96D</span>, <span class="number">0xF90E</span>, <span class="number">0xE92F</span>,</span><br><span class="line">            <span class="number">0x99C8</span>, <span class="number">0x89E9</span>, <span class="number">0xB98A</span>, <span class="number">0xA9AB</span>, <span class="number">0x5844</span>, <span class="number">0x4865</span>, <span class="number">0x7806</span>, <span class="number">0x6827</span>,</span><br><span class="line">            <span class="number">0x18C0</span>, <span class="number">0x08E1</span>, <span class="number">0x3882</span>, <span class="number">0x28A3</span>, <span class="number">0xCB7D</span>, <span class="number">0xDB5C</span>, <span class="number">0xEB3F</span>, <span class="number">0xFB1E</span>,</span><br><span class="line">            <span class="number">0x8BF9</span>, <span class="number">0x9BD8</span>, <span class="number">0xABBB</span>, <span class="number">0xBB9A</span>, <span class="number">0x4A75</span>, <span class="number">0x5A54</span>, <span class="number">0x6A37</span>, <span class="number">0x7A16</span>,</span><br><span class="line">            <span class="number">0x0AF1</span>, <span class="number">0x1AD0</span>, <span class="number">0x2AB3</span>, <span class="number">0x3A92</span>, <span class="number">0xFD2E</span>, <span class="number">0xED0F</span>, <span class="number">0xDD6C</span>, <span class="number">0xCD4D</span>,</span><br><span class="line">            <span class="number">0xBDAA</span>, <span class="number">0xAD8B</span>, <span class="number">0x9DE8</span>, <span class="number">0x8DC9</span>, <span class="number">0x7C26</span>, <span class="number">0x6C07</span>, <span class="number">0x5C64</span>, <span class="number">0x4C45</span>,</span><br><span class="line">            <span class="number">0x3CA2</span>, <span class="number">0x2C83</span>, <span class="number">0x1CE0</span>, <span class="number">0x0CC1</span>, <span class="number">0xEF1F</span>, <span class="number">0xFF3E</span>, <span class="number">0xCF5D</span>, <span class="number">0xDF7C</span>,</span><br><span class="line">            <span class="number">0xAF9B</span>, <span class="number">0xBFBA</span>, <span class="number">0x8FD9</span>, <span class="number">0x9FF8</span>, <span class="number">0x6E17</span>, <span class="number">0x7E36</span>, <span class="number">0x4E55</span>, <span class="number">0x5E74</span>,</span><br><span class="line">            <span class="number">0x2E93</span>, <span class="number">0x3EB2</span>, <span class="number">0x0ED1</span>, <span class="number">0x1EF0</span>,&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create a CRC16 checksum from the bytes. implementation is from</span></span><br><span class="line"><span class="comment">     * mp911de/lettuce, modified with some more optimizations</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> CRC16 as integer value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getCRC16</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> crc = <span class="number">0x0000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> b : bytes) &#123;</span><br><span class="line">            crc = ((crc &lt;&lt; <span class="number">8</span>) ^ LOOKUP_TABLE[((crc &gt;&gt;&gt; <span class="number">8</span>) ^ (b &amp; <span class="number">0xFF</span>)) &amp; <span class="number">0xFF</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> crc &amp; <span class="number">0xFFFF</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getCRC16</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getCRC16(key.getBytes(Charset.forName(<span class="string">"UTF-8"</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHashCode</span><span class="params">(String origin)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// optimization with modulo operator with power of 2</span></span><br><span class="line">        <span class="comment">// equivalent to getCRC16(key) % 16384</span></span><br><span class="line">        <span class="keyword">return</span> getCRC16(origin) &amp; (<span class="number">16384</span> - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3）FNV1_32 算法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FnvHashStrategy</span> <span class="keyword">implements</span> <span class="title">HashStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> FNV_32_INIT = <span class="number">2166136261L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FNV_32_PRIME = <span class="number">16777619</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHashCode</span><span class="params">(String origin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> p = FNV_32_PRIME;</span><br><span class="line">        <span class="keyword">int</span> hash = (<span class="keyword">int</span>) FNV_32_INIT;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; origin.length(); i++)</span><br><span class="line">            hash = (hash ^ origin.charAt(i)) * p;</span><br><span class="line">        hash += hash &lt;&lt; <span class="number">13</span>;</span><br><span class="line">        hash ^= hash &gt;&gt; <span class="number">7</span>;</span><br><span class="line">        hash += hash &lt;&lt; <span class="number">3</span>;</span><br><span class="line">        hash ^= hash &gt;&gt; <span class="number">17</span>;</span><br><span class="line">        hash += hash &lt;&lt; <span class="number">5</span>;</span><br><span class="line">        hash = Math.abs(hash);</span><br><span class="line">        <span class="keyword">return</span> hash;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>4）MurmurHash 算法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MurmurHashStrategy</span> <span class="keyword">implements</span> <span class="title">HashStrategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHashCode</span><span class="params">(String origin)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ByteBuffer buf = ByteBuffer.wrap(origin.getBytes());</span><br><span class="line">        <span class="keyword">int</span> seed = <span class="number">0x1234ABCD</span>;</span><br><span class="line"></span><br><span class="line">        ByteOrder byteOrder = buf.order();</span><br><span class="line">        buf.order(ByteOrder.LITTLE_ENDIAN);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> m = <span class="number">0xc6a4a7935bd1e995L</span>;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">47</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> h = seed ^ (buf.remaining() * m);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> k;</span><br><span class="line">        <span class="keyword">while</span> (buf.remaining() &gt;= <span class="number">8</span>) &#123;</span><br><span class="line">            k = buf.getLong();</span><br><span class="line"></span><br><span class="line">            k *= m;</span><br><span class="line">            k ^= k &gt;&gt;&gt; r;</span><br><span class="line">            k *= m;</span><br><span class="line"></span><br><span class="line">            h ^= k;</span><br><span class="line">            h *= m;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (buf.remaining() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ByteBuffer finish = ByteBuffer.allocate(<span class="number">8</span>).order(</span><br><span class="line">                    ByteOrder.LITTLE_ENDIAN);</span><br><span class="line">            <span class="comment">// for big-endian version, do this first:</span></span><br><span class="line">            <span class="comment">// finish.position(8-buf.remaining());</span></span><br><span class="line">            finish.put(buf).rewind();</span><br><span class="line">            h ^= finish.getLong();</span><br><span class="line">            h *= m;</span><br><span class="line">        &#125;</span><br><span class="line">        h ^= h &gt;&gt;&gt; r;</span><br><span class="line">        h *= m;</span><br><span class="line">        h ^= h &gt;&gt;&gt; r;</span><br><span class="line"></span><br><span class="line">        buf.order(byteOrder);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) (h &amp; <span class="number">0xffffffffL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>5）Ketama 算法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KetamaHashStrategy</span> <span class="keyword">implements</span> <span class="title">HashStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MessageDigest md5Digest;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            md5Digest = MessageDigest.getInstance(<span class="string">"MD5"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"MD5 not supported"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHashCode</span><span class="params">(String origin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bKey = computeMd5(origin);</span><br><span class="line">        <span class="keyword">long</span> rv = ((<span class="keyword">long</span>) (bKey[<span class="number">3</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">24</span>)</span><br><span class="line">                | ((<span class="keyword">long</span>) (bKey[<span class="number">2</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">16</span>)</span><br><span class="line">                | ((<span class="keyword">long</span>) (bKey[<span class="number">1</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">8</span>)</span><br><span class="line">                | (bKey[<span class="number">0</span>] &amp; <span class="number">0xFF</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) (rv &amp; <span class="number">0xffffffffL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the md5 of the given key.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] computeMd5(String k) &#123;</span><br><span class="line">        MessageDigest md5;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            md5 = (MessageDigest) md5Digest.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"clone of MD5 not supported"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        md5.update(k.getBytes());</span><br><span class="line">        <span class="keyword">return</span> md5.digest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>相对来说，在一致性哈希算法中，FNV，MurmurHash及Ketama是相对较好的算法，用的场景也较多。</p>
<h2 id="3-算法分析"><a href="#3-算法分析" class="headerlink" title="3. 算法分析"></a>3. 算法分析</h2><p>在一致性算法中，需要将哈希值空间组织成一个虚拟的哈希环，服务器结点的哈希值放置在该哈希环上，查找离请求key的哈希值最近的值。在这里提到要构建一个哈希环，它的底层数据结构是什么样的？我们可以转换一个思路，在算法中，最重要的环节是匹配两个最近的哈希值，是否可以将服务器的哈希值存储到一个有序的数据列表中，匹配的操作就是找一个小于等待key的最大值。为了提高查询效率，底层的数据结构一般使用红黑树。下面分析一致性哈希算法的一种可能实现，该算法由作者<a href="https://www.cnkirito.moe/consistent-hash-lb/" target="_blank" rel="noopener">徐靖峰</a>实现，代码的github地址：<a href="https://github.com/lexburner/consistent-hash-algorithm" target="_blank" rel="noopener">https://github.com/lexburner/consistent-hash-algorithm</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsistentHashLoadBalancer</span> <span class="keyword">implements</span> <span class="title">LoadBalancer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  使用的哈希算法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> HashStrategy hashStrategy = <span class="keyword">new</span> FnvHashStrategy();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  虚拟结点的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> VIRTUAL_NODE_SIZE = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  服务器与虚拟结点的连接符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String VIRTUAL_NODE_SUFFIX = <span class="string">"&amp;&amp;"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据请求匹配服务器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> servers 服务器数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocation 封装了调用的请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回匹配的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Server <span class="title">select</span><span class="params">(List&lt;Server&gt; servers, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> invocationHashCode = hashStrategy.getHashCode(invocation.getHashKey());</span><br><span class="line">        TreeMap&lt;Integer, Server&gt; ring = buildConsistentHashRing(servers);</span><br><span class="line">        Server server = locate(ring, invocationHashCode);</span><br><span class="line">        <span class="keyword">return</span> server;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从TreeMap中找出高key最近的服务器，如果没有服务器匹配，</span></span><br><span class="line"><span class="comment">     * 则返回第一值，形成一个环</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ring 存储服务器结点的哈希</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocationHashCode 封装了调用的请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Server <span class="title">locate</span><span class="params">(TreeMap&lt;Integer, Server&gt; ring, <span class="keyword">int</span> invocationHashCode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 向右找到第一个 key</span></span><br><span class="line">        Map.Entry&lt;Integer, Server&gt; locateEntry = ring.ceilingEntry(invocationHashCode);</span><br><span class="line">        <span class="keyword">if</span> (locateEntry == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 想象成一个环，超过尾部则取第一个 key</span></span><br><span class="line">            locateEntry = ring.firstEntry();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> locateEntry.getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建一个带虚拟结点的哈希环，使用TreeMap结构，底层是红黑树，</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> servers 服务器数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回服务器数组的哈希环</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeMap&lt;Integer, Server&gt; <span class="title">buildConsistentHashRing</span><span class="params">(List&lt;Server&gt; servers)</span> </span>&#123;</span><br><span class="line">        TreeMap&lt;Integer, Server&gt; virtualNodeRing = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Server server : servers) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; VIRTUAL_NODE_SIZE; i++) &#123;</span><br><span class="line">                <span class="comment">// 新增虚拟节点的方式如果有影响，也可以抽象出一个由物理节点扩展虚拟节点的类</span></span><br><span class="line">                virtualNodeRing.put(hashStrategy.getHashCode(server.getUrl() + VIRTUAL_NODE_SUFFIX + i), server);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> virtualNodeRing;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在该算法中，使用TreeMap的ceilingEntry方法返回离key的哈希值最近的服务器。</p>
<p>除了上面的一致性哈希算法的实现，还有一种实现，即Ketama算法，它不仅仅是一个哈希算法，更是一套完整的一致性哈希算法，在memcached中，其介绍如下：</p>
<blockquote>
<p>Ketama is an implementation of a consistent hashing algorithm, meaning you can add or remove servers from the memcached pool without causing a complete remap of all keys.<br>Here’s how it works:</p>
<ul>
<li>Take your list of servers (eg: 1.2.3.4:11211, 5.6.7.8:11211, 9.8.7.6:11211)</li>
<li>Hash each server string to several (100-200) unsigned ints</li>
<li>Conceptually, these numbers are placed on a circle called the continuum. (imagine a clock face that goes from 0 to 2^32)</li>
<li>Each number links to the server it was hashed from, so servers appear at several points on the continuum, by each of the numbers they hashed to.</li>
<li>To map a key-&gt;server, hash your key to a single unsigned int, and find the next biggest number on the continuum. The server linked to that number is the correct server for that key.</li>
<li>If you hash your key to a value near 2^32 and there are no points on the continuum greater than your hash, return the first server in the continuum.<br>If you then add or remove a server from the list, only a small proportion of keys end up mapping to different servers.</li>
</ul>
</blockquote>
<p>代码实现如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KetamaConsistentHashLoadBalancer</span> <span class="keyword">implements</span> <span class="title">LoadBalancer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MessageDigest md5Digest;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            md5Digest = MessageDigest.getInstance(<span class="string">"MD5"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"MD5 not supported"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  虚拟结点的个数，虚拟结点一般以4个为一组计算，所以数量一般同4的倍数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> VIRTUAL_NODE_SIZE = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  服务器与虚拟结点的连接符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String VIRTUAL_NODE_SUFFIX = <span class="string">"-"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据请求匹配服务器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> servers 服务器数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocation 封装了调用的请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回匹配的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Server <span class="title">select</span><span class="params">(List&lt;Server&gt; servers, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> invocationHashCode = getHashCode(invocation.getHashKey());</span><br><span class="line">        TreeMap&lt;Long, Server&gt; ring = buildConsistentHashRing(servers);</span><br><span class="line">        Server server = locate(ring, invocationHashCode);</span><br><span class="line">        <span class="keyword">return</span> server;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从TreeMap中找出高key最近的服务器，如果没有服务器匹配，</span></span><br><span class="line"><span class="comment">     * 则返回第一值，形成一个环</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ring 存储服务器结点的哈希</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocationHashCode 封装了调用的请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Server <span class="title">locate</span><span class="params">(TreeMap&lt;Long, Server&gt; ring, Long invocationHashCode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 向右找到第一个 key</span></span><br><span class="line">        Map.Entry&lt;Long, Server&gt; locateEntry = ring.ceilingEntry(invocationHashCode);</span><br><span class="line">        <span class="keyword">if</span> (locateEntry == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 想象成一个环，超过尾部则取第一个 key</span></span><br><span class="line">            locateEntry = ring.firstEntry();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> locateEntry.getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建一个带虚拟结点的哈希环，使用TreeMap结构，底层是红黑树，</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> servers 服务器数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回服务器数组的哈希环</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeMap&lt;Long, Server&gt; <span class="title">buildConsistentHashRing</span><span class="params">(List&lt;Server&gt; servers)</span> </span>&#123;</span><br><span class="line">        TreeMap&lt;Long, Server&gt; virtualNodeRing = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Server server : servers) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; VIRTUAL_NODE_SIZE / <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">byte</span>[] digest = computeMd5(server.getUrl() + VIRTUAL_NODE_SUFFIX + i);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; <span class="number">4</span>; h++) &#123;</span><br><span class="line">                    <span class="comment">// 将digest数组按4个byte为一组，通过位操作产生一个最大32位的长整数，</span></span><br><span class="line">                    <span class="comment">// 一个16 byte的MD5，可以生成4个哈希值，即4个虚拟结点，所以一般将虚拟结点按照</span></span><br><span class="line">                    <span class="comment">// 4个为一组进行计算。</span></span><br><span class="line">                    Long k = ((<span class="keyword">long</span>) (digest[<span class="number">3</span> + h * <span class="number">4</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">24</span>)</span><br><span class="line">                            | ((<span class="keyword">long</span>) (digest[<span class="number">2</span> + h * <span class="number">4</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">16</span>)</span><br><span class="line">                            | ((<span class="keyword">long</span>) (digest[<span class="number">1</span> + h * <span class="number">4</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">8</span>)</span><br><span class="line">                            | (digest[h * <span class="number">4</span>] &amp; <span class="number">0xFF</span>);</span><br><span class="line">                    virtualNodeRing.put(k, server);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> virtualNodeRing;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算字符串的Ketama哈希值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> origin key值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 哈希值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">getHashCode</span><span class="params">(String origin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bKey = computeMd5(origin);</span><br><span class="line">        <span class="comment">// 使用前4个字符进行位运算得到32位的整数。</span></span><br><span class="line">        <span class="keyword">long</span> rv = ((<span class="keyword">long</span>) (bKey[<span class="number">3</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">24</span>)</span><br><span class="line">                | ((<span class="keyword">long</span>) (bKey[<span class="number">2</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">16</span>)</span><br><span class="line">                | ((<span class="keyword">long</span>) (bKey[<span class="number">1</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">8</span>)</span><br><span class="line">                | (bKey[<span class="number">0</span>] &amp; <span class="number">0xFF</span>);</span><br><span class="line">        <span class="keyword">return</span> rv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key生成16位的MD5摘要，因此digest数组共16位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> MD5摘</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] computeMd5(String k) &#123;</span><br><span class="line">        MessageDigest md5;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            md5 = (MessageDigest) md5Digest.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"clone of MD5 not supported"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        md5.update(k.getBytes());</span><br><span class="line">        <span class="keyword">return</span> md5.digest();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>在Ketama一致性哈希算法中，以四个虚拟结点为一组，将服务器名称以Md5编码后，得到16个字节的编码，每个虚拟结点对应Md5码16个字节中的4个，组成一个long型数值，做为这个虚拟结点在环中的惟一key。请求key的哈希值则以Md5中的前4个字节计算得到。</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>在 <a href="https://www.cnblogs.com/xrq730/p/5186728.html" target="_blank" rel="noopener">对一致性Hash算法，Java代码实现的深入研究</a> 这篇文章中，作者通过数据分析，得出使用MurmurHash，FNV及Ketama这三种哈希算法，都能得到较好的性能，具有很好的参考意义。</p>
<p><strong>参考：</strong></p>
<hr>
<p><a href="https://www.oschina.net/translate/state-of-hash-functions" target="_blank" rel="noopener">1. Hash 函数概览</a></p>
<p><a href="https://www.cnkirito.moe/consistent-hash-lb/" target="_blank" rel="noopener">2. 一致性哈希负载均衡算法的探讨</a></p>
<p><a href="http://blog.codinglabs.org/articles/consistent-hashing.html" target="_blank" rel="noopener">3. 一致性哈希算法及其在分布式系统中的应用</a></p>
<p><a href="https://www.cnblogs.com/xrq730/p/5186728.html" target="_blank" rel="noopener">4. 对一致性Hash算法，Java代码实现的深入研究</a></p>
<p><a href="https://www.iteye.com/blog/langyu-684087" target="_blank" rel="noopener">5. Ketama一致性Hash算法(含Java代码)</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/16/skip-list/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Noahsark">
      <meta itemprop="description" content="不畏将来，不念过往">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以太格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/10/16/skip-list/" class="post-title-link" itemprop="http://yoursite.com/page/4/index.html">跳跃表</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-10-16 08:57:31" itemprop="dateCreated datePublished" datetime="2019-10-16T08:57:31+08:00">2019-10-16</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-07-31 17:17:10" itemprop="dateModified" datetime="2021-07-31T17:17:10+08:00">2021-07-31</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构与算法/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">38k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">35 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>跳跃表是一种数据结构。它允许快速查询一个有序连续元素的数据链表。跳跃表的平均查找和插入时间复杂度都是O(logn)，优于普通队列的O(n)。快速查询是通过维护一个多层次的链表，且每一层链表中的元素是前一层链表元素的子集。一开始时，算法在最稀疏的层次进行搜索，直至需要查找的元素在该层两个相邻的元素中间。这时，算法将跳转到下一个层次，重复刚才的搜索，直到找到需要查找的元素为止，跳跃表示意图如下所示。<br><img src="/images/skip-list.png" alt="skip-list" title="skip-list"><br>从图中可以看到， 跳跃表主要由以下部分构成：</p>
<ul>
<li>表头（head）：负责维护跳跃表的节点指针；</li>
<li>跳跃表节点：保存着元素值，以及多个层。</li>
<li>层：保存着指向其他元素的指针，高层的指针越过的元素数量大于等于低层的指针，为了提高查找的效率，程序总是从高层先开始访问，然后随着元素值范围的缩小，慢慢降低层次。</li>
<li>表尾：全部由 NULL 组成，表示跳跃表的末尾。</li>
</ul>
<p>本篇文章将以redis中的跳跃表为例进行介绍，代码用java进行了重写，为方便看懂，简化了部分流程。</p>
<h2 id="2-层数"><a href="#2-层数" class="headerlink" title="2. 层数"></a>2. 层数</h2><p>跳跃表是按照层构建的，每一层都是一个有序链表，最底层包含了所有的元素，每一个更高层都包含了指向下层的指针，也可以说高层是下层数据的“索引”。通过对高层数据的检索可以实现类似二分查找的效果，但是要准确判断出数据是否出现在高层通且对之前数据的层次进行调整是一个复杂的过程，要实现的算法可以参考AVL树和红黑树。在跳跃表中，通过概率的方式，近似得出数据的层数，简化操作。</p>
<p>每个更高层都充当下面列表的“快速通道”，在第i层中的元素按某个固定的概率p（通常为1/2或1/4出现在第i+1层），以Redis中的跳跃表为例：</p>
<blockquote>
<p>level 1的概率为 0.75<br>level 2的概率为 0.75 * 0.25<br>level 3的概率为 0.75 * 0.25 * 0.25<br>…<br>level 31的概率为 0.75 * 0.25^30<br>level 32的概率为 0.75 * 0.25^31</p>
</blockquote>
<p>代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">zslRandomLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((random.nextInt() &amp; <span class="number">0xFFFF</span>) &lt; (ZSKIPLIST_P * <span class="number">0xFFFF</span>)) &#123;</span><br><span class="line">        level += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (level &lt; ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中ZSKIPLIST_MAXLEVEL为32，ZSKIPLIST_P为0.25（即1/4）,random.nextInt() &amp; 0xFFFF为16位整数，ZSKIPLIST_P * 0xFFFF为16位整数的1/4。从概率学的角度来说，大于ZSKIPLIST_P * 0xFFFF的概率为3/4，即level 1的概率是0.75，level 2，概率是0.75 * 0.25，后面的层次依次类推。</p>
<p>在介绍跳跃表的插入和删除之前，先看下跳跃表的数据结构（参考redis的实现进行了简化）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZSkipList</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;? <span class="title">super</span> <span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最大层数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ZSKIPLIST_MAXLEVEL = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// P，概率</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> ZSKIPLIST_P = <span class="number">0.25</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 头结点</span></span><br><span class="line">    <span class="keyword">private</span> ZSkipListNode&lt;T&gt; header;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点总数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 层数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> level;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机数</span></span><br><span class="line">    <span class="keyword">private</span> Random random;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ZSkipList</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.level = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        ZSkipListNode&lt;T&gt; nullNode = <span class="keyword">new</span> ZSkipListNode&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.header = <span class="keyword">new</span> ZSkipListNode&lt;&gt;(<span class="keyword">null</span>, ZSKIPLIST_MAXLEVEL);</span><br><span class="line"></span><br><span class="line">        random = <span class="keyword">new</span> Random();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  结点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ZSkipListNode</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;? <span class="title">super</span> <span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 键值</span></span><br><span class="line">        T key;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 层次</span></span><br><span class="line">        ZSkipListLevel&lt;T&gt;[] levels;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ZSkipListNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ZSkipListNode</span><span class="params">(T key, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.levels = <span class="keyword">new</span> ZSkipListLevel[level];</span><br><span class="line"></span><br><span class="line">            ZSkipListLevel&lt;T&gt; listLevel = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; level ; i++) &#123;</span><br><span class="line">                listLevel = <span class="keyword">new</span> ZSkipListLevel&lt;&gt;();</span><br><span class="line">                <span class="keyword">this</span>.levels[i] = listLevel;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  层</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ZSkipListLevel</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;? <span class="title">super</span> <span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下一个结点</span></span><br><span class="line">        ZSkipListNode&lt;T&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跨度，当前结点与后继结点蹭相隔几个结点</span></span><br><span class="line">        <span class="keyword">int</span> span;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ZSkipListLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.span = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-插入"><a href="#3-插入" class="headerlink" title="3. 插入"></a>3. 插入</h2><p>插入操作的步骤：</p>
<ul>
<li>1）找出插入结点每一层的前驱结点及排名；</li>
<li>2）随机生成插入结点的层数；</li>
<li>3）在每一层链表中插入结点，修改结点跨度；</li>
<li>4）更新结点数。</li>
</ul>
<p>代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向跳跃表中插入结点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 插入元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Preconditions.checkNotNull(key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// update存放插入结点每一层的前驱结点，</span></span><br><span class="line">    ZSkipListNode&lt;T&gt;[] update = <span class="keyword">new</span> ZSkipListNode[ZSKIPLIST_MAXLEVEL];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rank存放结点在每一层上的排名</span></span><br><span class="line">    <span class="keyword">int</span> [] rank = <span class="keyword">new</span> <span class="keyword">int</span>[ZSKIPLIST_MAXLEVEL];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于遍历插入结点的位置</span></span><br><span class="line">    ZSkipListNode&lt;T&gt; creeper = header;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *   1、找到每一个层次的前驱结点及每一个层次的排名。</span></span><br><span class="line"><span class="comment">     *  从最顶层开始遍历,从上往下查的插入结点的位置,如果在该层中结点大于插入结点的值,</span></span><br><span class="line"><span class="comment">     *  则移向该结点的下一层开始查找,同时记录插入结点的排名,用于计算插入结点与前一个</span></span><br><span class="line"><span class="comment">     *  结点之间的跨度(span).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用于插入结点在某一个层次的排名,在最高层排名默认值为0;</span></span><br><span class="line">        <span class="comment">// 非最高层默认值上一个层次的值,会在下面的循环中依次增加排名.</span></span><br><span class="line">        rank[i] = i == level-<span class="number">1</span> ? <span class="number">0</span> : rank[i+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前结点小于等于插入结点,则继续查找.</span></span><br><span class="line">        <span class="keyword">while</span> (creeper.levels[i].next != <span class="keyword">null</span> &amp;&amp; key.compareTo(creeper.levels[i].next.key) &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 排名数加上当前结点到一个结点之间的跨度</span></span><br><span class="line">            rank[i] += creeper.levels[i].span;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 指向后继结点</span></span><br><span class="line">            creeper = creeper.levels[i].next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到当前层次中后继结点大于等于插入结点的结点,作为插入结点的前驱结点</span></span><br><span class="line">        update[i] = creeper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、随机生成插入结点的层次</span></span><br><span class="line">    <span class="comment">// 用冥次定律,生成一个随机的层次</span></span><br><span class="line">    <span class="keyword">int</span> newLevel = zslRandomLevel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果生成的层次大于当前跳跃表的最大层次,则初始化大于的层次.</span></span><br><span class="line">    <span class="keyword">if</span> (newLevel &gt; level) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = level ; i &lt; newLevel ; i++) &#123;</span><br><span class="line">            rank[i] = <span class="number">0</span>;</span><br><span class="line">            update[i] = header;</span><br><span class="line">            update[i].levels[i].span = <span class="keyword">this</span>.length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.level = newLevel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//System.out.println("newLevel = " + newLevel + " ; key=" + key);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新建插入的结点</span></span><br><span class="line">    ZSkipListNode&lt;T&gt; node = <span class="keyword">new</span> ZSkipListNode&lt;&gt;(key, level);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *  3、插入结点及更新跨度</span></span><br><span class="line"><span class="comment">    *  1）在每一个层次中插入一个结点，该操作就是链表的插入操作，比较简单；</span></span><br><span class="line"><span class="comment">    *  2）更新产驱结点及当前结点的跨度。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; newLevel; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.1 插入结点的后继结点指向前驱结点的后继结点；</span></span><br><span class="line">        <span class="comment">// 3.2 前驱结点的后继结点指向插入结点。</span></span><br><span class="line">        node.levels[i].next = update[i].levels[i].next;</span><br><span class="line">        update[i].levels[i].next = node;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 插入一个新结点，等于在前驱结点与其后继结点之间插入一个结点，之前的</span></span><br><span class="line"><span class="comment">        *  span等于前驱结点与其后继结点之间的跨度，现在一分为二：前驱结点与插入结点的跨度和</span></span><br><span class="line"><span class="comment">        *  插入结点与后继结点的跨度。前一个值即为前驱结点的跨度，等于上下两个层次排名的差值，</span></span><br><span class="line"><span class="comment">        *  后一个值即为插入结点的跨度，等于前驱结点原先的span减去前一个值。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        node.levels[i].span = update[i].levels[i].span - (rank[<span class="number">0</span>] - rank[i]);</span><br><span class="line">        update[i].levels[i].span = (rank[<span class="number">0</span>] - rank[i]) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果插入结点的层次小于当前最大的层数，则更新高层的spsn。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = newLevel; i &lt; <span class="keyword">this</span>.level; i++) &#123;</span><br><span class="line">        update[i].levels[i].span++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 结点数加1.</span></span><br><span class="line">    <span class="keyword">this</span>.length++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以插入12, 45, 63, 21, 99, 87, 23, 47, 30, 50数组为例，分析插入结点的流程，图形的格式说明：head[00](01)–&gt;12(00)，定义为head[层数](跨度,当前结点与下一个结点之间相隔结点数)–&gt;下一个结点(跨度)。</p>
<ul>
<li><p>1）插入12，层数为1，当前只有一层，12为最底层的第一个结点，头结点到12中间的跨度为1（包括12在内）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new node = 12, level = 1</span><br><span class="line"></span><br><span class="line">head[00](01)--&gt;12(00)</span><br></pre></td></tr></table></figure>
</li>
<li><p>2）插入45，层数为2，跳跃表新增一层，在两层中插入45，其中第二层头结点到45结点的跨度为2（包括45在内）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new node = 45, level = 2 </span><br><span class="line"></span><br><span class="line">head[01](02)-----------&gt;45(00)</span><br><span class="line">head[00](01)--&gt;12(01)--&gt;45(00)</span><br></pre></td></tr></table></figure>
</li>
<li><p>3）插入63，层数为1，只插入到第一层。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new node = 63, level = 1 </span><br><span class="line"></span><br><span class="line">head[01](02)-----------&gt;45(01)</span><br><span class="line">head[00](01)--&gt;12(01)--&gt;45(01)--&gt;63(00)</span><br></pre></td></tr></table></figure>
</li>
<li><p>4）插入21，层数为2。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new node = 21, level = 2 </span><br><span class="line"></span><br><span class="line">head[01](02)-----------&gt;21(01)--&gt;45(01)</span><br><span class="line">head[00](01)--&gt;12(01)--&gt;21(01)--&gt;45(01)--&gt;63(00)</span><br></pre></td></tr></table></figure>
</li>
<li><p>5）插入99，层数为1。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new node = 99, level = 1 </span><br><span class="line"></span><br><span class="line">head[01](02)-----------&gt;21(01)--&gt;45(02)</span><br><span class="line">head[00](01)--&gt;12(01)--&gt;21(01)--&gt;45(01)--&gt;63(01)--&gt;99(00)</span><br></pre></td></tr></table></figure>
</li>
<li><p>6）插入87，层数为1。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new node = 87, level = 1 </span><br><span class="line"></span><br><span class="line">head[01](02)-----------&gt;21(01)--&gt;45(03)</span><br><span class="line">head[00](01)--&gt;12(01)--&gt;21(01)--&gt;45(01)--&gt;63(01)--&gt;87(01)--&gt;99(00)</span><br></pre></td></tr></table></figure>
</li>
<li><p>7）插入23，层数为1。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new node = 23, level = 1 </span><br><span class="line"></span><br><span class="line">head[01](02)-----------&gt;21(02)-----------&gt;45(03)</span><br><span class="line">head[00](01)--&gt;12(01)--&gt;21(01)--&gt;23(01)--&gt;45(01)--&gt;63(01)--&gt;87(01)--&gt;99(00)</span><br></pre></td></tr></table></figure>
</li>
<li><p>8）插入47，层数为2。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new node = 47, level = 2 </span><br><span class="line"></span><br><span class="line">head[01](02)-----------&gt;21(02)-----------&gt;45(01)--&gt;47(03)</span><br><span class="line">head[00](01)--&gt;12(01)--&gt;21(01)--&gt;23(01)--&gt;45(01)--&gt;47(01)--&gt;63(01)--&gt;87(01)--&gt;99(00)</span><br></pre></td></tr></table></figure>
</li>
<li><p>9）插入30，层数为1。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new node = 30, level = 1 </span><br><span class="line"></span><br><span class="line">head[01](02)-----------&gt;21(03)--------------------&gt;45(01)--&gt;47(03)</span><br><span class="line">head[00](01)--&gt;12(01)--&gt;21(01)--&gt;23(01)--&gt;30(01)--&gt;45(01)--&gt;47(01)--&gt;63(01)--&gt;87(01)--&gt;99(00)</span><br></pre></td></tr></table></figure>
</li>
<li><p>10）插入87，层数为4。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new node = 50, level = 4 </span><br><span class="line"></span><br><span class="line">head[03](07)--------------------------------------------------------&gt;50(03)</span><br><span class="line">head[02](07)--------------------------------------------------------&gt;50(03)</span><br><span class="line">head[01](02)-----------&gt;21(03)--------------------&gt;45(01)--&gt;47(01)--&gt;50(03)</span><br><span class="line">head[00](01)--&gt;12(01)--&gt;21(01)--&gt;23(01)--&gt;30(01)--&gt;45(01)--&gt;47(01)--&gt;50(01)--&gt;63(01)--&gt;87(01)--&gt;99(00)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="4-删除"><a href="#4-删除" class="headerlink" title="4. 删除"></a>4. 删除</h2><p>删除操作的步骤为：</p>
<ul>
<li>1）找出删除结点每一层的前驱结点；</li>
<li>2）将前驱结点的后继结点指向删除指点的后继结点，并修改前驱结点的跨度；</li>
<li>3）删除空的层并对结点数减一。</li>
</ul>
<p>跳跃表的删除实际就是单向链表的删除，其代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除一个已有结点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、找到key对应的结点</span></span><br><span class="line">    Preconditions.checkNotNull(key);</span><br><span class="line"></span><br><span class="line">    ZSkipListNode&lt;T&gt;[] update = <span class="keyword">new</span> ZSkipListNode[ZSKIPLIST_MAXLEVEL];</span><br><span class="line">    <span class="comment">// 获取前驱结点</span></span><br><span class="line">    predecessorLevels(key, update);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一层的后继结点有可能是删除的结点(有可能删除一个不存在的结点)</span></span><br><span class="line">    ZSkipListNode&lt;T&gt; node = update[<span class="number">0</span>].levels[<span class="number">0</span>].next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否是删除的结点</span></span><br><span class="line">    <span class="keyword">if</span> (key.compareTo(node.key) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.level; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (update[i].levels[i].next == node) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 前驱结点的跨度等于之前的跨度再加上删除结点的跨度,再减去删除结点.</span></span><br><span class="line">                update[i].levels[i].span += node.levels[i].span -<span class="number">1</span>;</span><br><span class="line">                update[i].levels[i].next = node.levels[i].next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                update[i].levels[i].span -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清理空的层</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">this</span>.level &gt; <span class="number">1</span> &amp;&amp; <span class="keyword">this</span>.header.levels[<span class="keyword">this</span>.level-<span class="number">1</span>].next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.level--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 结点数减一</span></span><br><span class="line">        <span class="keyword">this</span>.length--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取每一层的前驱结点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> update</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">predecessorLevels</span><span class="params">(T key, ZSkipListNode&lt;T&gt;[] update)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ZSkipListNode&lt;T&gt; creeper = header;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (creeper.levels[i].next != <span class="keyword">null</span> &amp;&amp; key.compareTo(creeper.levels[i].next.key) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            creeper = creeper.levels[i].next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        update[i] = creeper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>删除实例如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">删除前的跳跃表：</span><br><span class="line">head[03](04)-----------------------------&gt;30(06)</span><br><span class="line">head[02](04)-----------------------------&gt;30(05)--------------------------------------&gt;87(01)</span><br><span class="line">head[01](01)--&gt;12(01)--&gt;21(02)-----------&gt;30(05)--------------------------------------&gt;87(01)</span><br><span class="line">head[00](01)--&gt;12(01)--&gt;21(01)--&gt;23(01)--&gt;30(01)--&gt;45(01)--&gt;47(01)--&gt;50(01)--&gt;63(01)--&gt;87(01)--&gt;99(00)</span><br><span class="line"></span><br><span class="line">删除30后的跳跃表：</span><br><span class="line">head[02](08)-----------------------------------------------------------------&gt;87(01)</span><br><span class="line">head[01](01)--&gt;12(01)--&gt;21(06)-----------------------------------------------&gt;87(01)</span><br><span class="line">head[00](01)--&gt;12(01)--&gt;21(01)--&gt;23(01)--&gt;45(01)--&gt;47(01)--&gt;50(01)--&gt;63(01)--&gt;87(01)--&gt;99(00)</span><br></pre></td></tr></table></figure></p>
<p>在每一层的链表中都会删除30这个结点，同时更新前驱结点的跨度。因为第4层只有30这个结点，删除之后，该层没有结点，就要减少跳跃表的层数。</p>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>跳跃表的发明者对其的评价：</p>
<blockquote>
<p>跳跃列表是在很多应用中有可能替代平衡树而作为实现方法的一种数据结构。跳跃列表的算法有同平衡树一样的渐进的预期时间边界，并且更简单、更快速和使用更少的空间</p>
</blockquote>
<p>跳跃表相对平衡二叉树而言，实现简单，又能在近似O(logn)时间复杂度的情况下实现数据的检索和插入，这或许也是在redis中使用跳跃表代替红黑树的原因之一。</p>
<p><strong>参考：</strong></p>
<hr>
<p><a href="https://zh.wikipedia.org/wiki/%E8%B7%B3%E8%B7%83%E5%88%97%E8%A1%A8" target="_blank" rel="noopener">1. 跳跃列表</a></p>
<p><a href="https://www.jianshu.com/p/58bab10b7ab9" target="_blank" rel="noopener">2. Redis 源码研究之skiplist</a></p>
<p><a href="http://download.redis.io/redis-stable/src/t_zset.c" target="_blank" rel="noopener">3. redis源码</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Noahsark</p>
              <p class="site-description motion-element" itemprop="description">不畏将来，不念过往</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">50</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">21</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">164</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Noahsark</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数">197k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
    <span title="站点阅读时长">2:59</span>
  
</div>

<div class="BbeiAn-info">
    <a target="_blank" href="https://beian.miit.gov.cn/" rel="nofollow">粤ICP备 2021097726号-1 </a>
	<a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44030702004132" style="text-decoration:none;padding-left:30px;background:url(https://s1.ax1x.com/2018/09/29/ilmwIH.png) no-repeat left center" rel="nofollow">粤公网安备 44030702004132号</a>
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v6.5.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.5.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.5.0"></script>



  



  










  





  

  

  

  

  

  
  

  

  

  

  

  

  

</body>
</html>
